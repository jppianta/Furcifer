# -*- coding: utf-8 -*-
"""
Provides the default implementation of :class:`ArrowFactory <arrow.factory.ArrowFactory>`
methods for use as a module API.

"""

from __future__ import absolute_import

from arrow.factory import ArrowFactory

# internal default factory.
_factory = ArrowFactory()


def get(*args, **kwargs):
    """ Calls the default :class:`ArrowFactory <arrow.factory.ArrowFactory>` ``get`` method.

    """

    return _factory.get(*args, **kwargs)


get.__doc__ = _factory.get.__doc__


def utcnow():
    """ Calls the default :class:`ArrowFactory <arrow.factory.ArrowFactory>` ``utcnow`` method.

    """

    return _factory.utcnow()


utcnow.__doc__ = _factory.utcnow.__doc__


def now(tz=None):
    """ Calls the default :class:`ArrowFactory <arrow.factory.ArrowFactory>` ``now`` method.

    """

    return _factory.now(tz)


now.__doc__ = _factory.now.__doc__


def factory(type):
    """ Returns an :class:`.ArrowFactory` for the specified :class:`Arrow <arrow.arrow.Arrow>`
    or derived type.

    :param type: the type, :class:`Arrow <arrow.arrow.Arrow>` or derived.

    """

    return ArrowFactory(type)


__all__ = ["get", "utcnow", "now", "factory"]
# -*- coding: utf-8 -*-
"""
Provides the :class:`Arrow <arrow.arrow.Arrow>` class, an enhanced ``datetime``
replacement.

"""

from __future__ import absolute_import

import calendar
import sys
from datetime import datetime, timedelta
from datetime import tzinfo as dt_tzinfo
from math import trunc

from dateutil import tz as dateutil_tz
from dateutil.relativedelta import relativedelta

from arrow import formatter, locales, parser, util


class Arrow(object):
    """An :class:`Arrow <arrow.arrow.Arrow>` object.

    Implements the ``datetime`` interface, behaving as an aware ``datetime`` while implementing
    additional functionality.

    :param year: the calendar year.
    :param month: the calendar month.
    :param day: the calendar day.
    :param hour: (optional) the hour. Defaults to 0.
    :param minute: (optional) the minute, Defaults to 0.
    :param second: (optional) the second, Defaults to 0.
    :param microsecond: (optional) the microsecond. Defaults 0.
    :param tzinfo: (optional) A timezone expression.  Defaults to UTC.

    .. _tz-expr:

    Recognized timezone expressions:

        - A ``tzinfo`` object.
        - A ``str`` describing a timezone, similar to 'US/Pacific', or 'Europe/Berlin'.
        - A ``str`` in ISO 8601 style, as in '+07:00'.
        - A ``str``, one of the following:  'local', 'utc', 'UTC'.

    Usage::

        >>> import arrow
        >>> arrow.Arrow(2013, 5, 5, 12, 30, 45)
        <Arrow [2013-05-05T12:30:45+00:00]>

    """

    resolution = datetime.resolution

    _ATTRS = ["year", "month", "day", "hour", "minute", "second", "microsecond"]
    _ATTRS_PLURAL = ["{}s".format(a) for a in _ATTRS]
    _MONTHS_PER_QUARTER = 3
    _SECS_PER_MINUTE = float(60)
    _SECS_PER_HOUR = float(60 * 60)
    _SECS_PER_DAY = float(60 * 60 * 24)
    _SECS_PER_WEEK = float(60 * 60 * 24 * 7)
    _SECS_PER_MONTH = float(60 * 60 * 24 * 30.5)
    _SECS_PER_YEAR = float(60 * 60 * 24 * 365.25)

    def __init__(
        self, year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None
    ):
        if tzinfo is None:
            tzinfo = dateutil_tz.tzutc()
        # detect that tzinfo is a pytz object (issue #626)
        elif (
            isinstance(tzinfo, dt_tzinfo)
            and hasattr(tzinfo, "localize")
            and hasattr(tzinfo, "zone")
            and tzinfo.zone
        ):
            tzinfo = parser.TzinfoParser.parse(tzinfo.zone)
        elif util.isstr(tzinfo):
            tzinfo = parser.TzinfoParser.parse(tzinfo)

        self._datetime = datetime(
            year, month, day, hour, minute, second, microsecond, tzinfo
        )

    # factories: single object, both original and from datetime.

    @classmethod
    def now(cls, tzinfo=None):
        """Constructs an :class:`Arrow <arrow.arrow.Arrow>` object, representing "now" in the given
        timezone.

        :param tzinfo: (optional) a ``tzinfo`` object. Defaults to local time.

        Usage::

            >>> arrow.now('Asia/Baku')
            <Arrow [2019-01-24T20:26:31.146412+04:00]>

        """

        if tzinfo is None:
            tzinfo = dateutil_tz.tzlocal()
        dt = datetime.now(tzinfo)

        return cls(
            dt.year,
            dt.month,
            dt.day,
            dt.hour,
            dt.minute,
            dt.second,
            dt.microsecond,
            dt.tzinfo,
        )

    @classmethod
    def utcnow(cls):
        """ Constructs an :class:`Arrow <arrow.arrow.Arrow>` object, representing "now" in UTC
        time.

        Usage::

            >>> arrow.utcnow()
            <Arrow [2019-01-24T16:31:40.651108+00:00]>

        """

        dt = datetime.now(dateutil_tz.tzutc())

        return cls(
            dt.year,
            dt.month,
            dt.day,
            dt.hour,
            dt.minute,
            dt.second,
            dt.microsecond,
            dt.tzinfo,
        )

    @classmethod
    def fromtimestamp(cls, timestamp, tzinfo=None):
        """ Constructs an :class:`Arrow <arrow.arrow.Arrow>` object from a timestamp, converted to
        the given timezone.

        :param timestamp: an ``int`` or ``float`` timestamp, or a ``str`` that converts to either.
        :param tzinfo: (optional) a ``tzinfo`` object.  Defaults to local time.
        """

        if tzinfo is None:
            tzinfo = dateutil_tz.tzlocal()
        elif util.isstr(tzinfo):
            tzinfo = parser.TzinfoParser.parse(tzinfo)

        if not util.is_timestamp(timestamp):
            raise ValueError(
                "The provided timestamp '{}' is invalid.".format(timestamp)
            )

        dt = datetime.fromtimestamp(float(timestamp), tzinfo)

        return cls(
            dt.year,
            dt.month,
            dt.day,
            dt.hour,
            dt.minute,
            dt.second,
            dt.microsecond,
            dt.tzinfo,
        )

    @classmethod
    def utcfromtimestamp(cls, timestamp):
        """Constructs an :class:`Arrow <arrow.arrow.Arrow>` object from a timestamp, in UTC time.

        :param timestamp: an ``int`` or ``float`` timestamp, or a ``str`` that converts to either.

        """

        if not util.is_timestamp(timestamp):
            raise ValueError(
                "The provided timestamp '{}' is invalid.".format(timestamp)
            )

        dt = datetime.utcfromtimestamp(float(timestamp))

        return cls(
            dt.year,
            dt.month,
            dt.day,
            dt.hour,
            dt.minute,
            dt.second,
            dt.microsecond,
            dateutil_tz.tzutc(),
        )

    @classmethod
    def fromdatetime(cls, dt, tzinfo=None):
        """ Constructs an :class:`Arrow <arrow.arrow.Arrow>` object from a ``datetime`` and
        optional replacement timezone.

        :param dt: the ``datetime``
        :param tzinfo: (optional) A :ref:`timezone expression <tz-expr>`.  Defaults to ``dt``'s
            timezone, or UTC if naive.

        If you only want to replace the timezone of naive datetimes::

            >>> dt
            datetime.datetime(2013, 5, 5, 0, 0, tzinfo=tzutc())
            >>> arrow.Arrow.fromdatetime(dt, dt.tzinfo or 'US/Pacific')
            <Arrow [2013-05-05T00:00:00+00:00]>

        """

        if tzinfo is None:
            if dt.tzinfo is None:
                tzinfo = dateutil_tz.tzutc()
            else:
                tzinfo = dt.tzinfo

        return cls(
            dt.year,
            dt.month,
            dt.day,
            dt.hour,
            dt.minute,
            dt.second,
            dt.microsecond,
            tzinfo,
        )

    @classmethod
    def fromdate(cls, date, tzinfo=None):
        """ Constructs an :class:`Arrow <arrow.arrow.Arrow>` object from a ``date`` and optional
        replacement timezone.  Time values are set to 0.

        :param date: the ``date``
        :param tzinfo: (optional) A :ref:`timezone expression <tz-expr>`.  Defaults to UTC.
        """

        if tzinfo is None:
            tzinfo = dateutil_tz.tzutc()

        return cls(date.year, date.month, date.day, tzinfo=tzinfo)

    @classmethod
    def strptime(cls, date_str, fmt, tzinfo=None):
        """ Constructs an :class:`Arrow <arrow.arrow.Arrow>` object from a date string and format,
        in the style of ``datetime.strptime``.  Optionally replaces the parsed timezone.

        :param date_str: the date string.
        :param fmt: the format string.
        :param tzinfo: (optional) A :ref:`timezone expression <tz-expr>`.  Defaults to the parsed
            timezone if ``fmt`` contains a timezone directive, otherwise UTC.

        Usage::

            >>> arrow.Arrow.strptime('20-01-2019 15:49:10', '%d-%m-%Y %H:%M:%S')
            <Arrow [2019-01-20T15:49:10+00:00]>

        """

        dt = datetime.strptime(date_str, fmt)
        if tzinfo is None:
            tzinfo = dt.tzinfo

        return cls(
            dt.year,
            dt.month,
            dt.day,
            dt.hour,
            dt.minute,
            dt.second,
            dt.microsecond,
            tzinfo,
        )

    # factories: ranges and spans

    @classmethod
    def range(cls, frame, start, end=None, tz=None, limit=None):
        """ Returns an iterator of :class:`Arrow <arrow.arrow.Arrow>` objects, representing
        points in time between two inputs.

        :param frame: The timeframe.  Can be any ``datetime`` property (day, hour, minute...).
        :param start: A datetime expression, the start of the range.
        :param end: (optional) A datetime expression, the end of the range.
        :param tz: (optional) A :ref:`timezone expression <tz-expr>`.  Defaults to
            ``start``'s timezone, or UTC if ``start`` is naive.
        :param limit: (optional) A maximum number of tuples to return.

        **NOTE**: The ``end`` or ``limit`` must be provided.  Call with ``end`` alone to
        return the entire range.  Call with ``limit`` alone to return a maximum # of results from
        the start.  Call with both to cap a range at a maximum # of results.

        **NOTE**: ``tz`` internally **replaces** the timezones of both ``start`` and ``end`` before
        iterating.  As such, either call with naive objects and ``tz``, or aware objects from the
        same timezone and no ``tz``.

        Supported frame values: year, quarter, month, week, day, hour, minute, second.

        Recognized datetime expressions:

            - An :class:`Arrow <arrow.arrow.Arrow>` object.
            - A ``datetime`` object.

        Usage::

            >>> start = datetime(2013, 5, 5, 12, 30)
            >>> end = datetime(2013, 5, 5, 17, 15)
            >>> for r in arrow.Arrow.range('hour', start, end):
            ...     print(repr(r))
            ...
            <Arrow [2013-05-05T12:30:00+00:00]>
            <Arrow [2013-05-05T13:30:00+00:00]>
            <Arrow [2013-05-05T14:30:00+00:00]>
            <Arrow [2013-05-05T15:30:00+00:00]>
            <Arrow [2013-05-05T16:30:00+00:00]>

        **NOTE**: Unlike Python's ``range``, ``end`` *may* be included in the returned iterator::

            >>> start = datetime(2013, 5, 5, 12, 30)
            >>> end = datetime(2013, 5, 5, 13, 30)
            >>> for r in arrow.Arrow.range('hour', start, end):
            ...     print(repr(r))
            ...
            <Arrow [2013-05-05T12:30:00+00:00]>
            <Arrow [2013-05-05T13:30:00+00:00]>

        """

        _, frame_relative, relative_steps = cls._get_frames(frame)

        tzinfo = cls._get_tzinfo(start.tzinfo if tz is None else tz)

        start = cls._get_datetime(start).replace(tzinfo=tzinfo)
        end, limit = cls._get_iteration_params(end, limit)
        end = cls._get_datetime(end).replace(tzinfo=tzinfo)

        current = cls.fromdatetime(start)
        i = 0

        while current <= end and i < limit:
            i += 1
            yield current

            values = [getattr(current, f) for f in cls._ATTRS]
            current = cls(*values, tzinfo=tzinfo) + relativedelta(
                **{frame_relative: relative_steps}
            )

    @classmethod
    def span_range(cls, frame, start, end, tz=None, limit=None, bounds="[)"):
        """ Returns an iterator of tuples, each :class:`Arrow <arrow.arrow.Arrow>` objects,
        representing a series of timespans between two inputs.

        :param frame: The timeframe.  Can be any ``datetime`` property (day, hour, minute...).
        :param start: A datetime expression, the start of the range.
        :param end: (optional) A datetime expression, the end of the range.
        :param tz: (optional) A :ref:`timezone expression <tz-expr>`.  Defaults to
            ``start``'s timezone, or UTC if ``start`` is naive.
        :param limit: (optional) A maximum number of tuples to return.
        :param bounds: (optional) a ``str`` of either '()', '(]', '[)', or '[]' that specifies
            whether to include or exclude the start and end values in each span in the range. '(' excludes
            the start, '[' includes the start, ')' excludes the end, and ']' includes the end.
            If the bounds are not specified, the default bound '[)' is used.

        **NOTE**: The ``end`` or ``limit`` must be provided.  Call with ``end`` alone to
        return the entire range.  Call with ``limit`` alone to return a maximum # of results from
        the start.  Call with both to cap a range at a maximum # of results.

        **NOTE**: ``tz`` internally **replaces** the timezones of both ``start`` and ``end`` before
        iterating.  As such, either call with naive objects and ``tz``, or aware objects from the
        same timezone and no ``tz``.

        Supported frame values: year, quarter, month, week, day, hour, minute, second.

        Recognized datetime expressions:

            - An :class:`Arrow <arrow.arrow.Arrow>` object.
            - A ``datetime`` object.

        **NOTE**: Unlike Python's ``range``, ``end`` will *always* be included in the returned
        iterator of timespans.

        Usage:

            >>> start = datetime(2013, 5, 5, 12, 30)
            >>> end = datetime(2013, 5, 5, 17, 15)
            >>> for r in arrow.Arrow.span_range('hour', start, end):
            ...     print(r)
            ...
            (<Arrow [2013-05-05T12:00:00+00:00]>, <Arrow [2013-05-05T12:59:59.999999+00:00]>)
            (<Arrow [2013-05-05T13:00:00+00:00]>, <Arrow [2013-05-05T13:59:59.999999+00:00]>)
            (<Arrow [2013-05-05T14:00:00+00:00]>, <Arrow [2013-05-05T14:59:59.999999+00:00]>)
            (<Arrow [2013-05-05T15:00:00+00:00]>, <Arrow [2013-05-05T15:59:59.999999+00:00]>)
            (<Arrow [2013-05-05T16:00:00+00:00]>, <Arrow [2013-05-05T16:59:59.999999+00:00]>)
            (<Arrow [2013-05-05T17:00:00+00:00]>, <Arrow [2013-05-05T17:59:59.999999+00:00]>)

        """

        tzinfo = cls._get_tzinfo(start.tzinfo if tz is None else tz)
        start = cls.fromdatetime(start, tzinfo).span(frame)[0]
        _range = cls.range(frame, start, end, tz, limit)
        return (r.span(frame, bounds=bounds) for r in _range)

    @classmethod
    def interval(cls, frame, start, end, interval=1, tz=None, bounds="[)"):
        """ Returns an iterator of tuples, each :class:`Arrow <arrow.arrow.Arrow>` objects,
        representing a series of intervals between two inputs.

        :param frame: The timeframe.  Can be any ``datetime`` property (day, hour, minute...).
        :param start: A datetime expression, the start of the range.
        :param end: (optional) A datetime expression, the end of the range.
        :param interval: (optional) Time interval for the given time frame.
        :param tz: (optional) A timezone expression.  Defaults to UTC.
        :param bounds: (optional) a ``str`` of either '()', '(]', '[)', or '[]' that specifies
            whether to include or exclude the start and end values in the intervals. '(' excludes
            the start, '[' includes the start, ')' excludes the end, and ']' includes the end.
            If the bounds are not specified, the default bound '[)' is used.

        Supported frame values: year, quarter, month, week, day, hour, minute, second

        Recognized datetime expressions:

            - An :class:`Arrow <arrow.arrow.Arrow>` object.
            - A ``datetime`` object.

        Recognized timezone expressions:

            - A ``tzinfo`` object.
            - A ``str`` describing a timezone, similar to 'US/Pacific', or 'Europe/Berlin'.
            - A ``str`` in ISO 8601 style, as in '+07:00'.
            - A ``str``, one of the following:  'local', 'utc', 'UTC'.

        Usage:

            >>> start = datetime(2013, 5, 5, 12, 30)
            >>> end = datetime(2013, 5, 5, 17, 15)
            >>> for r in arrow.Arrow.interval('hour', start, end, 2):
            ...     print r
            ...
            (<Arrow [2013-05-05T12:00:00+00:00]>, <Arrow [2013-05-05T13:59:59.999999+00:00]>)
            (<Arrow [2013-05-05T14:00:00+00:00]>, <Arrow [2013-05-05T15:59:59.999999+00:00]>)
            (<Arrow [2013-05-05T16:00:00+00:00]>, <Arrow [2013-05-05T17:59:59.999999+00:0]>)
        """
        if interval < 1:
            raise ValueError("interval has to be a positive integer")

        spanRange = iter(cls.span_range(frame, start, end, tz, bounds=bounds))
        while True:
            try:
                intvlStart, intvlEnd = next(spanRange)
                for _ in range(interval - 1):
                    _, intvlEnd = next(spanRange)
                yield intvlStart, intvlEnd
            except StopIteration:
                return

    # representations

    def __repr__(self):
        return "<{} [{}]>".format(self.__class__.__name__, self.__str__())

    def __str__(self):
        return self._datetime.isoformat()

    def __format__(self, formatstr):

        if len(formatstr) > 0:
            return self.format(formatstr)

        return str(self)

    def __hash__(self):
        return self._datetime.__hash__()

    # attributes & properties

    def __getattr__(self, name):

        if name == "week":
            return self.isocalendar()[1]

        if name == "quarter":
            return int((self.month - 1) / self._MONTHS_PER_QUARTER) + 1

        if not name.startswith("_"):
            value = getattr(self._datetime, name, None)

            if value is not None:
                return value

        return object.__getattribute__(self, name)

    @property
    def tzinfo(self):
        """ Gets the ``tzinfo`` of the :class:`Arrow <arrow.arrow.Arrow>` object.

        Usage::

            >>> arw=arrow.utcnow()
            >>> arw.tzinfo
            tzutc()

        """

        return self._datetime.tzinfo

    @tzinfo.setter
    def tzinfo(self, tzinfo):
        """ Sets the ``tzinfo`` of the :class:`Arrow <arrow.arrow.Arrow>` object. """

        self._datetime = self._datetime.replace(tzinfo=tzinfo)

    @property
    def datetime(self):
        """ Returns a datetime representation of the :class:`Arrow <arrow.arrow.Arrow>` object.

        Usage::

            >>> arw=arrow.utcnow()
            >>> arw.datetime
            datetime.datetime(2019, 1, 24, 16, 35, 27, 276649, tzinfo=tzutc())

        """

        return self._datetime

    @property
    def naive(self):
        """ Returns a naive datetime representation of the :class:`Arrow <arrow.arrow.Arrow>`
        object.

        Usage::

            >>> nairobi = arrow.now('Africa/Nairobi')
            >>> nairobi
            <Arrow [2019-01-23T19:27:12.297999+03:00]>
            >>> nairobi.naive
            datetime.datetime(2019, 1, 23, 19, 27, 12, 297999)

        """

        return self._datetime.replace(tzinfo=None)

    @property
    def timestamp(self):
        """ Returns a timestamp representation of the :class:`Arrow <arrow.arrow.Arrow>` object, in
        UTC time.

        Usage::

            >>> arrow.utcnow().timestamp
            1548260567

        """

        return calendar.timegm(self._datetime.utctimetuple())

    @property
    def float_timestamp(self):
        """ Returns a floating-point representation of the :class:`Arrow <arrow.arrow.Arrow>`
        object, in UTC time.

        Usage::

            >>> arrow.utcnow().float_timestamp
            1548260516.830896

        """

        return self.timestamp + float(self.microsecond) / 1000000

    # mutation and duplication.

    def clone(self):
        """ Returns a new :class:`Arrow <arrow.arrow.Arrow>` object, cloned from the current one.

        Usage:

            >>> arw = arrow.utcnow()
            >>> cloned = arw.clone()

        """

        return self.fromdatetime(self._datetime)

    def replace(self, **kwargs):
        """ Returns a new :class:`Arrow <arrow.arrow.Arrow>` object with attributes updated
        according to inputs.

        Use property names to set their value absolutely::

            >>> import arrow
            >>> arw = arrow.utcnow()
            >>> arw
            <Arrow [2013-05-11T22:27:34.787885+00:00]>
            >>> arw.replace(year=2014, month=6)
            <Arrow [2014-06-11T22:27:34.787885+00:00]>

        You can also replace the timezone without conversion, using a
        :ref:`timezone expression <tz-expr>`::

            >>> arw.replace(tzinfo=tz.tzlocal())
            <Arrow [2013-05-11T22:27:34.787885-07:00]>

        """

        absolute_kwargs = {}

        for key, value in kwargs.items():

            if key in self._ATTRS:
                absolute_kwargs[key] = value
            elif key in ["week", "quarter"]:
                raise AttributeError("setting absolute {} is not supported".format(key))
            elif key != "tzinfo":
                raise AttributeError('unknown attribute: "{}"'.format(key))

        current = self._datetime.replace(**absolute_kwargs)

        tzinfo = kwargs.get("tzinfo")

        if tzinfo is not None:
            tzinfo = self._get_tzinfo(tzinfo)
            current = current.replace(tzinfo=tzinfo)

        return self.fromdatetime(current)

    def shift(self, **kwargs):
        """ Returns a new :class:`Arrow <arrow.arrow.Arrow>` object with attributes updated
        according to inputs.

        Use pluralized property names to relatively shift their current value:

        >>> import arrow
        >>> arw = arrow.utcnow()
        >>> arw
        <Arrow [2013-05-11T22:27:34.787885+00:00]>
        >>> arw.shift(years=1, months=-1)
        <Arrow [2014-04-11T22:27:34.787885+00:00]>

        Day-of-the-week relative shifting can use either Python's weekday numbers
        (Monday = 0, Tuesday = 1 .. Sunday = 6) or using dateutil.relativedelta's
        day instances (MO, TU .. SU).  When using weekday numbers, the returned
        date will always be greater than or equal to the starting date.

        Using the above code (which is a Saturday) and asking it to shift to Saturday:

        >>> arw.shift(weekday=5)
        <Arrow [2013-05-11T22:27:34.787885+00:00]>

        While asking for a Monday:

        >>> arw.shift(weekday=0)
        <Arrow [2013-05-13T22:27:34.787885+00:00]>

        """

        relative_kwargs = {}
        additional_attrs = ["weeks", "quarters", "weekday"]

        for key, value in kwargs.items():

            if key in self._ATTRS_PLURAL or key in additional_attrs:
                relative_kwargs[key] = value
            else:
                raise AttributeError(
                    "Invalid shift time frame. Please select one of the following: {}.".format(
                        ", ".join(self._ATTRS_PLURAL + additional_attrs)
                    )
                )

        # core datetime does not support quarters, translate to months.
        relative_kwargs.setdefault("months", 0)
        relative_kwargs["months"] += (
            relative_kwargs.pop("quarters", 0) * self._MONTHS_PER_QUARTER
        )

        current = self._datetime + relativedelta(**relative_kwargs)

        return self.fromdatetime(current)

    def to(self, tz):
        """ Returns a new :class:`Arrow <arrow.arrow.Arrow>` object, converted
        to the target timezone.

        :param tz: A :ref:`timezone expression <tz-expr>`.

        Usage::

            >>> utc = arrow.utcnow()
            >>> utc
            <Arrow [2013-05-09T03:49:12.311072+00:00]>

            >>> utc.to('US/Pacific')
            <Arrow [2013-05-08T20:49:12.311072-07:00]>

            >>> utc.to(tz.tzlocal())
            <Arrow [2013-05-08T20:49:12.311072-07:00]>

            >>> utc.to('-07:00')
            <Arrow [2013-05-08T20:49:12.311072-07:00]>

            >>> utc.to('local')
            <Arrow [2013-05-08T20:49:12.311072-07:00]>

            >>> utc.to('local').to('utc')
            <Arrow [2013-05-09T03:49:12.311072+00:00]>

        """

        if not isinstance(tz, dt_tzinfo):
            tz = parser.TzinfoParser.parse(tz)

        dt = self._datetime.astimezone(tz)

        return self.__class__(
            dt.year,
            dt.month,
            dt.day,
            dt.hour,
            dt.minute,
            dt.second,
            dt.microsecond,
            dt.tzinfo,
        )

    @classmethod
    def _validate_bounds(cls, bounds):
        if bounds != "()" and bounds != "(]" and bounds != "[)" and bounds != "[]":
            raise AttributeError(
                'Invalid bounds. Please select between "()", "(]", "[)", or "[]".'
            )

    def span(self, frame, count=1, bounds="[)"):
        """ Returns two new :class:`Arrow <arrow.arrow.Arrow>` objects, representing the timespan
        of the :class:`Arrow <arrow.arrow.Arrow>` object in a given timeframe.

        :param frame: the timeframe.  Can be any ``datetime`` property (day, hour, minute...).
        :param count: (optional) the number of frames to span.
        :param bounds: (optional) a ``str`` of either '()', '(]', '[)', or '[]' that specifies
            whether to include or exclude the start and end values in the span. '(' excludes
            the start, '[' includes the start, ')' excludes the end, and ']' includes the end.
            If the bounds are not specified, the default bound '[)' is used.

        Supported frame values: year, quarter, month, week, day, hour, minute, second.

        Usage::

            >>> arrow.utcnow()
            <Arrow [2013-05-09T03:32:36.186203+00:00]>

            >>> arrow.utcnow().span('hour')
            (<Arrow [2013-05-09T03:00:00+00:00]>, <Arrow [2013-05-09T03:59:59.999999+00:00]>)

            >>> arrow.utcnow().span('day')
            (<Arrow [2013-05-09T00:00:00+00:00]>, <Arrow [2013-05-09T23:59:59.999999+00:00]>)

            >>> arrow.utcnow().span('day', count=2)
            (<Arrow [2013-05-09T00:00:00+00:00]>, <Arrow [2013-05-10T23:59:59.999999+00:00]>)

            >>> arrow.utcnow().span('day', bounds='[]')
            (<Arrow [2013-05-09T00:00:00+00:00]>, <Arrow [2013-05-10T00:00:00+00:00]>)

        """

        self._validate_bounds(bounds)

        frame_absolute, frame_relative, relative_steps = self._get_frames(frame)

        if frame_absolute == "week":
            attr = "day"
        elif frame_absolute == "quarter":
            attr = "month"
        else:
            attr = frame_absolute

        index = self._ATTRS.index(attr)
        frames = self._ATTRS[: index + 1]

        values = [getattr(self, f) for f in frames]

        for _ in range(3 - len(values)):
            values.append(1)

        floor = self.__class__(*values, tzinfo=self.tzinfo)

        if frame_absolute == "week":
            floor = floor + relativedelta(days=-(self.isoweekday() - 1))
        elif frame_absolute == "quarter":
            floor = floor + relativedelta(months=-((self.month - 1) % 3))

        ceil = floor + relativedelta(**{frame_relative: count * relative_steps})

        if bounds[0] == "(":
            floor += relativedelta(microseconds=1)

        if bounds[1] == ")":
            ceil += relativedelta(microseconds=-1)

        return floor, ceil

    def floor(self, frame):
        """ Returns a new :class:`Arrow <arrow.arrow.Arrow>` object, representing the "floor"
        of the timespan of the :class:`Arrow <arrow.arrow.Arrow>` object in a given timeframe.
        Equivalent to the first element in the 2-tuple returned by
        :func:`span <arrow.arrow.Arrow.span>`.

        :param frame: the timeframe.  Can be any ``datetime`` property (day, hour, minute...).

        Usage::

            >>> arrow.utcnow().floor('hour')
            <Arrow [2013-05-09T03:00:00+00:00]>
        """

        return self.span(frame)[0]

    def ceil(self, frame):
        """ Returns a new :class:`Arrow <arrow.arrow.Arrow>` object, representing the "ceiling"
        of the timespan of the :class:`Arrow <arrow.arrow.Arrow>` object in a given timeframe.
        Equivalent to the second element in the 2-tuple returned by
        :func:`span <arrow.arrow.Arrow.span>`.

        :param frame: the timeframe.  Can be any ``datetime`` property (day, hour, minute...).

        Usage::

            >>> arrow.utcnow().ceil('hour')
            <Arrow [2013-05-09T03:59:59.999999+00:00]>
        """

        return self.span(frame)[1]

    # string output and formatting.

    def format(self, fmt="YYYY-MM-DD HH:mm:ssZZ", locale="en_us"):
        """ Returns a string representation of the :class:`Arrow <arrow.arrow.Arrow>` object,
        formatted according to a format string.

        :param fmt: the format string.

        Usage::

            >>> arrow.utcnow().format('YYYY-MM-DD HH:mm:ss ZZ')
            '2013-05-09 03:56:47 -00:00'

            >>> arrow.utcnow().format('X')
            '1368071882'

            >>> arrow.utcnow().format('MMMM DD, YYYY')
            'May 09, 2013'

            >>> arrow.utcnow().format()
            '2013-05-09 03:56:47 -00:00'

        """

        return formatter.DateTimeFormatter(locale).format(self._datetime, fmt)

    def humanize(
        self, other=None, locale="en_us", only_distance=False, granularity="auto"
    ):
        """ Returns a localized, humanized representation of a relative difference in time.

        :param other: (optional) an :class:`Arrow <arrow.arrow.Arrow>` or ``datetime`` object.
            Defaults to now in the current :class:`Arrow <arrow.arrow.Arrow>` object's timezone.
        :param locale: (optional) a ``str`` specifying a locale.  Defaults to 'en_us'.
        :param only_distance: (optional) returns only time difference eg: "11 seconds" without "in" or "ago" part.
        :param granularity: (optional) defines the precision of the output. Set it to strings 'second', 'minute',
                           'hour', 'day', 'week', 'month' or 'year' or a list of any combination of these strings

        Usage::

            >>> earlier = arrow.utcnow().shift(hours=-2)
            >>> earlier.humanize()
            '2 hours ago'

            >>> later = earlier.shift(hours=4)
            >>> later.humanize(earlier)
            'in 4 hours'

        """

        locale_name = locale
        locale = locales.get_locale(locale)

        if other is None:
            utc = datetime.utcnow().replace(tzinfo=dateutil_tz.tzutc())
            dt = utc.astimezone(self._datetime.tzinfo)

        elif isinstance(other, Arrow):
            dt = other._datetime

        elif isinstance(other, datetime):
            if other.tzinfo is None:
                dt = other.replace(tzinfo=self._datetime.tzinfo)
            else:
                dt = other.astimezone(self._datetime.tzinfo)

        else:
            raise TypeError(
                "Invalid 'other' argument of type '{}'. "
                "Argument must be of type None, Arrow, or datetime.".format(
                    type(other).__name__
                )
            )

        if isinstance(granularity, list) and len(granularity) == 1:
            granularity = granularity[0]

        delta = int(round(util.total_seconds(self._datetime - dt)))
        sign = -1 if delta < 0 else 1
        diff = abs(delta)
        delta = diff

        try:
            if granularity == "auto":
                if diff < 10:
                    return locale.describe("now", only_distance=only_distance)

                if diff < 45:
                    seconds = sign * delta
                    return locale.describe(
                        "seconds", seconds, only_distance=only_distance
                    )

                elif diff < 90:
                    return locale.describe("minute", sign, only_distance=only_distance)
                elif diff < 2700:
                    minutes = sign * int(max(delta / 60, 2))
                    return locale.describe(
                        "minutes", minutes, only_distance=only_distance
                    )

                elif diff < 5400:
                    return locale.describe("hour", sign, only_distance=only_distance)
                elif diff < 79200:
                    hours = sign * int(max(delta / 3600, 2))
                    return locale.describe("hours", hours, only_distance=only_distance)

                # anything less than 48 hours should be 1 day
                elif diff < 172800:
                    return locale.describe("day", sign, only_distance=only_distance)
                elif diff < 554400:
                    days = sign * int(max(delta / 86400, 2))
                    return locale.describe("days", days, only_distance=only_distance)

                elif diff < 907200:
                    return locale.describe("week", sign, only_distance=only_distance)
                elif diff < 2419200:
                    weeks = sign * int(max(delta / 604800, 2))
                    return locale.describe("weeks", weeks, only_distance=only_distance)

                elif diff < 3888000:
                    return locale.describe("month", sign, only_distance=only_distance)
                elif diff < 29808000:
                    self_months = self._datetime.year * 12 + self._datetime.month
                    other_months = dt.year * 12 + dt.month

                    months = sign * int(max(abs(other_months - self_months), 2))

                    return locale.describe(
                        "months", months, only_distance=only_distance
                    )

                elif diff < 47260800:
                    return locale.describe("year", sign, only_distance=only_distance)
                else:
                    years = sign * int(max(delta / 31536000, 2))
                    return locale.describe("years", years, only_distance=only_distance)

            elif util.isstr(granularity):
                if granularity == "second":
                    delta = sign * delta
                    if abs(delta) < 2:
                        return locale.describe("now", only_distance=only_distance)
                elif granularity == "minute":
                    delta = sign * delta / self._SECS_PER_MINUTE
                elif granularity == "hour":
                    delta = sign * delta / self._SECS_PER_HOUR
                elif granularity == "day":
                    delta = sign * delta / self._SECS_PER_DAY
                elif granularity == "week":
                    delta = sign * delta / self._SECS_PER_WEEK
                elif granularity == "month":
                    delta = sign * delta / self._SECS_PER_MONTH
                elif granularity == "year":
                    delta = sign * delta / self._SECS_PER_YEAR
                else:
                    raise AttributeError(
                        "Invalid level of granularity. Please select between 'second', 'minute', 'hour', 'day', 'week', 'month' or 'year'"
                    )

                if trunc(abs(delta)) != 1:
                    granularity += "s"
                return locale.describe(granularity, delta, only_distance=only_distance)

            else:
                timeframes = []
                if "year" in granularity:
                    years = sign * delta / self._SECS_PER_YEAR
                    delta %= self._SECS_PER_YEAR
                    timeframes.append(["year", years])

                if "month" in granularity:
                    months = sign * delta / self._SECS_PER_MONTH
                    delta %= self._SECS_PER_MONTH
                    timeframes.append(["month", months])

                if "week" in granularity:
                    weeks = sign * delta / self._SECS_PER_WEEK
                    delta %= self._SECS_PER_WEEK
                    timeframes.append(["week", weeks])

                if "day" in granularity:
                    days = sign * delta / self._SECS_PER_DAY
                    delta %= self._SECS_PER_DAY
                    timeframes.append(["day", days])

                if "hour" in granularity:
                    hours = sign * delta / self._SECS_PER_HOUR
                    delta %= self._SECS_PER_HOUR
                    timeframes.append(["hour", hours])

                if "minute" in granularity:
                    minutes = sign * delta / self._SECS_PER_MINUTE
                    delta %= self._SECS_PER_MINUTE
                    timeframes.append(["minute", minutes])

                if "second" in granularity:
                    seconds = sign * delta
                    timeframes.append(["second", seconds])

                if len(timeframes) < len(granularity):
                    raise AttributeError(
                        "Invalid level of granularity. "
                        "Please select between 'second', 'minute', 'hour', 'day', 'week', 'month' or 'year'."
                    )

                for tf in timeframes:
                    # Make granularity plural if the delta is not equal to 1
                    if trunc(abs(tf[1])) != 1:
                        tf[0] += "s"
                return locale.describe_multi(timeframes, only_distance=only_distance)

        except KeyError as e:
            raise ValueError(
                "Humanization of the {} granularity is not currently translated in the '{}' locale. "
                "Please consider making a contribution to this locale.".format(
                    e, locale_name
                )
            )

    # query functions

    def is_between(self, start, end, bounds="()"):
        """ Returns a boolean denoting whether the specified date and time is between
        the start and end dates and times.

        :param start: an :class:`Arrow <arrow.arrow.Arrow>` object.
        :param end: an :class:`Arrow <arrow.arrow.Arrow>` object.
        :param bounds: (optional) a ``str`` of either '()', '(]', '[)', or '[]' that specifies
            whether to include or exclude the start and end values in the range. '(' excludes
            the start, '[' includes the start, ')' excludes the end, and ']' includes the end.
            If the bounds are not specified, the default bound '()' is used.

        Usage::

            >>> start = arrow.get(datetime(2013, 5, 5, 12, 30, 10))
            >>> end = arrow.get(datetime(2013, 5, 5, 12, 30, 36))
            >>> arrow.get(datetime(2013, 5, 5, 12, 30, 27)).is_between(start, end)
            True

            >>> start = arrow.get(datetime(2013, 5, 5))
            >>> end = arrow.get(datetime(2013, 5, 8))
            >>> arrow.get(datetime(2013, 5, 8)).is_between(start, end, '[]')
            True

            >>> start = arrow.get(datetime(2013, 5, 5))
            >>> end = arrow.get(datetime(2013, 5, 8))
            >>> arrow.get(datetime(2013, 5, 8)).is_between(start, end, '[)')
            False

        """

        self._validate_bounds(bounds)

        if not isinstance(start, Arrow):
            raise TypeError(
                "Can't parse start date argument type of '{}'".format(type(start))
            )

        if not isinstance(end, Arrow):
            raise TypeError(
                "Can't parse end date argument type of '{}'".format(type(end))
            )

        include_start = bounds[0] == "["
        include_end = bounds[1] == "]"

        target_timestamp = self.float_timestamp
        start_timestamp = start.float_timestamp
        end_timestamp = end.float_timestamp

        if include_start and include_end:
            return (
                target_timestamp >= start_timestamp
                and target_timestamp <= end_timestamp
            )
        elif include_start and not include_end:
            return (
                target_timestamp >= start_timestamp and target_timestamp < end_timestamp
            )
        elif not include_start and include_end:
            return (
                target_timestamp > start_timestamp and target_timestamp <= end_timestamp
            )
        else:
            return (
                target_timestamp > start_timestamp and target_timestamp < end_timestamp
            )

    # math

    def __add__(self, other):

        if isinstance(other, (timedelta, relativedelta)):
            return self.fromdatetime(self._datetime + other, self._datetime.tzinfo)

        return NotImplemented

    def __radd__(self, other):
        return self.__add__(other)

    def __sub__(self, other):

        if isinstance(other, (timedelta, relativedelta)):
            return self.fromdatetime(self._datetime - other, self._datetime.tzinfo)

        elif isinstance(other, datetime):
            return self._datetime - other

        elif isinstance(other, Arrow):
            return self._datetime - other._datetime

        return NotImplemented

    def __rsub__(self, other):

        if isinstance(other, datetime):
            return other - self._datetime

        return NotImplemented

    # comparisons

    def __eq__(self, other):

        if not isinstance(other, (Arrow, datetime)):
            return False

        return self._datetime == self._get_datetime(other)

    def __ne__(self, other):

        if not isinstance(other, (Arrow, datetime)):
            return True

        return not self.__eq__(other)

    def __gt__(self, other):

        if not isinstance(other, (Arrow, datetime)):
            return NotImplemented

        return self._datetime > self._get_datetime(other)

    def __ge__(self, other):

        if not isinstance(other, (Arrow, datetime)):
            return NotImplemented

        return self._datetime >= self._get_datetime(other)

    def __lt__(self, other):

        if not isinstance(other, (Arrow, datetime)):
            return NotImplemented

        return self._datetime < self._get_datetime(other)

    def __le__(self, other):

        if not isinstance(other, (Arrow, datetime)):
            return NotImplemented

        return self._datetime <= self._get_datetime(other)

    def __cmp__(self, other):
        if sys.version_info[0] < 3:  # pragma: no cover
            if not isinstance(other, (Arrow, datetime)):
                raise TypeError(
                    "can't compare '{}' to '{}'".format(type(self), type(other))
                )

    # datetime methods

    def date(self):
        """ Returns a ``date`` object with the same year, month and day.

        Usage::

            >>> arrow.utcnow().date()
            datetime.date(2019, 1, 23)

        """

        return self._datetime.date()

    def time(self):
        """ Returns a ``time`` object with the same hour, minute, second, microsecond.

        Usage::

            >>> arrow.utcnow().time()
            datetime.time(12, 15, 34, 68352)

        """

        return self._datetime.time()

    def timetz(self):
        """ Returns a ``time`` object with the same hour, minute, second, microsecond and
        tzinfo.

        Usage::

            >>> arrow.utcnow().timetz()
            datetime.time(12, 5, 18, 298893, tzinfo=tzutc())

        """

        return self._datetime.timetz()

    def astimezone(self, tz):
        """ Returns a ``datetime`` object, converted to the specified timezone.

        :param tz: a ``tzinfo`` object.

        Usage::

            >>> pacific=arrow.now('US/Pacific')
            >>> nyc=arrow.now('America/New_York').tzinfo
            >>> pacific.astimezone(nyc)
            datetime.datetime(2019, 1, 20, 10, 24, 22, 328172, tzinfo=tzfile('/usr/share/zoneinfo/America/New_York'))

        """

        return self._datetime.astimezone(tz)

    def utcoffset(self):
        """ Returns a ``timedelta`` object representing the whole number of minutes difference from
        UTC time.

        Usage::

            >>> arrow.now('US/Pacific').utcoffset()
            datetime.timedelta(-1, 57600)

        """

        return self._datetime.utcoffset()

    def dst(self):
        """ Returns the daylight savings time adjustment.

        Usage::

            >>> arrow.utcnow().dst()
            datetime.timedelta(0)

        """

        return self._datetime.dst()

    def timetuple(self):
        """ Returns a ``time.struct_time``, in the current timezone.

        Usage::

            >>> arrow.utcnow().timetuple()
            time.struct_time(tm_year=2019, tm_mon=1, tm_mday=20, tm_hour=15, tm_min=17, tm_sec=8, tm_wday=6, tm_yday=20, tm_isdst=0)

        """

        return self._datetime.timetuple()

    def utctimetuple(self):
        """ Returns a ``time.struct_time``, in UTC time.

        Usage::

            >>> arrow.utcnow().utctimetuple()
            time.struct_time(tm_year=2019, tm_mon=1, tm_mday=19, tm_hour=21, tm_min=41, tm_sec=7, tm_wday=5, tm_yday=19, tm_isdst=0)

        """

        return self._datetime.utctimetuple()

    def toordinal(self):
        """ Returns the proleptic Gregorian ordinal of the date.

        Usage::

            >>> arrow.utcnow().toordinal()
            737078

        """

        return self._datetime.toordinal()

    def weekday(self):
        """ Returns the day of the week as an integer (0-6).

        Usage::

            >>> arrow.utcnow().weekday()
            5

        """

        return self._datetime.weekday()

    def isoweekday(self):
        """ Returns the ISO day of the week as an integer (1-7).

        Usage::

            >>> arrow.utcnow().isoweekday()
            6

        """

        return self._datetime.isoweekday()

    def isocalendar(self):
        """ Returns a 3-tuple, (ISO year, ISO week number, ISO weekday).

        Usage::

            >>> arrow.utcnow().isocalendar()
            (2019, 3, 6)

        """

        return self._datetime.isocalendar()

    def isoformat(self, sep="T"):
        """Returns an ISO 8601 formatted representation of the date and time.

        Usage::

            >>> arrow.utcnow().isoformat()
            '2019-01-19T18:30:52.442118+00:00'

        """

        return self._datetime.isoformat(sep)

    def ctime(self):
        """ Returns a ctime formatted representation of the date and time.

        Usage::

            >>> arrow.utcnow().ctime()
            'Sat Jan 19 18:26:50 2019'

        """

        return self._datetime.ctime()

    def strftime(self, format):
        """ Formats in the style of ``datetime.strftime``.

        :param format: the format string.

        Usage::

            >>> arrow.utcnow().strftime('%d-%m-%Y %H:%M:%S')
            '23-01-2019 12:28:17'

        """

        return self._datetime.strftime(format)

    def for_json(self):
        """Serializes for the ``for_json`` protocol of simplejson.

        Usage::

            >>> arrow.utcnow().for_json()
            '2019-01-19T18:25:36.760079+00:00'

        """

        return self.isoformat()

    # internal tools.

    @staticmethod
    def _get_tzinfo(tz_expr):

        if tz_expr is None:
            return dateutil_tz.tzutc()
        if isinstance(tz_expr, dt_tzinfo):
            return tz_expr
        else:
            try:
                return parser.TzinfoParser.parse(tz_expr)
            except parser.ParserError:
                raise ValueError("'{}' not recognized as a timezone".format(tz_expr))

    @classmethod
    def _get_datetime(cls, expr):
        """Get datetime object for a specified expression."""
        if isinstance(expr, Arrow):
            return expr.datetime
        elif isinstance(expr, datetime):
            return expr
        elif util.is_timestamp(expr):
            timestamp = float(expr)
            return cls.utcfromtimestamp(timestamp).datetime
        else:
            raise ValueError(
                "'{}' not recognized as a datetime or timestamp.".format(expr)
            )

    @classmethod
    def _get_frames(cls, name):

        if name in cls._ATTRS:
            return name, "{}s".format(name), 1
        elif name[-1] == "s" and name[:-1] in cls._ATTRS:
            return name[:-1], name, 1
        elif name in ["week", "weeks"]:
            return "week", "weeks", 1
        elif name in ["quarter", "quarters"]:
            return "quarter", "months", 3

        supported = ", ".join(
            [
                "year(s)",
                "month(s)",
                "day(s)",
                "hour(s)",
                "minute(s)",
                "second(s)",
                "microsecond(s)",
                "week(s)",
                "quarter(s)",
            ]
        )
        raise AttributeError(
            "range/span over frame {} not supported. Supported frames: {}".format(
                name, supported
            )
        )

    @classmethod
    def _get_iteration_params(cls, end, limit):

        if end is None:

            if limit is None:
                raise ValueError("one of 'end' or 'limit' is required")

            return cls.max, limit

        else:
            if limit is None:
                return end, sys.maxsize
            return end, limit


Arrow.min = Arrow.fromdatetime(datetime.min)
Arrow.max = Arrow.fromdatetime(datetime.max)
# -*- coding: utf-8 -*-

# Output of time.mktime(datetime.max.timetuple()) on macOS
# This value must be hardcoded for compatibility with Windows
# Platform-independent max timestamps are hard to form
# https://stackoverflow.com/q/46133223
MAX_TIMESTAMP = 253402318799.0
MAX_TIMESTAMP_MS = MAX_TIMESTAMP * 1000
MAX_TIMESTAMP_US = MAX_TIMESTAMP * 1000000
# -*- coding: utf-8 -*-
"""
Implements the :class:`ArrowFactory <arrow.factory.ArrowFactory>` class,
providing factory methods for common :class:`Arrow <arrow.arrow.Arrow>`
construction scenarios.

"""

from __future__ import absolute_import

import calendar
from datetime import date, datetime
from datetime import tzinfo as dt_tzinfo
from time import struct_time

from dateutil import tz as dateutil_tz

from arrow import parser
from arrow.arrow import Arrow
from arrow.util import is_timestamp, iso_to_gregorian, isstr


class ArrowFactory(object):
    """ A factory for generating :class:`Arrow <arrow.arrow.Arrow>` objects.

    :param type: (optional) the :class:`Arrow <arrow.arrow.Arrow>`-based class to construct from.
        Defaults to :class:`Arrow <arrow.arrow.Arrow>`.

    """

    def __init__(self, type=Arrow):
        self.type = type

    def get(self, *args, **kwargs):
        """ Returns an :class:`Arrow <arrow.arrow.Arrow>` object based on flexible inputs.

        :param locale: (optional) a ``str`` specifying a locale for the parser. Defaults to
            'en_us'.
        :param tzinfo: (optional) a :ref:`timezone expression <tz-expr>` or tzinfo object.
            Replaces the timezone unless using an input form that is explicitly UTC or specifies
            the timezone in a positional argument. Defaults to UTC.

        Usage::

            >>> import arrow

        **No inputs** to get current UTC time::

            >>> arrow.get()
            <Arrow [2013-05-08T05:51:43.316458+00:00]>

        **None** to also get current UTC time::

            >>> arrow.get(None)
            <Arrow [2013-05-08T05:51:49.016458+00:00]>

        **One** :class:`Arrow <arrow.arrow.Arrow>` object, to get a copy.

            >>> arw = arrow.utcnow()
            >>> arrow.get(arw)
            <Arrow [2013-10-23T15:21:54.354846+00:00]>

        **One** ``float`` or ``int``, convertible to a floating-point timestamp, to get
        that timestamp in UTC::

            >>> arrow.get(1367992474.293378)
            <Arrow [2013-05-08T05:54:34.293378+00:00]>

            >>> arrow.get(1367992474)
            <Arrow [2013-05-08T05:54:34+00:00]>

        **One** ISO 8601-formatted ``str``, to parse it::

            >>> arrow.get('2013-09-29T01:26:43.830580')
            <Arrow [2013-09-29T01:26:43.830580+00:00]>

        **One** ISO 8601-formatted ``str``, in basic format, to parse it::

            >>> arrow.get('20160413T133656.456289')
            <Arrow [2016-04-13T13:36:56.456289+00:00]>

        **One** ``tzinfo``, to get the current time **converted** to that timezone::

            >>> arrow.get(tz.tzlocal())
            <Arrow [2013-05-07T22:57:28.484717-07:00]>

        **One** naive ``datetime``, to get that datetime in UTC::

            >>> arrow.get(datetime(2013, 5, 5))
            <Arrow [2013-05-05T00:00:00+00:00]>

        **One** aware ``datetime``, to get that datetime::

            >>> arrow.get(datetime(2013, 5, 5, tzinfo=tz.tzlocal()))
            <Arrow [2013-05-05T00:00:00-07:00]>

        **One** naive ``date``, to get that date in UTC::

            >>> arrow.get(date(2013, 5, 5))
            <Arrow [2013-05-05T00:00:00+00:00]>

        **One** time.struct time::

            >>> arrow.get(gmtime(0))
            <Arrow [1970-01-01T00:00:00+00:00]>

        **One** iso calendar ``tuple``, to get that week date in UTC::

            >>> arrow.get((2013, 18, 7))
            <Arrow [2013-05-05T00:00:00+00:00]>

        **Two** arguments, a naive or aware ``datetime``, and a replacement
        :ref:`timezone expression <tz-expr>`::

            >>> arrow.get(datetime(2013, 5, 5), 'US/Pacific')
            <Arrow [2013-05-05T00:00:00-07:00]>

        **Two** arguments, a naive ``date``, and a replacement
        :ref:`timezone expression <tz-expr>`::

            >>> arrow.get(date(2013, 5, 5), 'US/Pacific')
            <Arrow [2013-05-05T00:00:00-07:00]>

        **Two** arguments, both ``str``, to parse the first according to the format of the second::

            >>> arrow.get('2013-05-05 12:30:45 America/Chicago', 'YYYY-MM-DD HH:mm:ss ZZZ')
            <Arrow [2013-05-05T12:30:45-05:00]>

        **Two** arguments, first a ``str`` to parse and second a ``list`` of formats to try::

            >>> arrow.get('2013-05-05 12:30:45', ['MM/DD/YYYY', 'YYYY-MM-DD HH:mm:ss'])
            <Arrow [2013-05-05T12:30:45+00:00]>

        **Three or more** arguments, as for the constructor of a ``datetime``::

            >>> arrow.get(2013, 5, 5, 12, 30, 45)
            <Arrow [2013-05-05T12:30:45+00:00]>

        """

        arg_count = len(args)
        locale = kwargs.pop("locale", "en_us")
        tz = kwargs.get("tzinfo", None)

        # if kwargs given, send to constructor unless only tzinfo provided
        if len(kwargs) > 1:
            arg_count = 3

        # tzinfo kwarg is not provided
        if len(kwargs) == 1 and tz is None:
            arg_count = 3

        # () -> now, @ utc.
        if arg_count == 0:
            if isstr(tz):
                tz = parser.TzinfoParser.parse(tz)
                return self.type.now(tz)

            if isinstance(tz, dt_tzinfo):
                return self.type.now(tz)

            return self.type.utcnow()

        if arg_count == 1:
            arg = args[0]

            # (None) -> now, @ utc.
            if arg is None:
                return self.type.utcnow()

            # try (int, float) -> from timestamp with tz
            elif not isstr(arg) and is_timestamp(arg):
                if tz is None:
                    # set to UTC by default
                    tz = dateutil_tz.tzutc()
                return self.type.fromtimestamp(arg, tzinfo=tz)

            # (Arrow) -> from the object's datetime.
            elif isinstance(arg, Arrow):
                return self.type.fromdatetime(arg.datetime)

            # (datetime) -> from datetime.
            elif isinstance(arg, datetime):
                return self.type.fromdatetime(arg)

            # (date) -> from date.
            elif isinstance(arg, date):
                return self.type.fromdate(arg)

            # (tzinfo) -> now, @ tzinfo.
            elif isinstance(arg, dt_tzinfo):
                return self.type.now(arg)

            # (str) -> parse.
            elif isstr(arg):
                dt = parser.DateTimeParser(locale).parse_iso(arg)
                return self.type.fromdatetime(dt, tz)

            # (struct_time) -> from struct_time
            elif isinstance(arg, struct_time):
                return self.type.utcfromtimestamp(calendar.timegm(arg))

            # (iso calendar) -> convert then from date
            elif isinstance(arg, tuple) and len(arg) == 3:
                dt = iso_to_gregorian(*arg)
                return self.type.fromdate(dt)

            else:
                raise TypeError(
                    "Can't parse single argument of type '{}'".format(type(arg))
                )

        elif arg_count == 2:

            arg_1, arg_2 = args[0], args[1]

            if isinstance(arg_1, datetime):

                # (datetime, tzinfo/str) -> fromdatetime replace tzinfo.
                if isinstance(arg_2, dt_tzinfo) or isstr(arg_2):
                    return self.type.fromdatetime(arg_1, arg_2)
                else:
                    raise TypeError(
                        "Can't parse two arguments of types 'datetime', '{}'".format(
                            type(arg_2)
                        )
                    )

            elif isinstance(arg_1, date):

                # (date, tzinfo/str) -> fromdate replace tzinfo.
                if isinstance(arg_2, dt_tzinfo) or isstr(arg_2):
                    return self.type.fromdate(arg_1, tzinfo=arg_2)
                else:
                    raise TypeError(
                        "Can't parse two arguments of types 'date', '{}'".format(
                            type(arg_2)
                        )
                    )

            # (str, format) -> parse.
            elif isstr(arg_1) and (isstr(arg_2) or isinstance(arg_2, list)):
                dt = parser.DateTimeParser(locale).parse(args[0], args[1])
                return self.type.fromdatetime(dt, tzinfo=tz)

            else:
                raise TypeError(
                    "Can't parse two arguments of types '{}' and '{}'".format(
                        type(arg_1), type(arg_2)
                    )
                )

        # 3+ args -> datetime-like via constructor.
        else:
            return self.type(*args, **kwargs)

    def utcnow(self):
        """Returns an :class:`Arrow <arrow.arrow.Arrow>` object, representing "now" in UTC time.

        Usage::

            >>> import arrow
            >>> arrow.utcnow()
            <Arrow [2013-05-08T05:19:07.018993+00:00]>
        """

        return self.type.utcnow()

    def now(self, tz=None):
        """Returns an :class:`Arrow <arrow.arrow.Arrow>` object, representing "now" in the given
        timezone.

        :param tz: (optional) A :ref:`timezone expression <tz-expr>`.  Defaults to local time.

        Usage::

            >>> import arrow
            >>> arrow.now()
            <Arrow [2013-05-07T22:19:11.363410-07:00]>

            >>> arrow.now('US/Pacific')
            <Arrow [2013-05-07T22:19:15.251821-07:00]>

            >>> arrow.now('+02:00')
            <Arrow [2013-05-08T07:19:25.618646+02:00]>

            >>> arrow.now('local')
            <Arrow [2013-05-07T22:19:39.130059-07:00]>
        """

        if tz is None:
            tz = dateutil_tz.tzlocal()
        elif not isinstance(tz, dt_tzinfo):
            tz = parser.TzinfoParser.parse(tz)

        return self.type.now(tz)
# -*- coding: utf-8 -*-
from __future__ import absolute_import, division

import calendar
import re

from dateutil import tz as dateutil_tz

from arrow import locales, util


class DateTimeFormatter(object):

    # This pattern matches characters enclosed in square brackets are matched as
    # an atomic group. For more info on atomic groups and how to they are
    # emulated in Python's re library, see https://stackoverflow.com/a/13577411/2701578

    _FORMAT_RE = re.compile(
        r"(\[(?:(?=(?P<literal>[^]]))(?P=literal))*\]|YYY?Y?|MM?M?M?|Do|DD?D?D?|d?dd?d?|HH?|hh?|mm?|ss?|SS?S?S?S?S?|ZZ?Z?|a|A|X|x|W)"
    )

    def __init__(self, locale="en_us"):

        self.locale = locales.get_locale(locale)

    def format(cls, dt, fmt):

        return cls._FORMAT_RE.sub(lambda m: cls._format_token(dt, m.group(0)), fmt)

    def _format_token(self, dt, token):

        if token and token.startswith("[") and token.endswith("]"):
            return token[1:-1]

        if token == "YYYY":
            return self.locale.year_full(dt.year)
        if token == "YY":
            return self.locale.year_abbreviation(dt.year)

        if token == "MMMM":
            return self.locale.month_name(dt.month)
        if token == "MMM":
            return self.locale.month_abbreviation(dt.month)
        if token == "MM":
            return "{:02d}".format(dt.month)
        if token == "M":
            return str(dt.month)

        if token == "DDDD":
            return "{:03d}".format(dt.timetuple().tm_yday)
        if token == "DDD":
            return str(dt.timetuple().tm_yday)
        if token == "DD":
            return "{:02d}".format(dt.day)
        if token == "D":
            return str(dt.day)

        if token == "Do":
            return self.locale.ordinal_number(dt.day)

        if token == "dddd":
            return self.locale.day_name(dt.isoweekday())
        if token == "ddd":
            return self.locale.day_abbreviation(dt.isoweekday())
        if token == "d":
            return str(dt.isoweekday())

        if token == "HH":
            return "{:02d}".format(dt.hour)
        if token == "H":
            return str(dt.hour)
        if token == "hh":
            return "{:02d}".format(dt.hour if 0 < dt.hour < 13 else abs(dt.hour - 12))
        if token == "h":
            return str(dt.hour if 0 < dt.hour < 13 else abs(dt.hour - 12))

        if token == "mm":
            return "{:02d}".format(dt.minute)
        if token == "m":
            return str(dt.minute)

        if token == "ss":
            return "{:02d}".format(dt.second)
        if token == "s":
            return str(dt.second)

        if token == "SSSSSS":
            return str("{:06d}".format(int(dt.microsecond)))
        if token == "SSSSS":
            return str("{:05d}".format(int(dt.microsecond / 10)))
        if token == "SSSS":
            return str("{:04d}".format(int(dt.microsecond / 100)))
        if token == "SSS":
            return str("{:03d}".format(int(dt.microsecond / 1000)))
        if token == "SS":
            return str("{:02d}".format(int(dt.microsecond / 10000)))
        if token == "S":
            return str(int(dt.microsecond / 100000))

        if token == "X":
            # TODO: replace with a call to dt.timestamp() when we drop Python 2.7
            return str(calendar.timegm(dt.utctimetuple()))

        if token == "x":
            # TODO: replace with a call to dt.timestamp() when we drop Python 2.7
            ts = calendar.timegm(dt.utctimetuple()) + (dt.microsecond / 1000000)
            return str(int(ts * 1000000))

        if token == "ZZZ":
            return dt.tzname()

        if token in ["ZZ", "Z"]:
            separator = ":" if token == "ZZ" else ""
            tz = dateutil_tz.tzutc() if dt.tzinfo is None else dt.tzinfo
            total_minutes = int(util.total_seconds(tz.utcoffset(dt)) / 60)

            sign = "+" if total_minutes >= 0 else "-"
            total_minutes = abs(total_minutes)
            hour, minute = divmod(total_minutes, 60)

            return "{}{:02d}{}{:02d}".format(sign, hour, separator, minute)

        if token in ("a", "A"):
            return self.locale.meridian(dt.hour, token)

        if token == "W":
            year, week, day = dt.isocalendar()
            return "{}-W{:02d}-{}".format(year, week, day)
# -*- coding: utf-8 -*-
from __future__ import absolute_import, unicode_literals

import inspect
import sys
from math import trunc


def get_locale(name):
    """Returns an appropriate :class:`Locale <arrow.locales.Locale>`
    corresponding to an inpute locale name.

    :param name: the name of the locale.

    """

    locale_cls = _locales.get(name.lower())

    if locale_cls is None:
        raise ValueError("Unsupported locale '{}'".format(name))

    return locale_cls()


def get_locale_by_class_name(name):
    """Returns an appropriate :class:`Locale <arrow.locales.Locale>`
    corresponding to an locale class name.

    :param name: the name of the locale class.

    """
    locale_cls = globals().get(name)

    if locale_cls is None:
        raise ValueError("Unsupported locale '{}'".format(name))

    return locale_cls()


# base locale type.


class Locale(object):
    """ Represents locale-specific data and functionality. """

    names = []

    timeframes = {
        "now": "",
        "second": "",
        "seconds": "",
        "minute": "",
        "minutes": "",
        "hour": "",
        "hours": "",
        "day": "",
        "days": "",
        "week": "",
        "weeks": "",
        "month": "",
        "months": "",
        "year": "",
        "years": "",
    }

    meridians = {"am": "", "pm": "", "AM": "", "PM": ""}

    past = None
    future = None
    and_word = None

    month_names = []
    month_abbreviations = []

    day_names = []
    day_abbreviations = []

    ordinal_day_re = r"(\d+)"

    def __init__(self):

        self._month_name_to_ordinal = None

    def describe(self, timeframe, delta=0, only_distance=False):
        """ Describes a delta within a timeframe in plain language.

        :param timeframe: a string representing a timeframe.
        :param delta: a quantity representing a delta in a timeframe.
        :param only_distance: return only distance eg: "11 seconds" without "in" or "ago" keywords
        """

        humanized = self._format_timeframe(timeframe, delta)
        if not only_distance:
            humanized = self._format_relative(humanized, timeframe, delta)

        return humanized

    def describe_multi(self, timeframes, only_distance=False):
        """ Describes a delta within multiple timeframes in plain language.

        :param timeframes: a list of string, quantity pairs each representing a timeframe and delta.
        :param only_distance: return only distance eg: "2 hours and 11 seconds" without "in" or "ago" keywords
        """

        humanized = ""
        for index, (timeframe, delta) in enumerate(timeframes):
            humanized += self._format_timeframe(timeframe, delta)
            if index == len(timeframes) - 2 and self.and_word:
                humanized += " " + self.and_word + " "
            elif index < len(timeframes) - 1:
                humanized += " "

        if not only_distance:
            humanized = self._format_relative(humanized, timeframe, delta)

        return humanized

    def day_name(self, day):
        """ Returns the day name for a specified day of the week.

        :param day: the ``int`` day of the week (1-7).

        """

        return self.day_names[day]

    def day_abbreviation(self, day):
        """ Returns the day abbreviation for a specified day of the week.

        :param day: the ``int`` day of the week (1-7).

        """

        return self.day_abbreviations[day]

    def month_name(self, month):
        """ Returns the month name for a specified month of the year.

        :param month: the ``int`` month of the year (1-12).

        """

        return self.month_names[month]

    def month_abbreviation(self, month):
        """ Returns the month abbreviation for a specified month of the year.

        :param month: the ``int`` month of the year (1-12).

        """

        return self.month_abbreviations[month]

    def month_number(self, name):
        """ Returns the month number for a month specified by name or abbreviation.

        :param name: the month name or abbreviation.

        """

        if self._month_name_to_ordinal is None:
            self._month_name_to_ordinal = self._name_to_ordinal(self.month_names)
            self._month_name_to_ordinal.update(
                self._name_to_ordinal(self.month_abbreviations)
            )

        return self._month_name_to_ordinal.get(name)

    def year_full(self, year):
        """  Returns the year for specific locale if available

        :param name: the ``int`` year (4-digit)
        """
        return "{:04d}".format(year)

    def year_abbreviation(self, year):
        """ Returns the year for specific locale if available

        :param name: the ``int`` year (4-digit)
        """
        return "{:04d}".format(year)[2:]

    def meridian(self, hour, token):
        """ Returns the meridian indicator for a specified hour and format token.

        :param hour: the ``int`` hour of the day.
        :param token: the format token.
        """

        if token == "a":
            return self.meridians["am"] if hour < 12 else self.meridians["pm"]
        if token == "A":
            return self.meridians["AM"] if hour < 12 else self.meridians["PM"]

    def ordinal_number(self, n):
        """ Returns the ordinal format of a given integer

        :param n: an integer
        """
        return self._ordinal_number(n)

    def _ordinal_number(self, n):
        return "{}".format(n)

    def _name_to_ordinal(self, lst):
        return dict(map(lambda i: (i[1].lower(), i[0] + 1), enumerate(lst[1:])))

    def _format_timeframe(self, timeframe, delta):
        return self.timeframes[timeframe].format(trunc(abs(delta)))

    def _format_relative(self, humanized, timeframe, delta):

        if timeframe == "now":
            return humanized

        direction = self.past if delta < 0 else self.future

        return direction.format(humanized)


# base locale type implementations.


class EnglishLocale(Locale):

    names = [
        "en",
        "en_us",
        "en_gb",
        "en_au",
        "en_be",
        "en_jp",
        "en_za",
        "en_ca",
        "en_ph",
    ]

    past = "{0} ago"
    future = "in {0}"
    and_word = "and"

    timeframes = {
        "now": "just now",
        "second": "a second",
        "seconds": "{0} seconds",
        "minute": "a minute",
        "minutes": "{0} minutes",
        "hour": "an hour",
        "hours": "{0} hours",
        "day": "a day",
        "days": "{0} days",
        "week": "a week",
        "weeks": "{0} weeks",
        "month": "a month",
        "months": "{0} months",
        "year": "a year",
        "years": "{0} years",
    }

    meridians = {"am": "am", "pm": "pm", "AM": "AM", "PM": "PM"}

    month_names = [
        "",
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
    ]
    month_abbreviations = [
        "",
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
    ]

    day_names = [
        "",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday",
    ]
    day_abbreviations = ["", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]

    ordinal_day_re = r"((?P<value>[2-3]?1(?=st)|[2-3]?2(?=nd)|[2-3]?3(?=rd)|[1-3]?[04-9](?=th)|1[1-3](?=th))(st|nd|rd|th))"

    def _ordinal_number(self, n):
        if n % 100 not in (11, 12, 13):
            remainder = abs(n) % 10
            if remainder == 1:
                return "{}st".format(n)
            elif remainder == 2:
                return "{}nd".format(n)
            elif remainder == 3:
                return "{}rd".format(n)
        return "{}th".format(n)

    def describe(self, timeframe, delta=0, only_distance=False):
        """ Describes a delta within a timeframe in plain language.

        :param timeframe: a string representing a timeframe.
        :param delta: a quantity representing a delta in a timeframe.
        :param only_distance: return only distance eg: "11 seconds" without "in" or "ago" keywords
        """

        humanized = super(EnglishLocale, self).describe(timeframe, delta, only_distance)
        if only_distance and timeframe == "now":
            humanized = "instantly"

        return humanized


class ItalianLocale(Locale):
    names = ["it", "it_it"]
    past = "{0} fa"
    future = "tra {0}"
    and_word = "e"

    timeframes = {
        "now": "adesso",
        "second": "un secondo",
        "seconds": "{0} qualche secondo",
        "minute": "un minuto",
        "minutes": "{0} minuti",
        "hour": "un'ora",
        "hours": "{0} ore",
        "day": "un giorno",
        "days": "{0} giorni",
        "week": "una settimana,",
        "weeks": "{0} settimane",
        "month": "un mese",
        "months": "{0} mesi",
        "year": "un anno",
        "years": "{0} anni",
    }

    month_names = [
        "",
        "gennaio",
        "febbraio",
        "marzo",
        "aprile",
        "maggio",
        "giugno",
        "luglio",
        "agosto",
        "settembre",
        "ottobre",
        "novembre",
        "dicembre",
    ]
    month_abbreviations = [
        "",
        "gen",
        "feb",
        "mar",
        "apr",
        "mag",
        "giu",
        "lug",
        "ago",
        "set",
        "ott",
        "nov",
        "dic",
    ]

    day_names = [
        "",
        "luned",
        "marted",
        "mercoled",
        "gioved",
        "venerd",
        "sabato",
        "domenica",
    ]
    day_abbreviations = ["", "lun", "mar", "mer", "gio", "ven", "sab", "dom"]

    ordinal_day_re = r"((?P<value>[1-3]?[0-9](?=[]))[])"

    def _ordinal_number(self, n):
        return "{}".format(n)


class SpanishLocale(Locale):
    names = ["es", "es_es"]
    past = "hace {0}"
    future = "en {0}"
    and_word = "y"

    timeframes = {
        "now": "ahora",
        "second": "un segundo",
        "seconds": "{0} segundos",
        "minute": "un minuto",
        "minutes": "{0} minutos",
        "hour": "una hora",
        "hours": "{0} horas",
        "day": "un da",
        "days": "{0} das",
        "week": "una semana",
        "weeks": "{0} semanas",
        "month": "un mes",
        "months": "{0} meses",
        "year": "un ao",
        "years": "{0} aos",
    }

    meridians = {"am": "am", "pm": "pm", "AM": "AM", "PM": "PM"}

    month_names = [
        "",
        "enero",
        "febrero",
        "marzo",
        "abril",
        "mayo",
        "junio",
        "julio",
        "agosto",
        "septiembre",
        "octubre",
        "noviembre",
        "diciembre",
    ]
    month_abbreviations = [
        "",
        "ene",
        "feb",
        "mar",
        "abr",
        "may",
        "jun",
        "jul",
        "ago",
        "sep",
        "oct",
        "nov",
        "dic",
    ]

    day_names = [
        "",
        "lunes",
        "martes",
        "mircoles",
        "jueves",
        "viernes",
        "sbado",
        "domingo",
    ]
    day_abbreviations = ["", "lun", "mar", "mie", "jue", "vie", "sab", "dom"]

    ordinal_day_re = r"((?P<value>[1-3]?[0-9](?=[]))[])"

    def _ordinal_number(self, n):
        return "{}".format(n)


class FrenchLocale(Locale):
    names = ["fr", "fr_fr"]
    past = "il y a {0}"
    future = "dans {0}"
    and_word = "et"

    timeframes = {
        "now": "maintenant",
        "second": "une seconde",
        "seconds": "{0} quelques secondes",
        "minute": "une minute",
        "minutes": "{0} minutes",
        "hour": "une heure",
        "hours": "{0} heures",
        "day": "un jour",
        "days": "{0} jours",
        "week": "une semaine",
        "weeks": "{0} semaines",
        "month": "un mois",
        "months": "{0} mois",
        "year": "un an",
        "years": "{0} ans",
    }

    month_names = [
        "",
        "janvier",
        "fvrier",
        "mars",
        "avril",
        "mai",
        "juin",
        "juillet",
        "aot",
        "septembre",
        "octobre",
        "novembre",
        "dcembre",
    ]
    month_abbreviations = [
        "",
        "janv",
        "fvr",
        "mars",
        "avr",
        "mai",
        "juin",
        "juil",
        "aot",
        "sept",
        "oct",
        "nov",
        "dc",
    ]

    day_names = [
        "",
        "lundi",
        "mardi",
        "mercredi",
        "jeudi",
        "vendredi",
        "samedi",
        "dimanche",
    ]
    day_abbreviations = ["", "lun", "mar", "mer", "jeu", "ven", "sam", "dim"]

    ordinal_day_re = (
        r"((?P<value>\b1(?=er\b)|[1-3]?[02-9](?=e\b)|[1-3]1(?=e\b))(er|e)\b)"
    )

    def _ordinal_number(self, n):
        if abs(n) == 1:
            return "{}er".format(n)
        return "{}e".format(n)


class GreekLocale(Locale):

    names = ["el", "el_gr"]

    past = "{0} "
    future = " {0}"
    and_word = ""

    timeframes = {
        "now": "",
        "second": " ",
        "seconds": "{0} ",
        "minute": " ",
        "minutes": "{0} ",
        "hour": " ",
        "hours": "{0} ",
        "day": " ",
        "days": "{0} ",
        "month": " ",
        "months": "{0} ",
        "year": " ",
        "years": "{0} ",
    }

    month_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]

    day_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    day_abbreviations = ["", "", "", "", "", "", "", ""]


class JapaneseLocale(Locale):

    names = ["ja", "ja_jp"]

    past = "{0}"
    future = "{0}"

    timeframes = {
        "now": "",
        "second": "",
        "seconds": "{0}",
        "minute": "1",
        "minutes": "{0}",
        "hour": "1",
        "hours": "{0}",
        "day": "1",
        "days": "{0}",
        "week": "1",
        "weeks": "{0}",
        "month": "1",
        "months": "{0}",
        "year": "1",
        "years": "{0}",
    }

    month_names = [
        "",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
    ]
    month_abbreviations = [
        "",
        " 1",
        " 2",
        " 3",
        " 4",
        " 5",
        " 6",
        " 7",
        " 8",
        " 9",
        "10",
        "11",
        "12",
    ]

    day_names = ["", "", "", "", "", "", "", ""]
    day_abbreviations = ["", "", "", "", "", "", "", ""]


class SwedishLocale(Locale):

    names = ["sv", "sv_se"]

    past = "fr {0} sen"
    future = "om {0}"
    and_word = "och"

    timeframes = {
        "now": "just nu",
        "second": "en sekund",
        "seconds": "{0} ngra sekunder",
        "minute": "en minut",
        "minutes": "{0} minuter",
        "hour": "en timme",
        "hours": "{0} timmar",
        "day": "en dag",
        "days": "{0} dagar",
        "month": "en mnad",
        "months": "{0} mnader",
        "year": "ett r",
        "years": "{0} r",
    }

    month_names = [
        "",
        "januari",
        "februari",
        "mars",
        "april",
        "maj",
        "juni",
        "juli",
        "augusti",
        "september",
        "oktober",
        "november",
        "december",
    ]
    month_abbreviations = [
        "",
        "jan",
        "feb",
        "mar",
        "apr",
        "maj",
        "jun",
        "jul",
        "aug",
        "sep",
        "okt",
        "nov",
        "dec",
    ]

    day_names = [
        "",
        "mndag",
        "tisdag",
        "onsdag",
        "torsdag",
        "fredag",
        "lrdag",
        "sndag",
    ]
    day_abbreviations = ["", "mn", "tis", "ons", "tor", "fre", "lr", "sn"]


class FinnishLocale(Locale):

    names = ["fi", "fi_fi"]

    # The finnish grammar is very complex, and its hard to convert
    # 1-to-1 to something like English.

    past = "{0} sitten"
    future = "{0} kuluttua"

    timeframes = {
        "now": ["juuri nyt", "juuri nyt"],
        "second": ["sekunti", "sekunti"],
        "seconds": ["{0} muutama sekunti", "{0} muutaman sekunnin"],
        "minute": ["minuutti", "minuutin"],
        "minutes": ["{0} minuuttia", "{0} minuutin"],
        "hour": ["tunti", "tunnin"],
        "hours": ["{0} tuntia", "{0} tunnin"],
        "day": ["piv", "piv"],
        "days": ["{0} piv", "{0} pivn"],
        "month": ["kuukausi", "kuukauden"],
        "months": ["{0} kuukautta", "{0} kuukauden"],
        "year": ["vuosi", "vuoden"],
        "years": ["{0} vuotta", "{0} vuoden"],
    }

    # Months and days are lowercase in Finnish
    month_names = [
        "",
        "tammikuu",
        "helmikuu",
        "maaliskuu",
        "huhtikuu",
        "toukokuu",
        "keskuu",
        "heinkuu",
        "elokuu",
        "syyskuu",
        "lokakuu",
        "marraskuu",
        "joulukuu",
    ]

    month_abbreviations = [
        "",
        "tammi",
        "helmi",
        "maalis",
        "huhti",
        "touko",
        "kes",
        "hein",
        "elo",
        "syys",
        "loka",
        "marras",
        "joulu",
    ]

    day_names = [
        "",
        "maanantai",
        "tiistai",
        "keskiviikko",
        "torstai",
        "perjantai",
        "lauantai",
        "sunnuntai",
    ]

    day_abbreviations = ["", "ma", "ti", "ke", "to", "pe", "la", "su"]

    def _format_timeframe(self, timeframe, delta):
        return (
            self.timeframes[timeframe][0].format(abs(delta)),
            self.timeframes[timeframe][1].format(abs(delta)),
        )

    def _format_relative(self, humanized, timeframe, delta):
        if timeframe == "now":
            return humanized[0]

        direction = self.past if delta < 0 else self.future
        which = 0 if delta < 0 else 1

        return direction.format(humanized[which])

    def _ordinal_number(self, n):
        return "{}.".format(n)


class ChineseCNLocale(Locale):

    names = ["zh", "zh_cn"]

    past = "{0}"
    future = "{0}"

    timeframes = {
        "now": "",
        "second": "",
        "seconds": "{0}",
        "minute": "1",
        "minutes": "{0}",
        "hour": "1",
        "hours": "{0}",
        "day": "1",
        "days": "{0}",
        "week": "",
        "weeks": "{0}",
        "month": "1",
        "months": "{0}",
        "year": "1",
        "years": "{0}",
    }

    month_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        " 1",
        " 2",
        " 3",
        " 4",
        " 5",
        " 6",
        " 7",
        " 8",
        " 9",
        "10",
        "11",
        "12",
    ]

    day_names = ["", "", "", "", "", "", "", ""]
    day_abbreviations = ["", "", "", "", "", "", "", ""]


class ChineseTWLocale(Locale):

    names = ["zh_tw"]

    past = "{0}"
    future = "{0}"
    and_word = ""

    timeframes = {
        "now": "",
        "second": "1",
        "seconds": "{0}",
        "minute": "1",
        "minutes": "{0}",
        "hour": "1",
        "hours": "{0}",
        "day": "1",
        "days": "{0}",
        "week": "1",
        "weeks": "{0}",
        "month": "1",
        "months": "{0}",
        "year": "1",
        "years": "{0}",
    }

    month_names = [
        "",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
    ]
    month_abbreviations = [
        "",
        " 1",
        " 2",
        " 3",
        " 4",
        " 5",
        " 6",
        " 7",
        " 8",
        " 9",
        "10",
        "11",
        "12",
    ]

    day_names = ["", "", "", "", "", "", "", ""]
    day_abbreviations = ["", "", "", "", "", "", "", ""]


class HongKongLocale(Locale):

    names = ["zh_hk"]

    past = "{0}"
    future = "{0}"

    timeframes = {
        "now": "",
        "second": "1",
        "seconds": "{0}",
        "minute": "1",
        "minutes": "{0}",
        "hour": "1",
        "hours": "{0}",
        "day": "1",
        "days": "{0}",
        "week": "1",
        "weeks": "{0}",
        "month": "1",
        "months": "{0}",
        "year": "1",
        "years": "{0}",
    }

    month_names = [
        "",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
    ]
    month_abbreviations = [
        "",
        " 1",
        " 2",
        " 3",
        " 4",
        " 5",
        " 6",
        " 7",
        " 8",
        " 9",
        "10",
        "11",
        "12",
    ]

    day_names = ["", "", "", "", "", "", "", ""]
    day_abbreviations = ["", "", "", "", "", "", "", ""]


class KoreanLocale(Locale):

    names = ["ko", "ko_kr"]

    past = "{0} "
    future = "{0} "

    timeframes = {
        "now": "",
        "second": " ",
        "seconds": "{0} ",
        "minute": "1",
        "minutes": "{0}",
        "hour": "1",
        "hours": "{0}",
        "day": "1",
        "days": "{0}",
        "month": "1",
        "months": "{0}",
        "year": "1",
        "years": "{0}",
    }

    month_names = [
        "",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
    ]
    month_abbreviations = [
        "",
        " 1",
        " 2",
        " 3",
        " 4",
        " 5",
        " 6",
        " 7",
        " 8",
        " 9",
        "10",
        "11",
        "12",
    ]

    day_names = ["", "", "", "", "", "", "", ""]
    day_abbreviations = ["", "", "", "", "", "", "", ""]


# derived locale types & implementations.
class DutchLocale(Locale):

    names = ["nl", "nl_nl"]

    past = "{0} geleden"
    future = "over {0}"

    timeframes = {
        "now": "nu",
        "second": "een seconde",
        "seconds": "{0} seconden",
        "minute": "een minuut",
        "minutes": "{0} minuten",
        "hour": "een uur",
        "hours": "{0} uur",
        "day": "een dag",
        "days": "{0} dagen",
        "week": "een week",
        "weeks": "{0} weken",
        "month": "een maand",
        "months": "{0} maanden",
        "year": "een jaar",
        "years": "{0} jaar",
    }

    # In Dutch names of months and days are not starting with a capital letter
    # like in the English language.
    month_names = [
        "",
        "januari",
        "februari",
        "maart",
        "april",
        "mei",
        "juni",
        "juli",
        "augustus",
        "september",
        "oktober",
        "november",
        "december",
    ]
    month_abbreviations = [
        "",
        "jan",
        "feb",
        "mrt",
        "apr",
        "mei",
        "jun",
        "jul",
        "aug",
        "sep",
        "okt",
        "nov",
        "dec",
    ]

    day_names = [
        "",
        "maandag",
        "dinsdag",
        "woensdag",
        "donderdag",
        "vrijdag",
        "zaterdag",
        "zondag",
    ]
    day_abbreviations = ["", "ma", "di", "wo", "do", "vr", "za", "zo"]


class SlavicBaseLocale(Locale):
    def _format_timeframe(self, timeframe, delta):

        form = self.timeframes[timeframe]
        delta = abs(delta)

        if isinstance(form, list):

            if delta % 10 == 1 and delta % 100 != 11:
                form = form[0]
            elif 2 <= delta % 10 <= 4 and (delta % 100 < 10 or delta % 100 >= 20):
                form = form[1]
            else:
                form = form[2]

        return form.format(delta)


class BelarusianLocale(SlavicBaseLocale):

    names = ["be", "be_by"]

    past = "{0} "
    future = " {0}"

    timeframes = {
        "now": "",
        "second": "",
        "seconds": "{0}  ",
        "minute": "",
        "minutes": ["{0} ", "{0} ", "{0} "],
        "hour": "",
        "hours": ["{0} ", "{0} ", "{0} "],
        "day": "",
        "days": ["{0} ", "{0} ", "{0} "],
        "month": "",
        "months": ["{0} ", "{0} ", "{0} "],
        "year": "",
        "years": ["{0} ", "{0} ", "{0} "],
    }

    month_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]

    day_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    day_abbreviations = ["", "", "", "", "", "", "", ""]


class PolishLocale(SlavicBaseLocale):

    names = ["pl", "pl_pl"]

    past = "{0} temu"
    future = "za {0}"

    # The nouns should be in genitive case (Polish: "dopeniacz")
    # in order to correctly form `past` & `future` expressions.
    timeframes = {
        "now": "teraz",
        "second": "sekund",
        "seconds": ["{0} sekund", "{0} sekundy", "{0} sekund"],
        "minute": "minut",
        "minutes": ["{0} minut", "{0} minuty", "{0} minut"],
        "hour": "godzin",
        "hours": ["{0} godzin", "{0} godziny", "{0} godzin"],
        "day": "dzie",
        "days": "{0} dni",
        "week": "tydzie",
        "weeks": ["{0} tygodni", "{0} tygodnie", "{0} tygodni"],
        "month": "miesic",
        "months": ["{0} miesicy", "{0} miesice", "{0} miesicy"],
        "year": "rok",
        "years": ["{0} lat", "{0} lata", "{0} lat"],
    }

    month_names = [
        "",
        "stycze",
        "luty",
        "marzec",
        "kwiecie",
        "maj",
        "czerwiec",
        "lipiec",
        "sierpie",
        "wrzesie",
        "padziernik",
        "listopad",
        "grudzie",
    ]
    month_abbreviations = [
        "",
        "sty",
        "lut",
        "mar",
        "kwi",
        "maj",
        "cze",
        "lip",
        "sie",
        "wrz",
        "pa",
        "lis",
        "gru",
    ]

    day_names = [
        "",
        "poniedziaek",
        "wtorek",
        "roda",
        "czwartek",
        "pitek",
        "sobota",
        "niedziela",
    ]
    day_abbreviations = ["", "Pn", "Wt", "r", "Czw", "Pt", "So", "Nd"]


class RussianLocale(SlavicBaseLocale):

    names = ["ru", "ru_ru"]

    past = "{0} "
    future = " {0}"

    timeframes = {
        "now": "",
        "second": "",
        "seconds": "{0}  ",
        "minute": "",
        "minutes": ["{0} ", "{0} ", "{0} "],
        "hour": "",
        "hours": ["{0} ", "{0} ", "{0} "],
        "day": "",
        "days": ["{0} ", "{0} ", "{0} "],
        "week": "",
        "weeks": ["{0} ", "{0} ", "{0} "],
        "month": "",
        "months": ["{0} ", "{0} ", "{0} "],
        "year": "",
        "years": ["{0} ", "{0} ", "{0} "],
    }

    month_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]

    day_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    day_abbreviations = ["", "", "", "", "", "", "", ""]


class AfrikaansLocale(Locale):

    names = ["af", "af_nl"]

    past = "{0} gelede"
    future = "in {0}"

    timeframes = {
        "now": "nou",
        "second": "n sekonde",
        "seconds": "{0} sekondes",
        "minute": "minuut",
        "minutes": "{0} minute",
        "hour": "uur",
        "hours": "{0} ure",
        "day": "een dag",
        "days": "{0} dae",
        "month": "een maand",
        "months": "{0} maande",
        "year": "een jaar",
        "years": "{0} jaar",
    }

    month_names = [
        "",
        "Januarie",
        "Februarie",
        "Maart",
        "April",
        "Mei",
        "Junie",
        "Julie",
        "Augustus",
        "September",
        "Oktober",
        "November",
        "Desember",
    ]
    month_abbreviations = [
        "",
        "Jan",
        "Feb",
        "Mrt",
        "Apr",
        "Mei",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Okt",
        "Nov",
        "Des",
    ]

    day_names = [
        "",
        "Maandag",
        "Dinsdag",
        "Woensdag",
        "Donderdag",
        "Vrydag",
        "Saterdag",
        "Sondag",
    ]
    day_abbreviations = ["", "Ma", "Di", "Wo", "Do", "Vr", "Za", "So"]


class BulgarianLocale(SlavicBaseLocale):

    names = ["bg", "bg_BG"]

    past = "{0} "
    future = " {0}"

    timeframes = {
        "now": "",
        "second": "",
        "seconds": "{0}  ",
        "minute": "",
        "minutes": ["{0} ", "{0} ", "{0} "],
        "hour": "",
        "hours": ["{0} ", "{0} ", "{0} "],
        "day": "",
        "days": ["{0} ", "{0} ", "{0} "],
        "month": "",
        "months": ["{0} ", "{0} ", "{0} "],
        "year": "",
        "years": ["{0} ", "{0} ", "{0} "],
    }

    month_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]

    day_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    day_abbreviations = ["", "", "", "", "", "", "", ""]


class UkrainianLocale(SlavicBaseLocale):

    names = ["ua", "uk_ua"]

    past = "{0} "
    future = " {0}"

    timeframes = {
        "now": "",
        "second": "",
        "seconds": "{0}  ",
        "minute": "",
        "minutes": ["{0} ", "{0} ", "{0} "],
        "hour": "",
        "hours": ["{0} ", "{0} ", "{0} "],
        "day": "",
        "days": ["{0} ", "{0} ", "{0} "],
        "month": "",
        "months": ["{0} ", "{0} ", "{0} "],
        "year": "",
        "years": ["{0} ", "{0} ", "{0} "],
    }

    month_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]

    day_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    day_abbreviations = ["", "", "", "", "", "", "", ""]


class MacedonianLocale(SlavicBaseLocale):
    names = ["mk", "mk_mk"]

    past = " {0}"
    future = " {0}"

    timeframes = {
        "now": "",
        "second": "",
        "seconds": "{0} ",
        "minute": " ",
        "minutes": ["{0} ", "{0} ", "{0} "],
        "hour": " ",
        "hours": ["{0} ", "{0} ", "{0} "],
        "day": " ",
        "days": ["{0} ", "{0} ", "{0} "],
        "month": " ",
        "months": ["{0} ", "{0} ", "{0} "],
        "year": " ",
        "years": ["{0} ", "{0} ", "{0} "],
    }

    meridians = {"am": "", "pm": "", "AM": "", "PM": ""}

    month_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        ".",
        " .",
        " .",
        " .",
        " ",
        " .",
        " .",
        " .",
        " .",
        " .",
        " .",
        " .",
    ]

    day_names = [
        "",
        "",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
    ]
    day_abbreviations = [
        "",
        ".",
        " .",
        " .",
        " .",
        " .",
        " .",
        " .",
    ]


class GermanBaseLocale(Locale):

    past = "vor {0}"
    future = "in {0}"
    and_word = "und"

    timeframes = {
        "now": "gerade eben",
        "second": "eine Sekunde",
        "seconds": "{0} Sekunden",
        "minute": "einer Minute",
        "minutes": "{0} Minuten",
        "hour": "einer Stunde",
        "hours": "{0} Stunden",
        "day": "einem Tag",
        "days": "{0} Tagen",
        "week": "einer Woche",
        "weeks": "{0} Wochen",
        "month": "einem Monat",
        "months": "{0} Monaten",
        "year": "einem Jahr",
        "years": "{0} Jahren",
    }

    timeframes_only_distance = timeframes.copy()
    timeframes_only_distance["minute"] = "eine Minute"
    timeframes_only_distance["hour"] = "eine Stunde"
    timeframes_only_distance["day"] = "ein Tag"
    timeframes_only_distance["week"] = "eine Woche"
    timeframes_only_distance["month"] = "ein Monat"
    timeframes_only_distance["year"] = "ein Jahr"

    month_names = [
        "",
        "Januar",
        "Februar",
        "Mrz",
        "April",
        "Mai",
        "Juni",
        "Juli",
        "August",
        "September",
        "Oktober",
        "November",
        "Dezember",
    ]

    month_abbreviations = [
        "",
        "Jan",
        "Feb",
        "Mr",
        "Apr",
        "Mai",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Okt",
        "Nov",
        "Dez",
    ]

    day_names = [
        "",
        "Montag",
        "Dienstag",
        "Mittwoch",
        "Donnerstag",
        "Freitag",
        "Samstag",
        "Sonntag",
    ]

    day_abbreviations = ["", "Mo", "Di", "Mi", "Do", "Fr", "Sa", "So"]

    def _ordinal_number(self, n):
        return "{}.".format(n)

    def describe(self, timeframe, delta=0, only_distance=False):
        """ Describes a delta within a timeframe in plain language.

        :param timeframe: a string representing a timeframe.
        :param delta: a quantity representing a delta in a timeframe.
        :param only_distance: return only distance eg: "11 seconds" without "in" or "ago" keywords
        """

        if not only_distance:
            return super(GermanBaseLocale, self).describe(
                timeframe, delta, only_distance
            )

        # German uses a different case without 'in' or 'ago'
        humanized = self.timeframes_only_distance[timeframe].format(trunc(abs(delta)))

        return humanized


class GermanLocale(GermanBaseLocale, Locale):

    names = ["de", "de_de"]


class SwissLocale(GermanBaseLocale, Locale):

    names = ["de_ch"]


class AustrianLocale(GermanBaseLocale, Locale):

    names = ["de_at"]

    month_names = [
        "",
        "Jnner",
        "Februar",
        "Mrz",
        "April",
        "Mai",
        "Juni",
        "Juli",
        "August",
        "September",
        "Oktober",
        "November",
        "Dezember",
    ]


class NorwegianLocale(Locale):

    names = ["nb", "nb_no"]

    past = "for {0} siden"
    future = "om {0}"

    timeframes = {
        "now": "n nettopp",
        "second": "et sekund",
        "seconds": "{0} noen sekunder",
        "minute": "ett minutt",
        "minutes": "{0} minutter",
        "hour": "en time",
        "hours": "{0} timer",
        "day": "en dag",
        "days": "{0} dager",
        "month": "en mned",
        "months": "{0} mneder",
        "year": "ett r",
        "years": "{0} r",
    }

    month_names = [
        "",
        "januar",
        "februar",
        "mars",
        "april",
        "mai",
        "juni",
        "juli",
        "august",
        "september",
        "oktober",
        "november",
        "desember",
    ]
    month_abbreviations = [
        "",
        "jan",
        "feb",
        "mar",
        "apr",
        "mai",
        "jun",
        "jul",
        "aug",
        "sep",
        "okt",
        "nov",
        "des",
    ]

    day_names = [
        "",
        "mandag",
        "tirsdag",
        "onsdag",
        "torsdag",
        "fredag",
        "lrdag",
        "sndag",
    ]
    day_abbreviations = ["", "ma", "ti", "on", "to", "fr", "l", "s"]


class NewNorwegianLocale(Locale):

    names = ["nn", "nn_no"]

    past = "for {0} sidan"
    future = "om {0}"

    timeframes = {
        "now": "no nettopp",
        "second": "et sekund",
        "seconds": "{0} nokre sekund",
        "minute": "ett minutt",
        "minutes": "{0} minutt",
        "hour": "ein time",
        "hours": "{0} timar",
        "day": "ein dag",
        "days": "{0} dagar",
        "month": "en mnad",
        "months": "{0} mnader",
        "year": "eit r",
        "years": "{0} r",
    }

    month_names = [
        "",
        "januar",
        "februar",
        "mars",
        "april",
        "mai",
        "juni",
        "juli",
        "august",
        "september",
        "oktober",
        "november",
        "desember",
    ]
    month_abbreviations = [
        "",
        "jan",
        "feb",
        "mar",
        "apr",
        "mai",
        "jun",
        "jul",
        "aug",
        "sep",
        "okt",
        "nov",
        "des",
    ]

    day_names = [
        "",
        "mndag",
        "tysdag",
        "onsdag",
        "torsdag",
        "fredag",
        "laurdag",
        "sundag",
    ]
    day_abbreviations = ["", "m", "ty", "on", "to", "fr", "la", "su"]


class PortugueseLocale(Locale):
    names = ["pt", "pt_pt"]

    past = "h {0}"
    future = "em {0}"
    and_word = "e"

    timeframes = {
        "now": "agora",
        "second": "um segundo",
        "seconds": "{0} segundos",
        "minute": "um minuto",
        "minutes": "{0} minutos",
        "hour": "uma hora",
        "hours": "{0} horas",
        "day": "um dia",
        "days": "{0} dias",
        "week": "uma semana",
        "weeks": "{0} semanas",
        "month": "um ms",
        "months": "{0} meses",
        "year": "um ano",
        "years": "{0} anos",
    }

    month_names = [
        "",
        "janeiro",
        "fevereiro",
        "maro",
        "abril",
        "maio",
        "junho",
        "julho",
        "agosto",
        "setembro",
        "outubro",
        "novembro",
        "dezembro",
    ]
    month_abbreviations = [
        "",
        "jan",
        "fev",
        "mar",
        "abr",
        "maio",
        "jun",
        "jul",
        "ago",
        "set",
        "out",
        "nov",
        "dez",
    ]

    day_names = [
        "",
        "segunda-feira",
        "tera-feira",
        "quarta-feira",
        "quinta-feira",
        "sexta-feira",
        "sbado",
        "domingo",
    ]
    day_abbreviations = ["", "seg", "ter", "qua", "qui", "sex", "sab", "dom"]


class BrazilianPortugueseLocale(PortugueseLocale):
    names = ["pt_br"]

    past = "faz {0}"

    future = "em {0}"

    timeframes = {
        "now": "agora",
        "second": "um segundo",
        "seconds": "{0} segundos",
        "minute": "um minuto",
        "minutes": "{0} minutos",
        "hour": "uma hora",
        "hours": "{0} horas",
        "day": "um dia",
        "days": "{0} dias",
        "week": "uma semana",
        "weeks": "{0} semanas",
        "month": "um ms",
        "months": "{0} meses",
        "year": "um ano",
        "years": "{0} anos",
    }

    month_names = [
        "",
        "Janeiro",
        "Fevereiro",
        "Maro",
        "Abril",
        "Maio",
        "Junho",
        "Julho",
        "Agosto",
        "Setembro",
        "Outubro",
        "Novembro",
        "Dezembro",
    ]
    month_abbreviations = [
        "",
        "Jan",
        "Fev",
        "Mar",
        "Abr",
        "Mai",
        "Jun",
        "Jul",
        "Ago",
        "Set",
        "Out",
        "Nov",
        "Dez",
    ]

    day_names = [
        "",
        "Segunda-feira",
        "Tera-feira",
        "Quarta-feira",
        "Quinta-feira",
        "Sexta-feira",
        "Sbado",
        "Domingo",
    ]
    day_abbreviations = ["", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab", "Dom"]


class TagalogLocale(Locale):

    names = ["tl", "tl_ph"]

    past = "nakaraang {0}"
    future = "{0} mula ngayon"

    timeframes = {
        "now": "ngayon lang",
        "second": "isang segundo",
        "seconds": "{0} segundo",
        "minute": "isang minuto",
        "minutes": "{0} minuto",
        "hour": "isang oras",
        "hours": "{0} oras",
        "day": "isang araw",
        "days": "{0} araw",
        "month": "isang buwan",
        "months": "{0} buwan",
        "year": "isang taon",
        "years": "{0} taon",
    }

    month_names = [
        "",
        "Enero",
        "Pebrero",
        "Marso",
        "Abril",
        "Mayo",
        "Hunyo",
        "Hulyo",
        "Agosto",
        "Setyembre",
        "Oktubre",
        "Nobyembre",
        "Disyembre",
    ]
    month_abbreviations = [
        "",
        "Ene",
        "Peb",
        "Mar",
        "Abr",
        "May",
        "Hun",
        "Hul",
        "Ago",
        "Set",
        "Okt",
        "Nob",
        "Dis",
    ]

    day_names = [
        "",
        "Lunes",
        "Martes",
        "Miyerkules",
        "Huwebes",
        "Biyernes",
        "Sabado",
        "Linggo",
    ]
    day_abbreviations = ["", "Lun", "Mar", "Miy", "Huw", "Biy", "Sab", "Lin"]

    def _ordinal_number(self, n):
        return "ika-{}".format(n)


class VietnameseLocale(Locale):

    names = ["vi", "vi_vn"]

    past = "{0} trc"
    future = "{0} na"

    timeframes = {
        "now": "hin ti",
        "second": "mt giy",
        "seconds": "{0} giy",
        "minute": "mt pht",
        "minutes": "{0} pht",
        "hour": "mt gi",
        "hours": "{0} gi",
        "day": "mt ngy",
        "days": "{0} ngy",
        "week": "mt tun",
        "weeks": "{0} tun",
        "month": "mt thng",
        "months": "{0} thng",
        "year": "mt nm",
        "years": "{0} nm",
    }

    month_names = [
        "",
        "Thng Mt",
        "Thng Hai",
        "Thng Ba",
        "Thng T",
        "Thng Nm",
        "Thng Su",
        "Thng By",
        "Thng Tm",
        "Thng Chn",
        "Thng Mi",
        "Thng Mi Mt",
        "Thng Mi Hai",
    ]
    month_abbreviations = [
        "",
        "Thng 1",
        "Thng 2",
        "Thng 3",
        "Thng 4",
        "Thng 5",
        "Thng 6",
        "Thng 7",
        "Thng 8",
        "Thng 9",
        "Thng 10",
        "Thng 11",
        "Thng 12",
    ]

    day_names = [
        "",
        "Th Hai",
        "Th Ba",
        "Th T",
        "Th Nm",
        "Th Su",
        "Th By",
        "Ch Nht",
    ]
    day_abbreviations = ["", "Th 2", "Th 3", "Th 4", "Th 5", "Th 6", "Th 7", "CN"]


class TurkishLocale(Locale):

    names = ["tr", "tr_tr"]

    past = "{0} nce"
    future = "{0} sonra"

    timeframes = {
        "now": "imdi",
        "second": "bir saniye",
        "seconds": "{0} saniye",
        "minute": "bir dakika",
        "minutes": "{0} dakika",
        "hour": "bir saat",
        "hours": "{0} saat",
        "day": "bir gn",
        "days": "{0} gn",
        "month": "bir ay",
        "months": "{0} ay",
        "year": "yl",
        "years": "{0} yl",
    }

    month_names = [
        "",
        "Ocak",
        "ubat",
        "Mart",
        "Nisan",
        "Mays",
        "Haziran",
        "Temmuz",
        "Austos",
        "Eyll",
        "Ekim",
        "Kasm",
        "Aralk",
    ]
    month_abbreviations = [
        "",
        "Oca",
        "ub",
        "Mar",
        "Nis",
        "May",
        "Haz",
        "Tem",
        "Au",
        "Eyl",
        "Eki",
        "Kas",
        "Ara",
    ]

    day_names = [
        "",
        "Pazartesi",
        "Sal",
        "aramba",
        "Perembe",
        "Cuma",
        "Cumartesi",
        "Pazar",
    ]
    day_abbreviations = ["", "Pzt", "Sal", "ar", "Per", "Cum", "Cmt", "Paz"]


class AzerbaijaniLocale(Locale):

    names = ["az", "az_az"]

    past = "{0} vvl"
    future = "{0} sonra"

    timeframes = {
        "now": "indi",
        "second": "saniy",
        "seconds": "{0} saniy",
        "minute": "bir dqiq",
        "minutes": "{0} dqiq",
        "hour": "bir saat",
        "hours": "{0} saat",
        "day": "bir gn",
        "days": "{0} gn",
        "month": "bir ay",
        "months": "{0} ay",
        "year": "il",
        "years": "{0} il",
    }

    month_names = [
        "",
        "Yanvar",
        "Fevral",
        "Mart",
        "Aprel",
        "May",
        "yun",
        "yul",
        "Avqust",
        "Sentyabr",
        "Oktyabr",
        "Noyabr",
        "Dekabr",
    ]
    month_abbreviations = [
        "",
        "Yan",
        "Fev",
        "Mar",
        "Apr",
        "May",
        "yn",
        "yl",
        "Avq",
        "Sen",
        "Okt",
        "Noy",
        "Dek",
    ]

    day_names = [
        "",
        "Bazar ertsi",
        "rnb axam",
        "rnb",
        "Cm axam",
        "Cm",
        "nb",
        "Bazar",
    ]
    day_abbreviations = ["", "Ber", "ax", "r", "Cax", "Cm", "nb", "Bzr"]


class ArabicLocale(Locale):
    names = [
        "ar",
        "ar_ae",
        "ar_bh",
        "ar_dj",
        "ar_eg",
        "ar_eh",
        "ar_er",
        "ar_km",
        "ar_kw",
        "ar_ly",
        "ar_om",
        "ar_qa",
        "ar_sa",
        "ar_sd",
        "ar_so",
        "ar_ss",
        "ar_td",
        "ar_ye",
    ]

    past = " {0}"
    future = " {0}"

    timeframes = {
        "now": "",
        "second": "",
        "seconds": {"double": "", "ten": "{0} ", "higher": "{0} "},
        "minute": "",
        "minutes": {"double": "", "ten": "{0} ", "higher": "{0} "},
        "hour": "",
        "hours": {"double": "", "ten": "{0} ", "higher": "{0} "},
        "day": "",
        "days": {"double": "", "ten": "{0} ", "higher": "{0} "},
        "month": "",
        "months": {"double": "", "ten": "{0} ", "higher": "{0} "},
        "year": "",
        "years": {"double": "", "ten": "{0} ", "higher": "{0} "},
    }

    month_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]

    day_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    day_abbreviations = ["", "", "", "", "", "", "", ""]

    def _format_timeframe(self, timeframe, delta):
        form = self.timeframes[timeframe]
        delta = abs(delta)
        if isinstance(form, dict):
            if delta == 2:
                form = form["double"]
            elif delta > 2 and delta <= 10:
                form = form["ten"]
            else:
                form = form["higher"]

        return form.format(delta)


class LevantArabicLocale(ArabicLocale):
    names = ["ar_iq", "ar_jo", "ar_lb", "ar_ps", "ar_sy"]
    month_names = [
        "",
        " ",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        " ",
        " ",
        " ",
    ]
    month_abbreviations = [
        "",
        " ",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        " ",
        " ",
        " ",
    ]


class AlgeriaTunisiaArabicLocale(ArabicLocale):
    names = ["ar_tn", "ar_dz"]
    month_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]


class MauritaniaArabicLocale(ArabicLocale):
    names = ["ar_mr"]
    month_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]


class MoroccoArabicLocale(ArabicLocale):
    names = ["ar_ma"]
    month_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]


class IcelandicLocale(Locale):
    def _format_timeframe(self, timeframe, delta):

        timeframe = self.timeframes[timeframe]
        if delta < 0:
            timeframe = timeframe[0]
        elif delta > 0:
            timeframe = timeframe[1]

        return timeframe.format(abs(delta))

    names = ["is", "is_is"]

    past = "fyrir {0} san"
    future = "eftir {0}"

    timeframes = {
        "now": "rtt  essu",
        "second": ("sekndu", "sekndu"),
        "seconds": ("{0} nokkrum sekndum", "nokkrar sekndur"),
        "minute": ("einni mntu", "eina mntu"),
        "minutes": ("{0} mntum", "{0} mntur"),
        "hour": ("einum tma", "einn tma"),
        "hours": ("{0} tmum", "{0} tma"),
        "day": ("einum degi", "einn dag"),
        "days": ("{0} dgum", "{0} daga"),
        "month": ("einum mnui", "einn mnu"),
        "months": ("{0} mnuum", "{0} mnui"),
        "year": ("einu ri", "eitt r"),
        "years": ("{0} rum", "{0} r"),
    }

    meridians = {"am": "f.h.", "pm": "e.h.", "AM": "f.h.", "PM": "e.h."}

    month_names = [
        "",
        "janar",
        "febrar",
        "mars",
        "aprl",
        "ma",
        "jn",
        "jl",
        "gst",
        "september",
        "oktber",
        "nvember",
        "desember",
    ]
    month_abbreviations = [
        "",
        "jan",
        "feb",
        "mar",
        "apr",
        "ma",
        "jn",
        "jl",
        "g",
        "sep",
        "okt",
        "nv",
        "des",
    ]

    day_names = [
        "",
        "mnudagur",
        "rijudagur",
        "mivikudagur",
        "fimmtudagur",
        "fstudagur",
        "laugardagur",
        "sunnudagur",
    ]
    day_abbreviations = ["", "mn", "ri", "mi", "fim", "fs", "lau", "sun"]


class DanishLocale(Locale):

    names = ["da", "da_dk"]

    past = "for {0} siden"
    future = "efter {0}"
    and_word = "og"

    timeframes = {
        "now": "lige nu",
        "second": "et sekund",
        "seconds": "{0} et par sekunder",
        "minute": "et minut",
        "minutes": "{0} minutter",
        "hour": "en time",
        "hours": "{0} timer",
        "day": "en dag",
        "days": "{0} dage",
        "month": "en mned",
        "months": "{0} mneder",
        "year": "et r",
        "years": "{0} r",
    }

    month_names = [
        "",
        "januar",
        "februar",
        "marts",
        "april",
        "maj",
        "juni",
        "juli",
        "august",
        "september",
        "oktober",
        "november",
        "december",
    ]
    month_abbreviations = [
        "",
        "jan",
        "feb",
        "mar",
        "apr",
        "maj",
        "jun",
        "jul",
        "aug",
        "sep",
        "okt",
        "nov",
        "dec",
    ]

    day_names = [
        "",
        "mandag",
        "tirsdag",
        "onsdag",
        "torsdag",
        "fredag",
        "lrdag",
        "sndag",
    ]
    day_abbreviations = ["", "man", "tir", "ons", "tor", "fre", "lr", "sn"]


class MalayalamLocale(Locale):

    names = ["ml"]

    past = "{0} "
    future = "{0} "

    timeframes = {
        "now": "",
        "second": " ",
        "seconds": "{0} ",
        "minute": " ",
        "minutes": "{0} ",
        "hour": " ",
        "hours": "{0} ",
        "day": "  ",
        "days": "{0}  ",
        "month": "  ",
        "months": "{0}  ",
        "year": "  ",
        "years": "{0}  ",
    }

    meridians = {
        "am": "",
        "pm": " ",
        "AM": "",
        "PM": " ",
    }

    month_names = [
        "",
        "",
        "",
        "",
        " ",
        " ",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        "",
        " ",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]

    day_names = ["", "", "", "", "", "", "", ""]
    day_abbreviations = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]


class HindiLocale(Locale):

    names = ["hi"]

    past = "{0} "
    future = "{0} "

    timeframes = {
        "now": "",
        "second": " ",
        "seconds": "{0} ",
        "minute": "  ",
        "minutes": "{0}  ",
        "hour": " ",
        "hours": "{0} ",
        "day": " ",
        "days": "{0} ",
        "month": "  ",
        "months": "{0}  ",
        "year": "  ",
        "years": "{0}  ",
    }

    meridians = {"am": "", "pm": "", "AM": "", "PM": ""}

    month_names = [
        "",
        "",
        "",
        "",
        " ",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]

    day_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    day_abbreviations = ["", "", "", "", "", "", "", ""]


class CzechLocale(Locale):
    names = ["cs", "cs_cz"]

    timeframes = {
        "now": "Te",
        "second": {"past": "vteina", "future": "vteina", "zero": "vteina"},
        "seconds": {"past": "{0} sekundami", "future": ["{0} sekundy", "{0} sekund"]},
        "minute": {"past": "minutou", "future": "minutu", "zero": "{0} minut"},
        "minutes": {"past": "{0} minutami", "future": ["{0} minuty", "{0} minut"]},
        "hour": {"past": "hodinou", "future": "hodinu", "zero": "{0} hodin"},
        "hours": {"past": "{0} hodinami", "future": ["{0} hodiny", "{0} hodin"]},
        "day": {"past": "dnem", "future": "den", "zero": "{0} dn"},
        "days": {"past": "{0} dny", "future": ["{0} dny", "{0} dn"]},
        "month": {"past": "mscem", "future": "msc", "zero": "{0} msc"},
        "months": {"past": "{0} msci", "future": ["{0} msce", "{0} msc"]},
        "year": {"past": "rokem", "future": "rok", "zero": "{0} let"},
        "years": {"past": "{0} lety", "future": ["{0} roky", "{0} let"]},
    }

    past = "Ped {0}"
    future = "Za {0}"

    month_names = [
        "",
        "leden",
        "nor",
        "bezen",
        "duben",
        "kvten",
        "erven",
        "ervenec",
        "srpen",
        "z",
        "jen",
        "listopad",
        "prosinec",
    ]
    month_abbreviations = [
        "",
        "led",
        "no",
        "be",
        "dub",
        "kv",
        "vn",
        "vc",
        "srp",
        "z",
        "j",
        "lis",
        "pro",
    ]

    day_names = [
        "",
        "pondl",
        "ter",
        "steda",
        "tvrtek",
        "ptek",
        "sobota",
        "nedle",
    ]
    day_abbreviations = ["", "po", "t", "st", "t", "p", "so", "ne"]

    def _format_timeframe(self, timeframe, delta):
        """Czech aware time frame format function, takes into account
        the differences between past and future forms."""
        form = self.timeframes[timeframe]
        if isinstance(form, dict):
            if delta == 0:
                form = form["zero"]  # And *never* use 0 in the singular!
            elif delta > 0:
                form = form["future"]
            else:
                form = form["past"]
        delta = abs(delta)

        if isinstance(form, list):
            if 2 <= delta % 10 <= 4 and (delta % 100 < 10 or delta % 100 >= 20):
                form = form[0]
            else:
                form = form[1]

        return form.format(delta)


class SlovakLocale(Locale):
    names = ["sk", "sk_sk"]

    timeframes = {
        "now": "Teraz",
        "second": {"past": "druh", "future": "druh", "zero": "druh"},
        "seconds": {"past": "pr sekundami", "future": ["{0} sekundy", "{0} seknd"]},
        "minute": {"past": "mintou", "future": "mintu", "zero": "{0} mint"},
        "minutes": {"past": "{0} mintami", "future": ["{0} minty", "{0} mint"]},
        "hour": {"past": "hodinou", "future": "hodinu", "zero": "{0} hodn"},
        "hours": {"past": "{0} hodinami", "future": ["{0} hodiny", "{0} hodn"]},
        "day": {"past": "dom", "future": "de", "zero": "{0} dn"},
        "days": {"past": "{0} dami", "future": ["{0} dni", "{0} dn"]},
        "month": {"past": "mesiacom", "future": "mesiac", "zero": "{0} mesiacov"},
        "months": {"past": "{0} mesiacmi", "future": ["{0} mesiace", "{0} mesiacov"]},
        "year": {"past": "rokom", "future": "rok", "zero": "{0} rokov"},
        "years": {"past": "{0} rokmi", "future": ["{0} roky", "{0} rokov"]},
    }

    past = "Pred {0}"
    future = "O {0}"
    and_word = "a"

    month_names = [
        "",
        "janur",
        "februr",
        "marec",
        "aprl",
        "mj",
        "jn",
        "jl",
        "august",
        "september",
        "oktber",
        "november",
        "december",
    ]
    month_abbreviations = [
        "",
        "jan",
        "feb",
        "mar",
        "apr",
        "mj",
        "jn",
        "jl",
        "aug",
        "sep",
        "okt",
        "nov",
        "dec",
    ]

    day_names = [
        "",
        "pondelok",
        "utorok",
        "streda",
        "tvrtok",
        "piatok",
        "sobota",
        "nedea",
    ]
    day_abbreviations = ["", "po", "ut", "st", "t", "pi", "so", "ne"]

    def _format_timeframe(self, timeframe, delta):
        """Slovak aware time frame format function, takes into account
        the differences between past and future forms."""
        form = self.timeframes[timeframe]
        if isinstance(form, dict):
            if delta == 0:
                form = form["zero"]  # And *never* use 0 in the singular!
            elif delta > 0:
                form = form["future"]
            else:
                form = form["past"]
        delta = abs(delta)

        if isinstance(form, list):
            if 2 <= delta % 10 <= 4 and (delta % 100 < 10 or delta % 100 >= 20):
                form = form[0]
            else:
                form = form[1]

        return form.format(delta)


class FarsiLocale(Locale):

    names = ["fa", "fa_ir"]

    past = "{0} "
    future = " {0}"

    timeframes = {
        "now": "",
        "second": " ",
        "seconds": "{0} ",
        "minute": " ",
        "minutes": "{0} ",
        "hour": " ",
        "hours": "{0} ",
        "day": " ",
        "days": "{0} ",
        "month": " ",
        "months": "{0} ",
        "year": " ",
        "years": "{0} ",
    }

    meridians = {
        "am": "  ",
        "pm": "  ",
        "AM": "  ",
        "PM": "  ",
    }

    month_names = [
        "",
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
    ]
    month_abbreviations = [
        "",
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
    ]

    day_names = [
        "",
        " ",
        " ",
        "",
        "",
        "",
        "",
        "",
    ]
    day_abbreviations = ["", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]


class HebrewLocale(Locale):

    names = ["he", "he_IL"]

    past = " {0}"
    future = " {0}"

    timeframes = {
        "now": "",
        "second": "",
        "seconds": "{0} ",
        "minute": "",
        "minutes": "{0} ",
        "hour": "",
        "hours": "{0} ",
        "2-hours": "",
        "day": "",
        "days": "{0} ",
        "2-days": "",
        "month": "",
        "months": "{0} ",
        "2-months": "",
        "year": "",
        "years": "{0} ",
        "2-years": "",
    }

    meridians = {
        "am": '"',
        "pm": '"',
        "AM": " ",
        "PM": " ",
    }

    month_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]

    day_names = ["", "", "", "", "", "", "", ""]
    day_abbreviations = ["", "", "", "", "", "", "", ""]

    def _format_timeframe(self, timeframe, delta):
        """Hebrew couple of <timeframe> aware"""
        couple = "2-{}".format(timeframe)
        if abs(delta) == 2 and couple in self.timeframes:
            return self.timeframes[couple].format(abs(delta))
        else:
            return self.timeframes[timeframe].format(abs(delta))


class MarathiLocale(Locale):

    names = ["mr"]

    past = "{0} "
    future = "{0} "

    timeframes = {
        "now": "",
        "second": " ",
        "seconds": "{0} ",
        "minute": "  ",
        "minutes": "{0}  ",
        "hour": " ",
        "hours": "{0} ",
        "day": " ",
        "days": "{0} ",
        "month": "  ",
        "months": "{0}  ",
        "year": "  ",
        "years": "{0}  ",
    }

    meridians = {"am": "", "pm": "", "AM": "", "PM": ""}

    month_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]

    day_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    day_abbreviations = ["", "", "", "", "", "", "", ""]


def _map_locales():

    locales = {}

    for _, cls in inspect.getmembers(sys.modules[__name__], inspect.isclass):
        if issubclass(cls, Locale):  # pragma: no branch
            for name in cls.names:
                locales[name.lower()] = cls

    return locales


class CatalanLocale(Locale):
    names = ["ca", "ca_es", "ca_ad", "ca_fr", "ca_it"]
    past = "Fa {0}"
    future = "En {0}"
    and_word = "i"

    timeframes = {
        "now": "Ara mateix",
        "second": "un segon",
        "seconds": "{0} segons",
        "minute": "1 minut",
        "minutes": "{0} minuts",
        "hour": "una hora",
        "hours": "{0} hores",
        "day": "un dia",
        "days": "{0} dies",
        "month": "un mes",
        "months": "{0} mesos",
        "year": "un any",
        "years": "{0} anys",
    }

    month_names = [
        "",
        "Gener",
        "Febrer",
        "Mar",
        "Abril",
        "Maig",
        "Juny",
        "Juliol",
        "Agost",
        "Setembre",
        "Octubre",
        "Novembre",
        "Desembre",
    ]
    month_abbreviations = [
        "",
        "Gener",
        "Febrer",
        "Mar",
        "Abril",
        "Maig",
        "Juny",
        "Juliol",
        "Agost",
        "Setembre",
        "Octubre",
        "Novembre",
        "Desembre",
    ]
    day_names = [
        "",
        "Dilluns",
        "Dimarts",
        "Dimecres",
        "Dijous",
        "Divendres",
        "Dissabte",
        "Diumenge",
    ]
    day_abbreviations = [
        "",
        "Dilluns",
        "Dimarts",
        "Dimecres",
        "Dijous",
        "Divendres",
        "Dissabte",
        "Diumenge",
    ]


class BasqueLocale(Locale):
    names = ["eu", "eu_eu"]
    past = "duela {0}"
    future = "{0}"  # I don't know what's the right phrase in Basque for the future.

    timeframes = {
        "now": "Orain",
        "second": "segundo bat",
        "seconds": "{0} segundu",
        "minute": "minutu bat",
        "minutes": "{0} minutu",
        "hour": "ordu bat",
        "hours": "{0} ordu",
        "day": "egun bat",
        "days": "{0} egun",
        "month": "hilabete bat",
        "months": "{0} hilabet",
        "year": "urte bat",
        "years": "{0} urte",
    }

    month_names = [
        "",
        "urtarrilak",
        "otsailak",
        "martxoak",
        "apirilak",
        "maiatzak",
        "ekainak",
        "uztailak",
        "abuztuak",
        "irailak",
        "urriak",
        "azaroak",
        "abenduak",
    ]
    month_abbreviations = [
        "",
        "urt",
        "ots",
        "mar",
        "api",
        "mai",
        "eka",
        "uzt",
        "abu",
        "ira",
        "urr",
        "aza",
        "abe",
    ]
    day_names = [
        "",
        "astelehena",
        "asteartea",
        "asteazkena",
        "osteguna",
        "ostirala",
        "larunbata",
        "igandea",
    ]
    day_abbreviations = ["", "al", "ar", "az", "og", "ol", "lr", "ig"]


class HungarianLocale(Locale):

    names = ["hu", "hu_hu"]

    past = "{0} ezeltt"
    future = "{0} mlva"

    timeframes = {
        "now": "ppen most",
        "second": {"past": "egy msodik", "future": "egy msodik"},
        "seconds": {"past": "{0} msodpercekkel", "future": "{0} pr msodperc"},
        "minute": {"past": "egy perccel", "future": "egy perc"},
        "minutes": {"past": "{0} perccel", "future": "{0} perc"},
        "hour": {"past": "egy rval", "future": "egy ra"},
        "hours": {"past": "{0} rval", "future": "{0} ra"},
        "day": {"past": "egy nappal", "future": "egy nap"},
        "days": {"past": "{0} nappal", "future": "{0} nap"},
        "month": {"past": "egy hnappal", "future": "egy hnap"},
        "months": {"past": "{0} hnappal", "future": "{0} hnap"},
        "year": {"past": "egy vvel", "future": "egy v"},
        "years": {"past": "{0} vvel", "future": "{0} v"},
    }

    month_names = [
        "",
        "janur",
        "februr",
        "mrcius",
        "prilis",
        "mjus",
        "jnius",
        "jlius",
        "augusztus",
        "szeptember",
        "oktber",
        "november",
        "december",
    ]
    month_abbreviations = [
        "",
        "jan",
        "febr",
        "mrc",
        "pr",
        "mj",
        "jn",
        "jl",
        "aug",
        "szept",
        "okt",
        "nov",
        "dec",
    ]

    day_names = [
        "",
        "htf",
        "kedd",
        "szerda",
        "cstrtk",
        "pntek",
        "szombat",
        "vasrnap",
    ]
    day_abbreviations = ["", "ht", "kedd", "szer", "cst", "pnt", "szom", "vas"]

    meridians = {"am": "de", "pm": "du", "AM": "DE", "PM": "DU"}

    def _format_timeframe(self, timeframe, delta):
        form = self.timeframes[timeframe]

        if isinstance(form, dict):
            if delta > 0:
                form = form["future"]
            else:
                form = form["past"]

        return form.format(abs(delta))


class EsperantoLocale(Locale):
    names = ["eo", "eo_xx"]
    past = "anta {0}"
    future = "post {0}"

    timeframes = {
        "now": "nun",
        "second": "sekundo",
        "seconds": "{0} kelkaj sekundoj",
        "minute": "unu minuto",
        "minutes": "{0} minutoj",
        "hour": "un horo",
        "hours": "{0} horoj",
        "day": "unu tago",
        "days": "{0} tagoj",
        "month": "unu monato",
        "months": "{0} monatoj",
        "year": "unu jaro",
        "years": "{0} jaroj",
    }

    month_names = [
        "",
        "januaro",
        "februaro",
        "marto",
        "aprilo",
        "majo",
        "junio",
        "julio",
        "agusto",
        "septembro",
        "oktobro",
        "novembro",
        "decembro",
    ]
    month_abbreviations = [
        "",
        "jan",
        "feb",
        "mar",
        "apr",
        "maj",
        "jun",
        "jul",
        "ag",
        "sep",
        "okt",
        "nov",
        "dec",
    ]

    day_names = [
        "",
        "lundo",
        "mardo",
        "merkredo",
        "ado",
        "vendredo",
        "sabato",
        "dimano",
    ]
    day_abbreviations = ["", "lun", "mar", "mer", "a", "ven", "sab", "dim"]

    meridians = {"am": "atm", "pm": "ptm", "AM": "ATM", "PM": "PTM"}

    ordinal_day_re = r"((?P<value>[1-3]?[0-9](?=a))a)"

    def _ordinal_number(self, n):
        return "{}a".format(n)


class ThaiLocale(Locale):

    names = ["th", "th_th"]

    past = "{0}{1}"
    future = "{1}{0}"

    timeframes = {
        "now": "",
        "second": "",
        "seconds": "{0} ",
        "minute": "1 ",
        "minutes": "{0} ",
        "hour": "1 ",
        "hours": "{0} ",
        "day": "1 ",
        "days": "{0} ",
        "month": "1 ",
        "months": "{0} ",
        "year": "1 ",
        "years": "{0} ",
    }

    month_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
        "..",
    ]

    day_names = ["", "", "", "", "", "", "", ""]
    day_abbreviations = ["", "", "", "", "", "", "", ""]

    meridians = {"am": "am", "pm": "pm", "AM": "AM", "PM": "PM"}

    BE_OFFSET = 543

    def year_full(self, year):
        """Thai always use Buddhist Era (BE) which is CE + 543"""
        year += self.BE_OFFSET
        return "{:04d}".format(year)

    def year_abbreviation(self, year):
        """Thai always use Buddhist Era (BE) which is CE + 543"""
        year += self.BE_OFFSET
        return "{:04d}".format(year)[2:]

    def _format_relative(self, humanized, timeframe, delta):
        """Thai normally doesn't have any space between words"""
        if timeframe == "now":
            return humanized
        space = "" if timeframe == "seconds" else " "
        direction = self.past if delta < 0 else self.future

        return direction.format(humanized, space)


class BengaliLocale(Locale):

    names = ["bn", "bn_bd", "bn_in"]

    past = "{0} "
    future = "{0} "

    timeframes = {
        "now": "",
        "second": " ",
        "seconds": "{0} ",
        "minute": " ",
        "minutes": "{0} ",
        "hour": " ",
        "hours": "{0} ",
        "day": " ",
        "days": "{0} ",
        "month": " ",
        "months": "{0}  ",
        "year": " ",
        "years": "{0} ",
    }

    meridians = {"am": "", "pm": "", "AM": "", "PM": ""}

    month_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]

    day_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    day_abbreviations = ["", "", "", "", "", "", "", ""]

    def _ordinal_number(self, n):
        if n > 10 or n == 0:
            return "{}".format(n)
        if n in [1, 5, 7, 8, 9, 10]:
            return "{}".format(n)
        if n in [2, 3]:
            return "{}".format(n)
        if n == 4:
            return "{}".format(n)
        if n == 6:
            return "{}".format(n)


class RomanshLocale(Locale):

    names = ["rm", "rm_ch"]

    past = "avant {0}"
    future = "en {0}"

    timeframes = {
        "now": "en quest mument",
        "second": "in secunda",
        "seconds": "{0} secundas",
        "minute": "ina minuta",
        "minutes": "{0} minutas",
        "hour": "in'ura",
        "hours": "{0} ura",
        "day": "in di",
        "days": "{0} dis",
        "month": "in mais",
        "months": "{0} mais",
        "year": "in onn",
        "years": "{0} onns",
    }

    month_names = [
        "",
        "schaner",
        "favrer",
        "mars",
        "avrigl",
        "matg",
        "zercladur",
        "fanadur",
        "avust",
        "settember",
        "october",
        "november",
        "december",
    ]

    month_abbreviations = [
        "",
        "schan",
        "fav",
        "mars",
        "avr",
        "matg",
        "zer",
        "fan",
        "avu",
        "set",
        "oct",
        "nov",
        "dec",
    ]

    day_names = [
        "",
        "glindesdi",
        "mardi",
        "mesemna",
        "gievgia",
        "venderdi",
        "sonda",
        "dumengia",
    ]

    day_abbreviations = ["", "gli", "ma", "me", "gie", "ve", "so", "du"]


class RomanianLocale(Locale):
    names = ["ro", "ro_ro"]

    past = "{0} n urm"
    future = "peste {0}"
    and_word = "i"

    timeframes = {
        "now": "acum",
        "second": "o secunda",
        "seconds": "{0} cteva secunde",
        "minute": "un minut",
        "minutes": "{0} minute",
        "hour": "o or",
        "hours": "{0} ore",
        "day": "o zi",
        "days": "{0} zile",
        "month": "o lun",
        "months": "{0} luni",
        "year": "un an",
        "years": "{0} ani",
    }

    month_names = [
        "",
        "ianuarie",
        "februarie",
        "martie",
        "aprilie",
        "mai",
        "iunie",
        "iulie",
        "august",
        "septembrie",
        "octombrie",
        "noiembrie",
        "decembrie",
    ]
    month_abbreviations = [
        "",
        "ian",
        "febr",
        "mart",
        "apr",
        "mai",
        "iun",
        "iul",
        "aug",
        "sept",
        "oct",
        "nov",
        "dec",
    ]

    day_names = [
        "",
        "luni",
        "mari",
        "miercuri",
        "joi",
        "vineri",
        "smbt",
        "duminic",
    ]
    day_abbreviations = ["", "Lun", "Mar", "Mie", "Joi", "Vin", "Sm", "Dum"]


class SlovenianLocale(Locale):
    names = ["sl", "sl_si"]

    past = "pred {0}"
    future = "ez {0}"
    and_word = "in"

    timeframes = {
        "now": "zdaj",
        "second": "sekundo",
        "seconds": "{0} sekund",
        "minute": "minuta",
        "minutes": "{0} minutami",
        "hour": "uro",
        "hours": "{0} ur",
        "day": "dan",
        "days": "{0} dni",
        "month": "mesec",
        "months": "{0} mesecev",
        "year": "leto",
        "years": "{0} let",
    }

    meridians = {"am": "", "pm": "", "AM": "", "PM": ""}

    month_names = [
        "",
        "Januar",
        "Februar",
        "Marec",
        "April",
        "Maj",
        "Junij",
        "Julij",
        "Avgust",
        "September",
        "Oktober",
        "November",
        "December",
    ]

    month_abbreviations = [
        "",
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "Maj",
        "Jun",
        "Jul",
        "Avg",
        "Sep",
        "Okt",
        "Nov",
        "Dec",
    ]

    day_names = [
        "",
        "Ponedeljek",
        "Torek",
        "Sreda",
        "etrtek",
        "Petek",
        "Sobota",
        "Nedelja",
    ]

    day_abbreviations = ["", "Pon", "Tor", "Sre", "et", "Pet", "Sob", "Ned"]


class IndonesianLocale(Locale):

    names = ["id", "id_id"]

    past = "{0} yang lalu"
    future = "dalam {0}"
    and_word = "dan"

    timeframes = {
        "now": "baru saja",
        "second": "1 sebentar",
        "seconds": "{0} detik",
        "minute": "1 menit",
        "minutes": "{0} menit",
        "hour": "1 jam",
        "hours": "{0} jam",
        "day": "1 hari",
        "days": "{0} hari",
        "month": "1 bulan",
        "months": "{0} bulan",
        "year": "1 tahun",
        "years": "{0} tahun",
    }

    meridians = {"am": "", "pm": "", "AM": "", "PM": ""}

    month_names = [
        "",
        "Januari",
        "Februari",
        "Maret",
        "April",
        "Mei",
        "Juni",
        "Juli",
        "Agustus",
        "September",
        "Oktober",
        "November",
        "Desember",
    ]

    month_abbreviations = [
        "",
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "Mei",
        "Jun",
        "Jul",
        "Ags",
        "Sept",
        "Okt",
        "Nov",
        "Des",
    ]

    day_names = ["", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu", "Minggu"]

    day_abbreviations = [
        "",
        "Senin",
        "Selasa",
        "Rabu",
        "Kamis",
        "Jumat",
        "Sabtu",
        "Minggu",
    ]


class NepaliLocale(Locale):
    names = ["ne", "ne_np"]

    past = "{0} "
    future = "{0} "

    timeframes = {
        "now": "",
        "second": " ",
        "seconds": "{0} ",
        "minute": "",
        "minutes": "{0} ",
        "hour": " ",
        "hours": "{0} ",
        "day": " ",
        "days": "{0} ",
        "month": " ",
        "months": "{0} ",
        "year": " ",
        "years": "",
    }

    meridians = {"am": "", "pm": "", "AM": "", "PM": ""}

    month_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]
    month_abbreviations = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]

    day_names = [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
    ]

    day_abbreviations = ["", "", "", "", "", "", "", ""]


class EstonianLocale(Locale):
    names = ["ee", "et"]

    past = "{0} tagasi"
    future = "{0} prast"
    and_word = "ja"

    timeframes = {
        "now": {"past": "just nd", "future": "just nd"},
        "second": {"past": "ks sekund", "future": "he sekundi"},
        "seconds": {"past": "{0} sekundit", "future": "{0} sekundi"},
        "minute": {"past": "ks minut", "future": "he minuti"},
        "minutes": {"past": "{0} minutit", "future": "{0} minuti"},
        "hour": {"past": "tund aega", "future": "tunni aja"},
        "hours": {"past": "{0} tundi", "future": "{0} tunni"},
        "day": {"past": "ks pev", "future": "he peva"},
        "days": {"past": "{0} peva", "future": "{0} peva"},
        "month": {"past": "ks kuu", "future": "he kuu"},
        "months": {"past": "{0} kuud", "future": "{0} kuu"},
        "year": {"past": "ks aasta", "future": "he aasta"},
        "years": {"past": "{0} aastat", "future": "{0} aasta"},
    }

    month_names = [
        "",
        "Jaanuar",
        "Veebruar",
        "Mrts",
        "Aprill",
        "Mai",
        "Juuni",
        "Juuli",
        "August",
        "September",
        "Oktoober",
        "November",
        "Detsember",
    ]
    month_abbreviations = [
        "",
        "Jan",
        "Veb",
        "Mr",
        "Apr",
        "Mai",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Okt",
        "Nov",
        "Dets",
    ]

    day_names = [
        "",
        "Esmaspev",
        "Teisipev",
        "Kolmapev",
        "Neljapev",
        "Reede",
        "Laupev",
        "Phapev",
    ]
    day_abbreviations = ["", "Esm", "Teis", "Kolm", "Nelj", "Re", "Lau", "Ph"]

    def _format_timeframe(self, timeframe, delta):
        form = self.timeframes[timeframe]
        if delta > 0:
            form = form["future"]
        else:
            form = form["past"]
        return form.format(abs(delta))


_locales = _map_locales()
# -*- coding: utf-8 -*-
from __future__ import absolute_import, unicode_literals

import re
from datetime import datetime, timedelta

from dateutil import tz

from arrow import locales
from arrow.constants import MAX_TIMESTAMP, MAX_TIMESTAMP_MS, MAX_TIMESTAMP_US
from arrow.util import iso_to_gregorian

try:
    from functools import lru_cache
except ImportError:  # pragma: no cover
    from backports.functools_lru_cache import lru_cache  # pragma: no cover


class ParserError(ValueError):
    pass


# Allows for ParserErrors to be propagated from _build_datetime()
# when day_of_year errors occur.
# Before this, the ParserErrors were caught by the try/except in
# _parse_multiformat() and the appropriate error message was not
# transmitted to the user.
class ParserMatchError(ParserError):
    pass


class DateTimeParser(object):

    _FORMAT_RE = re.compile(
        r"(YYY?Y?|MM?M?M?|Do|DD?D?D?|d?d?d?d|HH?|hh?|mm?|ss?|S+|ZZ?Z?|a|A|x|X|W)"
    )
    _ESCAPE_RE = re.compile(r"\[[^\[\]]*\]")

    _ONE_OR_TWO_DIGIT_RE = re.compile(r"\d{1,2}")
    _ONE_OR_TWO_OR_THREE_DIGIT_RE = re.compile(r"\d{1,3}")
    _ONE_OR_MORE_DIGIT_RE = re.compile(r"\d+")
    _TWO_DIGIT_RE = re.compile(r"\d{2}")
    _THREE_DIGIT_RE = re.compile(r"\d{3}")
    _FOUR_DIGIT_RE = re.compile(r"\d{4}")
    _TZ_Z_RE = re.compile(r"([\+\-])(\d{2})(?:(\d{2}))?|Z")
    _TZ_ZZ_RE = re.compile(r"([\+\-])(\d{2})(?:\:(\d{2}))?|Z")
    _TZ_NAME_RE = re.compile(r"\w[\w+\-/]+")
    # NOTE: timestamps cannot be parsed from natural language strings (by removing the ^...$) because it will
    # break cases like "15 Jul 2000" and a format list (see issue #447)
    _TIMESTAMP_RE = re.compile(r"^\-?\d+\.?\d+$")
    _TIMESTAMP_EXPANDED_RE = re.compile(r"^\-?\d+$")
    _TIME_RE = re.compile(r"^(\d{2})(?:\:?(\d{2}))?(?:\:?(\d{2}))?(?:([\.\,])(\d+))?$")
    _WEEK_DATE_RE = re.compile(r"(?P<year>\d{4})[\-]?W(?P<week>\d{2})[\-]?(?P<day>\d)?")

    _BASE_INPUT_RE_MAP = {
        "YYYY": _FOUR_DIGIT_RE,
        "YY": _TWO_DIGIT_RE,
        "MM": _TWO_DIGIT_RE,
        "M": _ONE_OR_TWO_DIGIT_RE,
        "DDDD": _THREE_DIGIT_RE,
        "DDD": _ONE_OR_TWO_OR_THREE_DIGIT_RE,
        "DD": _TWO_DIGIT_RE,
        "D": _ONE_OR_TWO_DIGIT_RE,
        "HH": _TWO_DIGIT_RE,
        "H": _ONE_OR_TWO_DIGIT_RE,
        "hh": _TWO_DIGIT_RE,
        "h": _ONE_OR_TWO_DIGIT_RE,
        "mm": _TWO_DIGIT_RE,
        "m": _ONE_OR_TWO_DIGIT_RE,
        "ss": _TWO_DIGIT_RE,
        "s": _ONE_OR_TWO_DIGIT_RE,
        "X": _TIMESTAMP_RE,
        "x": _TIMESTAMP_EXPANDED_RE,
        "ZZZ": _TZ_NAME_RE,
        "ZZ": _TZ_ZZ_RE,
        "Z": _TZ_Z_RE,
        "S": _ONE_OR_MORE_DIGIT_RE,
        "W": _WEEK_DATE_RE,
    }

    SEPARATORS = ["-", "/", "."]

    def __init__(self, locale="en_us", cache_size=0):

        self.locale = locales.get_locale(locale)
        self._input_re_map = self._BASE_INPUT_RE_MAP.copy()
        self._input_re_map.update(
            {
                "MMMM": self._generate_choice_re(
                    self.locale.month_names[1:], re.IGNORECASE
                ),
                "MMM": self._generate_choice_re(
                    self.locale.month_abbreviations[1:], re.IGNORECASE
                ),
                "Do": re.compile(self.locale.ordinal_day_re),
                "dddd": self._generate_choice_re(
                    self.locale.day_names[1:], re.IGNORECASE
                ),
                "ddd": self._generate_choice_re(
                    self.locale.day_abbreviations[1:], re.IGNORECASE
                ),
                "d": re.compile(r"[1-7]"),
                "a": self._generate_choice_re(
                    (self.locale.meridians["am"], self.locale.meridians["pm"])
                ),
                # note: 'A' token accepts both 'am/pm' and 'AM/PM' formats to
                # ensure backwards compatibility of this token
                "A": self._generate_choice_re(self.locale.meridians.values()),
            }
        )
        if cache_size > 0:
            self._generate_pattern_re = lru_cache(maxsize=cache_size)(
                self._generate_pattern_re
            )

    # TODO: since we support more than ISO 8601, we should rename this function
    # IDEA: break into multiple functions
    def parse_iso(self, datetime_string):
        # TODO: add a flag to normalize whitespace (useful in logs, ref issue #421)
        has_space_divider = " " in datetime_string
        has_t_divider = "T" in datetime_string

        num_spaces = datetime_string.count(" ")
        if has_space_divider and num_spaces != 1 or has_t_divider and num_spaces > 0:
            raise ParserError(
                "Expected an ISO 8601-like string, but was given '{}'. Try passing in a format string to resolve this.".format(
                    datetime_string
                )
            )

        has_time = has_space_divider or has_t_divider
        has_tz = False

        # date formats (ISO 8601 and others) to test against
        # NOTE: YYYYMM is omitted to avoid confusion with YYMMDD (no longer part of ISO 8601, but is still often used)
        formats = [
            "YYYY-MM-DD",
            "YYYY-M-DD",
            "YYYY-M-D",
            "YYYY/MM/DD",
            "YYYY/M/DD",
            "YYYY/M/D",
            "YYYY.MM.DD",
            "YYYY.M.DD",
            "YYYY.M.D",
            "YYYYMMDD",
            "YYYY-DDDD",
            "YYYYDDDD",
            "YYYY-MM",
            "YYYY/MM",
            "YYYY.MM",
            "YYYY",
            "W",
        ]

        if has_time:

            if has_space_divider:
                date_string, time_string = datetime_string.split(" ", 1)
            else:
                date_string, time_string = datetime_string.split("T", 1)

            time_parts = re.split(r"[\+\-Z]", time_string, 1, re.IGNORECASE)

            time_components = self._TIME_RE.match(time_parts[0])

            if time_components is None:
                raise ParserError(
                    "Invalid time component provided. Please specify a format or provide a valid time component in the basic or extended ISO 8601 time format."
                )

            (
                hours,
                minutes,
                seconds,
                subseconds_sep,
                subseconds,
            ) = time_components.groups()

            has_tz = len(time_parts) == 2
            has_minutes = minutes is not None
            has_seconds = seconds is not None
            has_subseconds = subseconds is not None

            is_basic_time_format = ":" not in time_parts[0]
            tz_format = "Z"

            # use 'ZZ' token instead since tz offset is present in non-basic format
            if has_tz and ":" in time_parts[1]:
                tz_format = "ZZ"

            time_sep = "" if is_basic_time_format else ":"

            if has_subseconds:
                time_string = "HH{time_sep}mm{time_sep}ss{subseconds_sep}S".format(
                    time_sep=time_sep, subseconds_sep=subseconds_sep
                )
            elif has_seconds:
                time_string = "HH{time_sep}mm{time_sep}ss".format(time_sep=time_sep)
            elif has_minutes:
                time_string = "HH{time_sep}mm".format(time_sep=time_sep)
            else:
                time_string = "HH"

            if has_space_divider:
                formats = ["{} {}".format(f, time_string) for f in formats]
            else:
                formats = ["{}T{}".format(f, time_string) for f in formats]

        if has_time and has_tz:
            # Add "Z" or "ZZ" to the format strings to indicate to
            # _parse_token() that a timezone needs to be parsed
            formats = ["{}{}".format(f, tz_format) for f in formats]

        return self._parse_multiformat(datetime_string, formats)

    def parse(self, datetime_string, fmt):

        if isinstance(fmt, list):
            return self._parse_multiformat(datetime_string, fmt)

        fmt_tokens, fmt_pattern_re = self._generate_pattern_re(fmt)

        match = fmt_pattern_re.search(datetime_string)

        if match is None:
            raise ParserMatchError(
                "Failed to match '{}' when parsing '{}'".format(fmt, datetime_string)
            )

        parts = {}
        for token in fmt_tokens:
            if token == "Do":
                value = match.group("value")
            elif token == "W":
                value = (match.group("year"), match.group("week"), match.group("day"))
            else:
                value = match.group(token)
            self._parse_token(token, value, parts)

        return self._build_datetime(parts)

    def _generate_pattern_re(self, fmt):

        # fmt is a string of tokens like 'YYYY-MM-DD'
        # we construct a new string by replacing each
        # token by its pattern:
        # 'YYYY-MM-DD' -> '(?P<YYYY>\d{4})-(?P<MM>\d{2})-(?P<DD>\d{2})'
        tokens = []
        offset = 0

        # Escape all special RegEx chars
        escaped_fmt = re.escape(fmt)

        # Extract the bracketed expressions to be reinserted later.
        escaped_fmt = re.sub(self._ESCAPE_RE, "#", escaped_fmt)

        # Any number of S is the same as one.
        # TODO: allow users to specify the number of digits to parse
        escaped_fmt = re.sub(r"S+", "S", escaped_fmt)

        escaped_data = re.findall(self._ESCAPE_RE, fmt)

        fmt_pattern = escaped_fmt

        for m in self._FORMAT_RE.finditer(escaped_fmt):
            token = m.group(0)
            try:
                input_re = self._input_re_map[token]
            except KeyError:
                raise ParserError("Unrecognized token '{}'".format(token))
            input_pattern = "(?P<{}>{})".format(token, input_re.pattern)
            tokens.append(token)
            # a pattern doesn't have the same length as the token
            # it replaces! We keep the difference in the offset variable.
            # This works because the string is scanned left-to-right and matches
            # are returned in the order found by finditer.
            fmt_pattern = (
                fmt_pattern[: m.start() + offset]
                + input_pattern
                + fmt_pattern[m.end() + offset :]
            )
            offset += len(input_pattern) - (m.end() - m.start())

        final_fmt_pattern = ""
        split_fmt = fmt_pattern.split(r"\#")

        # Due to the way Python splits, 'split_fmt' will always be longer
        for i in range(len(split_fmt)):
            final_fmt_pattern += split_fmt[i]
            if i < len(escaped_data):
                final_fmt_pattern += escaped_data[i][1:-1]

        # Wrap final_fmt_pattern in a custom word boundary to strictly
        # match the formatting pattern and filter out date and time formats
        # that include junk such as: blah1998-09-12 blah, blah 1998-09-12blah,
        # blah1998-09-12blah. The custom word boundary matches every character
        # that is not a whitespace character to allow for searching for a date
        # and time string in a natural language sentence. Therefore, searching
        # for a string of the form YYYY-MM-DD in "blah 1998-09-12 blah" will
        # work properly.
        # Certain punctuation before or after the target pattern such as
        # "1998-09-12," is permitted. For the full list of valid punctuation,
        # see the documentation.

        starting_word_boundary = (
            r"(?<!\S\S)"  # Don't have two consecutive non-whitespace characters. This ensures that we allow cases like .11.25.2019 but not 1.11.25.2019 (for pattern MM.DD.YYYY)
            r"(?<![^\,\.\;\:\?\!\"\'\`\[\]\{\}\(\)<>\s])"  # This is the list of punctuation that is ok before the pattern (i.e. "It can't not be these characters before the pattern")
            r"(\b|^)"  # The \b is to block cases like 1201912 but allow 201912 for pattern YYYYMM. The ^ was necessary to allow a negative number through i.e. before epoch numbers
        )
        ending_word_boundary = (
            r"(?=[\,\.\;\:\?\!\"\'\`\[\]\{\}\(\)\<\>]?"  # Positive lookahead stating that these punctuation marks can appear after the pattern at most 1 time
            r"(?!\S))"  # Don't allow any non-whitespace character after the punctuation
        )
        bounded_fmt_pattern = r"{}{}{}".format(
            starting_word_boundary, final_fmt_pattern, ending_word_boundary
        )

        return tokens, re.compile(bounded_fmt_pattern, flags=re.IGNORECASE)

    def _parse_token(self, token, value, parts):

        if token == "YYYY":
            parts["year"] = int(value)

        elif token == "YY":
            value = int(value)
            parts["year"] = 1900 + value if value > 68 else 2000 + value

        elif token in ["MMMM", "MMM"]:
            parts["month"] = self.locale.month_number(value.lower())

        elif token in ["MM", "M"]:
            parts["month"] = int(value)

        elif token in ["DDDD", "DDD"]:
            parts["day_of_year"] = int(value)

        elif token in ["DD", "D"]:
            parts["day"] = int(value)

        elif token in ["Do"]:
            parts["day"] = int(value)

        elif token.upper() in ["HH", "H"]:
            parts["hour"] = int(value)

        elif token in ["mm", "m"]:
            parts["minute"] = int(value)

        elif token in ["ss", "s"]:
            parts["second"] = int(value)

        elif token == "S":
            # We have the *most significant* digits of an arbitrary-precision integer.
            # We want the six most significant digits as an integer, rounded.
            # IDEA: add nanosecond support somehow? Need datetime support for it first.
            value = value.ljust(7, str("0"))

            # floating-point (IEEE-754) defaults to half-to-even rounding
            seventh_digit = int(value[6])
            if seventh_digit == 5:
                rounding = int(value[5]) % 2
            elif seventh_digit > 5:
                rounding = 1
            else:
                rounding = 0

            parts["microsecond"] = int(value[:6]) + rounding

        elif token == "X":
            parts["timestamp"] = float(value)

        elif token == "x":
            parts["expanded_timestamp"] = int(value)

        elif token in ["ZZZ", "ZZ", "Z"]:
            parts["tzinfo"] = TzinfoParser.parse(value)

        elif token in ["a", "A"]:
            if value in (self.locale.meridians["am"], self.locale.meridians["AM"]):
                parts["am_pm"] = "am"
            elif value in (self.locale.meridians["pm"], self.locale.meridians["PM"]):
                parts["am_pm"] = "pm"

        elif token == "W":
            parts["weekdate"] = value

    @staticmethod
    def _build_datetime(parts):

        weekdate = parts.get("weekdate")

        if weekdate is not None:
            # we can use strptime (%G, %V, %u) in python 3.6 but these tokens aren't available before that
            year, week = int(weekdate[0]), int(weekdate[1])

            if weekdate[2] is not None:
                day = int(weekdate[2])
            else:
                # day not given, default to 1
                day = 1

            dt = iso_to_gregorian(year, week, day)
            parts["year"] = dt.year
            parts["month"] = dt.month
            parts["day"] = dt.day

        timestamp = parts.get("timestamp")

        if timestamp is not None:
            return datetime.fromtimestamp(timestamp, tz=tz.tzutc())

        expanded_timestamp = parts.get("expanded_timestamp")

        if expanded_timestamp is not None:

            if expanded_timestamp > MAX_TIMESTAMP:
                if expanded_timestamp < MAX_TIMESTAMP_MS:
                    expanded_timestamp /= 1000.0
                elif expanded_timestamp < MAX_TIMESTAMP_US:
                    expanded_timestamp /= 1000000.0
                else:
                    raise ValueError(
                        "The specified timestamp '{}' is too large.".format(
                            expanded_timestamp
                        )
                    )

            return datetime.fromtimestamp(expanded_timestamp, tz=tz.tzutc())

        day_of_year = parts.get("day_of_year")

        if day_of_year is not None:
            year = parts.get("year")
            month = parts.get("month")
            if year is None:
                raise ParserError(
                    "Year component is required with the DDD and DDDD tokens."
                )

            if month is not None:
                raise ParserError(
                    "Month component is not allowed with the DDD and DDDD tokens."
                )

            date_string = "{}-{}".format(year, day_of_year)
            try:
                dt = datetime.strptime(date_string, "%Y-%j")
            except ValueError:
                raise ParserError(
                    "The provided day of year '{}' is invalid.".format(day_of_year)
                )

            parts["year"] = dt.year
            parts["month"] = dt.month
            parts["day"] = dt.day

        am_pm = parts.get("am_pm")
        hour = parts.get("hour", 0)

        if am_pm == "pm" and hour < 12:
            hour += 12
        elif am_pm == "am" and hour == 12:
            hour = 0

        # Support for midnight at the end of day
        if hour == 24:
            if parts.get("minute", 0) != 0:
                raise ParserError("Midnight at the end of day must not contain minutes")
            if parts.get("second", 0) != 0:
                raise ParserError("Midnight at the end of day must not contain seconds")
            if parts.get("microsecond", 0) != 0:
                raise ParserError(
                    "Midnight at the end of day must not contain microseconds"
                )
            hour = 0
            day_increment = 1
        else:
            day_increment = 0

        # account for rounding up to 1000000
        microsecond = parts.get("microsecond", 0)
        if microsecond == 1000000:
            microsecond = 0
            second_increment = 1
        else:
            second_increment = 0

        increment = timedelta(days=day_increment, seconds=second_increment)

        return (
            datetime(
                year=parts.get("year", 1),
                month=parts.get("month", 1),
                day=parts.get("day", 1),
                hour=hour,
                minute=parts.get("minute", 0),
                second=parts.get("second", 0),
                microsecond=microsecond,
                tzinfo=parts.get("tzinfo"),
            )
            + increment
        )

    def _parse_multiformat(self, string, formats):

        _datetime = None

        for fmt in formats:
            try:
                _datetime = self.parse(string, fmt)
                break
            except ParserMatchError:
                pass

        if _datetime is None:
            raise ParserError(
                "Could not match input '{}' to any of the following formats: {}".format(
                    string, ", ".join(formats)
                )
            )

        return _datetime

    # generates a capture group of choices separated by an OR operator
    @staticmethod
    def _generate_choice_re(choices, flags=0):
        return re.compile(r"({})".format("|".join(choices)), flags=flags)


class TzinfoParser(object):
    _TZINFO_RE = re.compile(r"^([\+\-])?(\d{2})(?:\:?(\d{2}))?$")

    @classmethod
    def parse(cls, tzinfo_string):

        tzinfo = None

        if tzinfo_string == "local":
            tzinfo = tz.tzlocal()

        elif tzinfo_string in ["utc", "UTC", "Z"]:
            tzinfo = tz.tzutc()

        else:

            iso_match = cls._TZINFO_RE.match(tzinfo_string)

            if iso_match:
                sign, hours, minutes = iso_match.groups()
                if minutes is None:
                    minutes = 0
                seconds = int(hours) * 3600 + int(minutes) * 60

                if sign == "-":
                    seconds *= -1

                tzinfo = tz.tzoffset(None, seconds)

            else:
                tzinfo = tz.gettz(tzinfo_string)

        if tzinfo is None:
            raise ParserError(
                'Could not parse timezone expression "{}"'.format(tzinfo_string)
            )

        return tzinfo
# -*- coding: utf-8 -*-
from __future__ import absolute_import

import datetime


def total_seconds(td):
    """Get total seconds for timedelta."""
    return td.total_seconds()


def is_timestamp(value):
    """Check if value is a valid timestamp."""
    if isinstance(value, bool):
        return False
    if not (
        isinstance(value, int) or isinstance(value, float) or isinstance(value, str)
    ):
        return False
    try:
        float(value)
        return True
    except ValueError:
        return False


# Credit to https://stackoverflow.com/a/1700069
def iso_to_gregorian(iso_year, iso_week, iso_day):
    """Converts an ISO week date tuple into a datetime object."""

    if not 1 <= iso_week <= 53:
        raise ValueError("ISO Calendar week value must be between 1-53.")

    if not 1 <= iso_day <= 7:
        raise ValueError("ISO Calendar day value must be between 1-7")

    # The first week of the year always contains 4 Jan.
    fourth_jan = datetime.date(iso_year, 1, 4)
    delta = datetime.timedelta(fourth_jan.isoweekday() - 1)
    year_start = fourth_jan - delta
    gregorian = year_start + datetime.timedelta(days=iso_day - 1, weeks=iso_week - 1)

    return gregorian


# Python 2.7 / 3.0+ definitions for isstr function.

try:  # pragma: no cover
    basestring

    def isstr(s):
        return isinstance(s, basestring)  # noqa: F821


except NameError:  # pragma: no cover

    def isstr(s):
        return isinstance(s, str)


__all__ = ["total_seconds", "is_timestamp", "isstr", "iso_to_gregorian"]
__version__ = "0.15.6"
# -*- coding: utf-8 -*-
from ._version import __version__
from .api import get, now, utcnow
from .arrow import Arrow
from .factory import ArrowFactory
from .parser import ParserError
U
    ^                     @   sr   d Z ddlmZ ddlmZ e Zdd Zejj e_ dd Zejj e_ dd	d
Zejj e_ dd Z	ddd
dgZ
dS )z}
Provides the default implementation of :class:`ArrowFactory <arrow.factory.ArrowFactory>`
methods for use as a module API.

    )absolute_importArrowFactoryc                  O   s   t j| |S )z[ Calls the default :class:`ArrowFactory <arrow.factory.ArrowFactory>` ``get`` method.

    )_factoryget)argskwargs r	   JC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-b620trd2\arrow\api.pyr      s    r   c                   C   s   t  S )z^ Calls the default :class:`ArrowFactory <arrow.factory.ArrowFactory>` ``utcnow`` method.

    )r   utcnowr	   r	   r	   r
   r      s    r   Nc                 C   s
   t | S )z[ Calls the default :class:`ArrowFactory <arrow.factory.ArrowFactory>` ``now`` method.

    )r   now)tzr	   r	   r
   r   &   s    r   c                 C   s   t | S )z Returns an :class:`.ArrowFactory` for the specified :class:`Arrow <arrow.arrow.Arrow>`
    or derived type.

    :param type: the type, :class:`Arrow <arrow.arrow.Arrow>` or derived.

    r   )typer	   r	   r
   factory1   s    r   )N)__doc__
__future__r   Zarrow.factoryr   r   r   r   r   r   __all__r	   r	   r	   r
   <module>   s   



U
    ^                     @   s   d Z ddlmZ ddlZddlZddlmZmZ ddlmZ ddl	m
Z
 ddlmZ ddlmZ dd	lmZmZmZmZ G d
d deZeeje_eeje_dS )z_
Provides the :class:`Arrow <arrow.arrow.Arrow>` class, an enhanced ``datetime``
replacement.

    )absolute_importN)datetime	timedeltatzinfo)trunc)tz)relativedelta)	formatterlocalesparserutilc                   @   s  e Zd ZdZejZdddddddgZd	d
 eD ZdZe	dZ
e	dZe	dZe	dZe	dZe	dZdddZedddZedd ZedddZedd ZedddZedd d!Zedd"d#Zedd$d%Zedd'd(Zedd*d+Zd,d- Zd.d/ Zd0d1 Zd2d3 Zd4d5 Z e!d6d7 Z"e"j#d8d7 Z"e!d9d: Ze!d;d< Z$e!d=d> Z%e!d?d@ Z&dAdB Z'dCdD Z(dEdF Z)dGdH Z*edIdJ Z+ddKdLZ,dMdN Z-dOdP Z.ddSdTZ/ddWdXZ0ddZd[Z1d\d] Z2d^d_ Z3d`da Z4dbdc Z5ddde Z6dfdg Z7dhdi Z8djdk Z9dldm Z:dndo Z;dpdq Z<drds Z=dtdu Z>dvdw Z?dxdy Z@dzd{ ZAd|d} ZBd~d ZCdd ZDdd ZEdd ZFdd ZGdd ZHdddZIdd ZJdd ZKdd ZLeMdd ZNedd ZOedd ZPedd ZQdS )Arrowa  An :class:`Arrow <arrow.arrow.Arrow>` object.

    Implements the ``datetime`` interface, behaving as an aware ``datetime`` while implementing
    additional functionality.

    :param year: the calendar year.
    :param month: the calendar month.
    :param day: the calendar day.
    :param hour: (optional) the hour. Defaults to 0.
    :param minute: (optional) the minute, Defaults to 0.
    :param second: (optional) the second, Defaults to 0.
    :param microsecond: (optional) the microsecond. Defaults 0.
    :param tzinfo: (optional) A timezone expression.  Defaults to UTC.

    .. _tz-expr:

    Recognized timezone expressions:

        - A ``tzinfo`` object.
        - A ``str`` describing a timezone, similar to 'US/Pacific', or 'Europe/Berlin'.
        - A ``str`` in ISO 8601 style, as in '+07:00'.
        - A ``str``, one of the following:  'local', 'utc', 'UTC'.

    Usage::

        >>> import arrow
        >>> arrow.Arrow(2013, 5, 5, 12, 30, 45)
        <Arrow [2013-05-05T12:30:45+00:00]>

    yearmonthdayhourminutesecondmicrosecondc                 C   s   g | ]}d  |qS ){}s)format).0a r   LC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-b620trd2\arrow\arrow.py
<listcomp>9   s     zArrow.<listcomp>   <     Q :	 g    DAg    ~~Ar   Nc	           	   	   C   sx   |d krt  }nJt|trFt|drFt|drF|jrFtj|j}nt	
|r\tj|}t||||||||| _d S )NZlocalizezone)dateutil_tztzutc
isinstance	dt_tzinfohasattrr"   r   TzinfoParserparser   isstrr   	_datetime)	selfr   r   r   r   r   r   r   r   r   r   r   __init__B   s.    

       zArrow.__init__c              	   C   s@   |dkrt  }t|}| |j|j|j|j|j|j	|j
|jS )a4  Constructs an :class:`Arrow <arrow.arrow.Arrow>` object, representing "now" in the given
        timezone.

        :param tzinfo: (optional) a ``tzinfo`` object. Defaults to local time.

        Usage::

            >>> arrow.now('Asia/Baku')
            <Arrow [2019-01-24T20:26:31.146412+04:00]>

        N)r#   tzlocalr   nowr   r   r   r   r   r   r   r   )clsr   dtr   r   r   r/   X   s    
z	Arrow.nowc              	   C   s4   t t }| |j|j|j|j|j|j	|j
|jS )z Constructs an :class:`Arrow <arrow.arrow.Arrow>` object, representing "now" in UTC
        time.

        Usage::

            >>> arrow.utcnow()
            <Arrow [2019-01-24T16:31:40.651108+00:00]>

        )r   r/   r#   r$   r   r   r   r   r   r   r   r   )r0   r1   r   r   r   utcnowu   s    zArrow.utcnowc              	   C   sv   |dkrt  }nt|r(tj|}t|s@td	|t
t||}| |j|j|j|j|j|j|j|jS )a0   Constructs an :class:`Arrow <arrow.arrow.Arrow>` object from a timestamp, converted to
        the given timezone.

        :param timestamp: an ``int`` or ``float`` timestamp, or a ``str`` that converts to either.
        :param tzinfo: (optional) a ``tzinfo`` object.  Defaults to local time.
        N'The provided timestamp '{}' is invalid.)r#   r.   r   r*   r   r(   r)   is_timestamp
ValueErrorr   r   fromtimestampfloatr   r   r   r   r   r   r   r   )r0   	timestampr   r1   r   r   r   r6      s&    	


zArrow.fromtimestampc              
   C   sN   t |std|tt|}| |j|j|j	|j
|j|j|jt S )zConstructs an :class:`Arrow <arrow.arrow.Arrow>` object from a timestamp, in UTC time.

        :param timestamp: an ``int`` or ``float`` timestamp, or a ``str`` that converts to either.

        r3   )r   r4   r5   r   r   utcfromtimestampr7   r   r   r   r   r   r   r   r#   r$   )r0   r8   r1   r   r   r   r9      s    
zArrow.utcfromtimestampc              	   C   sF   |dkr"|j dkrt }n|j }| |j|j|j|j|j|j|j	|S )a@   Constructs an :class:`Arrow <arrow.arrow.Arrow>` object from a ``datetime`` and
        optional replacement timezone.

        :param dt: the ``datetime``
        :param tzinfo: (optional) A :ref:`timezone expression <tz-expr>`.  Defaults to ``dt``'s
            timezone, or UTC if naive.

        If you only want to replace the timezone of naive datetimes::

            >>> dt
            datetime.datetime(2013, 5, 5, 0, 0, tzinfo=tzutc())
            >>> arrow.Arrow.fromdatetime(dt, dt.tzinfo or 'US/Pacific')
            <Arrow [2013-05-05T00:00:00+00:00]>

        N)
r   r#   r$   r   r   r   r   r   r   r   )r0   r1   r   r   r   r   fromdatetime   s    

zArrow.fromdatetimec                 C   s&   |dkrt  }| |j|j|j|dS )a   Constructs an :class:`Arrow <arrow.arrow.Arrow>` object from a ``date`` and optional
        replacement timezone.  Time values are set to 0.

        :param date: the ``date``
        :param tzinfo: (optional) A :ref:`timezone expression <tz-expr>`.  Defaults to UTC.
        Nr   )r#   r$   r   r   r   )r0   dater   r   r   r   fromdate   s    	zArrow.fromdatec              	   C   s>   t ||}|dkr|j}| |j|j|j|j|j|j|j	|S )aO   Constructs an :class:`Arrow <arrow.arrow.Arrow>` object from a date string and format,
        in the style of ``datetime.strptime``.  Optionally replaces the parsed timezone.

        :param date_str: the date string.
        :param fmt: the format string.
        :param tzinfo: (optional) A :ref:`timezone expression <tz-expr>`.  Defaults to the parsed
            timezone if ``fmt`` contains a timezone directive, otherwise UTC.

        Usage::

            >>> arrow.Arrow.strptime('20-01-2019 15:49:10', '%d-%m-%Y %H:%M:%S')
            <Arrow [2019-01-20T15:49:10+00:00]>

        N)
r   strptimer   r   r   r   r   r   r   r   )r0   Zdate_strfmtr   r1   r   r   r   r=      s    zArrow.strptimec                 #   s   |  |\}}}| |dkr"|jn|}	| |j|	d}| ||\}}| |j|	d}| | d}
 |kr|
|k r|
d7 }
 V   fdd| jD }| |d|	itf ||i  qjdS )a   Returns an iterator of :class:`Arrow <arrow.arrow.Arrow>` objects, representing
        points in time between two inputs.

        :param frame: The timeframe.  Can be any ``datetime`` property (day, hour, minute...).
        :param start: A datetime expression, the start of the range.
        :param end: (optional) A datetime expression, the end of the range.
        :param tz: (optional) A :ref:`timezone expression <tz-expr>`.  Defaults to
            ``start``'s timezone, or UTC if ``start`` is naive.
        :param limit: (optional) A maximum number of tuples to return.

        **NOTE**: The ``end`` or ``limit`` must be provided.  Call with ``end`` alone to
        return the entire range.  Call with ``limit`` alone to return a maximum # of results from
        the start.  Call with both to cap a range at a maximum # of results.

        **NOTE**: ``tz`` internally **replaces** the timezones of both ``start`` and ``end`` before
        iterating.  As such, either call with naive objects and ``tz``, or aware objects from the
        same timezone and no ``tz``.

        Supported frame values: year, quarter, month, week, day, hour, minute, second.

        Recognized datetime expressions:

            - An :class:`Arrow <arrow.arrow.Arrow>` object.
            - A ``datetime`` object.

        Usage::

            >>> start = datetime(2013, 5, 5, 12, 30)
            >>> end = datetime(2013, 5, 5, 17, 15)
            >>> for r in arrow.Arrow.range('hour', start, end):
            ...     print(repr(r))
            ...
            <Arrow [2013-05-05T12:30:00+00:00]>
            <Arrow [2013-05-05T13:30:00+00:00]>
            <Arrow [2013-05-05T14:30:00+00:00]>
            <Arrow [2013-05-05T15:30:00+00:00]>
            <Arrow [2013-05-05T16:30:00+00:00]>

        **NOTE**: Unlike Python's ``range``, ``end`` *may* be included in the returned iterator::

            >>> start = datetime(2013, 5, 5, 12, 30)
            >>> end = datetime(2013, 5, 5, 13, 30)
            >>> for r in arrow.Arrow.range('hour', start, end):
            ...     print(repr(r))
            ...
            <Arrow [2013-05-05T12:30:00+00:00]>
            <Arrow [2013-05-05T13:30:00+00:00]>

        Nr   r      c                    s   g | ]}t  |qS r   getattrr   fcurrentr   r   r   ^  s     zArrow.range.<locals>.<listcomp>r   )	_get_frames_get_tzinfor   _get_datetimereplace_get_iteration_paramsr:   _ATTRSr	   )r0   framestartendr   limit_frame_relativerelative_stepsr   ivaluesr   rD   r   range  s    4
zArrow.range[)c           	         sT   |  |dkr|jn|}| ||d }| ||||} fdd|D S )aQ
   Returns an iterator of tuples, each :class:`Arrow <arrow.arrow.Arrow>` objects,
        representing a series of timespans between two inputs.

        :param frame: The timeframe.  Can be any ``datetime`` property (day, hour, minute...).
        :param start: A datetime expression, the start of the range.
        :param end: (optional) A datetime expression, the end of the range.
        :param tz: (optional) A :ref:`timezone expression <tz-expr>`.  Defaults to
            ``start``'s timezone, or UTC if ``start`` is naive.
        :param limit: (optional) A maximum number of tuples to return.
        :param bounds: (optional) a ``str`` of either '()', '(]', '[)', or '[]' that specifies
            whether to include or exclude the start and end values in each span in the range. '(' excludes
            the start, '[' includes the start, ')' excludes the end, and ']' includes the end.
            If the bounds are not specified, the default bound '[)' is used.

        **NOTE**: The ``end`` or ``limit`` must be provided.  Call with ``end`` alone to
        return the entire range.  Call with ``limit`` alone to return a maximum # of results from
        the start.  Call with both to cap a range at a maximum # of results.

        **NOTE**: ``tz`` internally **replaces** the timezones of both ``start`` and ``end`` before
        iterating.  As such, either call with naive objects and ``tz``, or aware objects from the
        same timezone and no ``tz``.

        Supported frame values: year, quarter, month, week, day, hour, minute, second.

        Recognized datetime expressions:

            - An :class:`Arrow <arrow.arrow.Arrow>` object.
            - A ``datetime`` object.

        **NOTE**: Unlike Python's ``range``, ``end`` will *always* be included in the returned
        iterator of timespans.

        Usage:

            >>> start = datetime(2013, 5, 5, 12, 30)
            >>> end = datetime(2013, 5, 5, 17, 15)
            >>> for r in arrow.Arrow.span_range('hour', start, end):
            ...     print(r)
            ...
            (<Arrow [2013-05-05T12:00:00+00:00]>, <Arrow [2013-05-05T12:59:59.999999+00:00]>)
            (<Arrow [2013-05-05T13:00:00+00:00]>, <Arrow [2013-05-05T13:59:59.999999+00:00]>)
            (<Arrow [2013-05-05T14:00:00+00:00]>, <Arrow [2013-05-05T14:59:59.999999+00:00]>)
            (<Arrow [2013-05-05T15:00:00+00:00]>, <Arrow [2013-05-05T15:59:59.999999+00:00]>)
            (<Arrow [2013-05-05T16:00:00+00:00]>, <Arrow [2013-05-05T16:59:59.999999+00:00]>)
            (<Arrow [2013-05-05T17:00:00+00:00]>, <Arrow [2013-05-05T17:59:59.999999+00:00]>)

        Nr   c                 3   s   | ]}|j  d V  qdS )boundsNspan)r   rrX   rL   r   r   	<genexpr>  s     z#Arrow.span_range.<locals>.<genexpr>)rG   r   r:   rZ   rU   )	r0   rL   rM   rN   r   rO   rX   r   _ranger   r\   r   
span_rangec  s    2zArrow.span_ranger?   c                 c   s~   |dk rt dt| j|||||d}z8t|\}}	t|d D ]}
t|\}
}	qB||	fV  W q( tk
rv   Y dS X q(dS )a   Returns an iterator of tuples, each :class:`Arrow <arrow.arrow.Arrow>` objects,
        representing a series of intervals between two inputs.

        :param frame: The timeframe.  Can be any ``datetime`` property (day, hour, minute...).
        :param start: A datetime expression, the start of the range.
        :param end: (optional) A datetime expression, the end of the range.
        :param interval: (optional) Time interval for the given time frame.
        :param tz: (optional) A timezone expression.  Defaults to UTC.
        :param bounds: (optional) a ``str`` of either '()', '(]', '[)', or '[]' that specifies
            whether to include or exclude the start and end values in the intervals. '(' excludes
            the start, '[' includes the start, ')' excludes the end, and ']' includes the end.
            If the bounds are not specified, the default bound '[)' is used.

        Supported frame values: year, quarter, month, week, day, hour, minute, second

        Recognized datetime expressions:

            - An :class:`Arrow <arrow.arrow.Arrow>` object.
            - A ``datetime`` object.

        Recognized timezone expressions:

            - A ``tzinfo`` object.
            - A ``str`` describing a timezone, similar to 'US/Pacific', or 'Europe/Berlin'.
            - A ``str`` in ISO 8601 style, as in '+07:00'.
            - A ``str``, one of the following:  'local', 'utc', 'UTC'.

        Usage:

            >>> start = datetime(2013, 5, 5, 12, 30)
            >>> end = datetime(2013, 5, 5, 17, 15)
            >>> for r in arrow.Arrow.interval('hour', start, end, 2):
            ...     print r
            ...
            (<Arrow [2013-05-05T12:00:00+00:00]>, <Arrow [2013-05-05T13:59:59.999999+00:00]>)
            (<Arrow [2013-05-05T14:00:00+00:00]>, <Arrow [2013-05-05T15:59:59.999999+00:00]>)
            (<Arrow [2013-05-05T16:00:00+00:00]>, <Arrow [2013-05-05T17:59:59.999999+00:0]>)
        r?   z%interval has to be a positive integerrW   N)r5   iterr_   nextrU   StopIteration)r0   rL   rM   rN   intervalr   rX   Z	spanRangeZ
intvlStartZintvlEndrP   r   r   r   rc     s    (zArrow.intervalc                 C   s   d | jj|  S )Nz	<{} [{}]>)r   	__class____name____str__r,   r   r   r   __repr__  s    zArrow.__repr__c                 C   s
   | j  S Nr+   	isoformatrg   r   r   r   rf     s    zArrow.__str__c                 C   s   t |dkr| |S t| S )Nr   )lenr   str)r,   Z	formatstrr   r   r   
__format__  s    
zArrow.__format__c                 C   s
   | j  S ri   )r+   __hash__rg   r   r   r   ro     s    zArrow.__hash__c                 C   sd   |dkr|   d S |dkr4t| jd | j d S |dsXt| j|d }|d k	rX|S t| |S )Nweekr?   quarterrP   )	isocalendarintr   _MONTHS_PER_QUARTER
startswithrA   r+   object__getattribute__)r,   namevaluer   r   r   __getattr__  s    
zArrow.__getattr__c                 C   s   | j jS )z Gets the ``tzinfo`` of the :class:`Arrow <arrow.arrow.Arrow>` object.

        Usage::

            >>> arw=arrow.utcnow()
            >>> arw.tzinfo
            tzutc()

        )r+   r   rg   r   r   r   r     s    zArrow.tzinfoc                 C   s   | j j|d| _ dS )zG Sets the ``tzinfo`` of the :class:`Arrow <arrow.arrow.Arrow>` object. r   Nr+   rI   )r,   r   r   r   r   r     s    c                 C   s   | j S )z Returns a datetime representation of the :class:`Arrow <arrow.arrow.Arrow>` object.

        Usage::

            >>> arw=arrow.utcnow()
            >>> arw.datetime
            datetime.datetime(2019, 1, 24, 16, 35, 27, 276649, tzinfo=tzutc())

        )r+   rg   r   r   r   r     s    zArrow.datetimec                 C   s   | j jddS )a`   Returns a naive datetime representation of the :class:`Arrow <arrow.arrow.Arrow>`
        object.

        Usage::

            >>> nairobi = arrow.now('Africa/Nairobi')
            >>> nairobi
            <Arrow [2019-01-23T19:27:12.297999+03:00]>
            >>> nairobi.naive
            datetime.datetime(2019, 1, 23, 19, 27, 12, 297999)

        Nr   r{   rg   r   r   r   naive  s    zArrow.naivec                 C   s   t | j S )z Returns a timestamp representation of the :class:`Arrow <arrow.arrow.Arrow>` object, in
        UTC time.

        Usage::

            >>> arrow.utcnow().timestamp
            1548260567

        )calendartimegmr+   utctimetuplerg   r   r   r   r8   &  s    zArrow.timestampc                 C   s   | j t| jd  S )z Returns a floating-point representation of the :class:`Arrow <arrow.arrow.Arrow>`
        object, in UTC time.

        Usage::

            >>> arrow.utcnow().float_timestamp
            1548260516.830896

        i@B )r8   r7   r   rg   r   r   r   float_timestamp4  s    zArrow.float_timestampc                 C   s   |  | jS )z Returns a new :class:`Arrow <arrow.arrow.Arrow>` object, cloned from the current one.

        Usage:

            >>> arw = arrow.utcnow()
            >>> cloned = arw.clone()

        )r:   r+   rg   r   r   r   cloneD  s    
zArrow.clonec                 K   s   i }|  D ]J\}}|| jkr(|||< q|dkr@td|q|dkrtd|q| jjf |}|d}|dk	r| |}|j|d}| |S )a   Returns a new :class:`Arrow <arrow.arrow.Arrow>` object with attributes updated
        according to inputs.

        Use property names to set their value absolutely::

            >>> import arrow
            >>> arw = arrow.utcnow()
            >>> arw
            <Arrow [2013-05-11T22:27:34.787885+00:00]>
            >>> arw.replace(year=2014, month=6)
            <Arrow [2014-06-11T22:27:34.787885+00:00]>

        You can also replace the timezone without conversion, using a
        :ref:`timezone expression <tz-expr>`::

            >>> arw.replace(tzinfo=tz.tzlocal())
            <Arrow [2013-05-11T22:27:34.787885-07:00]>

        )rp   rq   z$setting absolute {} is not supportedr   zunknown attribute: "{}"Nr   )	itemsrK   AttributeErrorr   r+   rI   getrG   r:   )r,   kwargsZabsolute_kwargskeyry   rE   r   r   r   r   rI   P  s    



zArrow.replacec                 K   s   i }dddg}|  D ]>\}}|| jks0||kr:|||< qtdd| j| q|dd |d  |dd| j 7  < | jt	f | }| 
|S )a   Returns a new :class:`Arrow <arrow.arrow.Arrow>` object with attributes updated
        according to inputs.

        Use pluralized property names to relatively shift their current value:

        >>> import arrow
        >>> arw = arrow.utcnow()
        >>> arw
        <Arrow [2013-05-11T22:27:34.787885+00:00]>
        >>> arw.shift(years=1, months=-1)
        <Arrow [2014-04-11T22:27:34.787885+00:00]>

        Day-of-the-week relative shifting can use either Python's weekday numbers
        (Monday = 0, Tuesday = 1 .. Sunday = 6) or using dateutil.relativedelta's
        day instances (MO, TU .. SU).  When using weekday numbers, the returned
        date will always be greater than or equal to the starting date.

        Using the above code (which is a Saturday) and asking it to shift to Saturday:

        >>> arw.shift(weekday=5)
        <Arrow [2013-05-11T22:27:34.787885+00:00]>

        While asking for a Monday:

        >>> arw.shift(weekday=0)
        <Arrow [2013-05-13T22:27:34.787885+00:00]>

        weeksquartersweekdayzAInvalid shift time frame. Please select one of the following: {}., monthsr   )r   _ATTRS_PLURALr   r   join
setdefaultpoprt   r+   r	   r:   )r,   r   Zrelative_kwargsZadditional_attrsr   ry   rE   r   r   r   shiftz  s     

zArrow.shiftc              
   C   sJ   t |tstj|}| j|}| |j|j	|j
|j|j|j|j|jS )a   Returns a new :class:`Arrow <arrow.arrow.Arrow>` object, converted
        to the target timezone.

        :param tz: A :ref:`timezone expression <tz-expr>`.

        Usage::

            >>> utc = arrow.utcnow()
            >>> utc
            <Arrow [2013-05-09T03:49:12.311072+00:00]>

            >>> utc.to('US/Pacific')
            <Arrow [2013-05-08T20:49:12.311072-07:00]>

            >>> utc.to(tz.tzlocal())
            <Arrow [2013-05-08T20:49:12.311072-07:00]>

            >>> utc.to('-07:00')
            <Arrow [2013-05-08T20:49:12.311072-07:00]>

            >>> utc.to('local')
            <Arrow [2013-05-08T20:49:12.311072-07:00]>

            >>> utc.to('local').to('utc')
            <Arrow [2013-05-09T03:49:12.311072+00:00]>

        )r%   r&   r   r(   r)   r+   
astimezonerd   r   r   r   r   r   r   r   r   )r,   r   r1   r   r   r   to  s    
zArrow.toc                 C   s,   |dkr(|dkr(|dkr(|dkr(t dd S )N()z(]rV   z[]z@Invalid bounds. Please select between "()", "(]", "[)", or "[]".)r   )r0   rX   r   r   r   _validate_bounds  s     zArrow._validate_boundsc                    s6    |  |\}}}|dkr(d}n|dkr6d}n|} j|} jd|d  }	 fdd|	D }
td	t|
 D ]}|
d qz j|
d
 ji}|dkr|t	 
 d  d }n"|dkr|t	 jd d	  d }|t	f ||| i }|d dkr|t	dd7 }|d dkr.|t	dd7 }||fS )a   Returns two new :class:`Arrow <arrow.arrow.Arrow>` objects, representing the timespan
        of the :class:`Arrow <arrow.arrow.Arrow>` object in a given timeframe.

        :param frame: the timeframe.  Can be any ``datetime`` property (day, hour, minute...).
        :param count: (optional) the number of frames to span.
        :param bounds: (optional) a ``str`` of either '()', '(]', '[)', or '[]' that specifies
            whether to include or exclude the start and end values in the span. '(' excludes
            the start, '[' includes the start, ')' excludes the end, and ']' includes the end.
            If the bounds are not specified, the default bound '[)' is used.

        Supported frame values: year, quarter, month, week, day, hour, minute, second.

        Usage::

            >>> arrow.utcnow()
            <Arrow [2013-05-09T03:32:36.186203+00:00]>

            >>> arrow.utcnow().span('hour')
            (<Arrow [2013-05-09T03:00:00+00:00]>, <Arrow [2013-05-09T03:59:59.999999+00:00]>)

            >>> arrow.utcnow().span('day')
            (<Arrow [2013-05-09T00:00:00+00:00]>, <Arrow [2013-05-09T23:59:59.999999+00:00]>)

            >>> arrow.utcnow().span('day', count=2)
            (<Arrow [2013-05-09T00:00:00+00:00]>, <Arrow [2013-05-10T23:59:59.999999+00:00]>)

            >>> arrow.utcnow().span('day', bounds='[]')
            (<Arrow [2013-05-09T00:00:00+00:00]>, <Arrow [2013-05-10T00:00:00+00:00]>)

        rp   r   rq   r   Nr?   c                    s   g | ]}t  |qS r   r@   rB   rg   r   r   r     s     zArrow.span.<locals>.<listcomp>r   r   )days)r   r   ()microseconds))r   rF   rK   indexrU   rl   appendrd   r   r	   
isoweekdayr   )r,   rL   countrX   Zframe_absoluterQ   rR   attrr   framesrT   rP   floorceilr   rg   r   rZ     s.     
z
Arrow.spanc                 C   s   |  |d S )a   Returns a new :class:`Arrow <arrow.arrow.Arrow>` object, representing the "floor"
        of the timespan of the :class:`Arrow <arrow.arrow.Arrow>` object in a given timeframe.
        Equivalent to the first element in the 2-tuple returned by
        :func:`span <arrow.arrow.Arrow.span>`.

        :param frame: the timeframe.  Can be any ``datetime`` property (day, hour, minute...).

        Usage::

            >>> arrow.utcnow().floor('hour')
            <Arrow [2013-05-09T03:00:00+00:00]>
        r   rY   r,   rL   r   r   r   r   (  s    zArrow.floorc                 C   s   |  |d S )a   Returns a new :class:`Arrow <arrow.arrow.Arrow>` object, representing the "ceiling"
        of the timespan of the :class:`Arrow <arrow.arrow.Arrow>` object in a given timeframe.
        Equivalent to the second element in the 2-tuple returned by
        :func:`span <arrow.arrow.Arrow.span>`.

        :param frame: the timeframe.  Can be any ``datetime`` property (day, hour, minute...).

        Usage::

            >>> arrow.utcnow().ceil('hour')
            <Arrow [2013-05-09T03:59:59.999999+00:00]>
        r?   rY   r   r   r   r   r   8  s    z
Arrow.ceilYYYY-MM-DD HH:mm:ssZZen_usc                 C   s   t || j|S )a   Returns a string representation of the :class:`Arrow <arrow.arrow.Arrow>` object,
        formatted according to a format string.

        :param fmt: the format string.

        Usage::

            >>> arrow.utcnow().format('YYYY-MM-DD HH:mm:ss ZZ')
            '2013-05-09 03:56:47 -00:00'

            >>> arrow.utcnow().format('X')
            '1368071882'

            >>> arrow.utcnow().format('MMMM DD, YYYY')
            'May 09, 2013'

            >>> arrow.utcnow().format()
            '2013-05-09 03:56:47 -00:00'

        )r
   ZDateTimeFormatterr   r+   )r,   r>   localer   r   r   r   J  s    zArrow.formatFautoc              
   C   s  |}t |}|dkr:t jt d}|| jj	}n\t
|trL|j}nJt
|tr|j	dkrr|j| jj	d}q|| jj	}ntdt|jt
|trt|dkr|d }ttt| j| }|dk rdnd}	t|}
|
}z|dkr*|
dk r|jd	|d
W S |
dk r4|	| }|jd||d
W S |
dk rP|jd|	|d
W S |
dk r|	tt|d d }|jd||d
W S |
dk r|jd|	|d
W S |
dk r|	tt|d d }|jd||d
W S |
dk r|jd|	|d
W S |
dk r|	tt|d d }|jd||d
W S |
dk r:|jd|	|d
W S |
dk rl|	tt|d  d }|jd!||d
W S |
d"k r|jd#|	|d
W S |
d$k r| jjd% | jj }|jd% |j }|	ttt|| d }|jd&||d
W S |
d'k r|jd(|	|d
W S |	tt|d) d }|jd*||d
W S nt|r8|d+krh|	| }t|dk r|jd	|d
W S n|dkr|	| | j }n|dkr|	| | j }np|dkr|	| | j }nV|dkr|	| | j }n<|d#kr|	| | j  }n"|d(kr|	| | j! }nt"d,t#t|dkr&|d-7 }|j|||d
W S g }d(|krl|	| | j! }|| j!; }|$d(|g d#|kr|	| | j  }|| j ; }|$d#|g d|kr|	| | j }|| j; }|$d|g d|kr|	| | j }|| j; }|$d|g d|kr,|	| | j }|| j; }|$d|g d|kr\|	| | j }|| j; }|$d|g d+|kr||	| }|$d+|g t|t|k rt"d.|D ],}t#t|d dkr|d  d-7  < q|j%||d
W S W n4 t&k
r } zt'd/||W 5 d}~X Y nX dS )0a   Returns a localized, humanized representation of a relative difference in time.

        :param other: (optional) an :class:`Arrow <arrow.arrow.Arrow>` or ``datetime`` object.
            Defaults to now in the current :class:`Arrow <arrow.arrow.Arrow>` object's timezone.
        :param locale: (optional) a ``str`` specifying a locale.  Defaults to 'en_us'.
        :param only_distance: (optional) returns only time difference eg: "11 seconds" without "in" or "ago" part.
        :param granularity: (optional) defines the precision of the output. Set it to strings 'second', 'minute',
                           'hour', 'day', 'week', 'month' or 'year' or a list of any combination of these strings

        Usage::

            >>> earlier = arrow.utcnow().shift(hours=-2)
            >>> earlier.humanize()
            '2 hours ago'

            >>> later = earlier.shift(hours=4)
            >>> later.humanize(earlier)
            'in 4 hours'

        Nr   zYInvalid 'other' argument of type '{}'. Argument must be of type None, Arrow, or datetime.r?   r   r   r   
   r/   )only_distance-   secondsZ   r   i
  r      minutesi  r   i`5 r   hoursi  r   iu r    r   i rp   i $ r!   r   iS; r   i   r   i$r   i3yearsr   zpInvalid level of granularity. Please select between 'second', 'minute', 'hour', 'day', 'week', 'month' or 'year'szqInvalid level of granularity. Please select between 'second', 'minute', 'hour', 'day', 'week', 'month' or 'year'.zHumanization of the {} granularity is not currently translated in the '{}' locale. Please consider making a contribution to this locale.)(r   Z
get_localer   r2   rI   r#   r$   r   r+   r   r%   r   	TypeErrorr   typere   listrl   rs   roundr   total_secondsabsZdescribemaxr   r   r*   _SECS_PER_MINUTE_SECS_PER_HOUR_SECS_PER_DAY_SECS_PER_WEEK_SECS_PER_MONTH_SECS_PER_YEARr   r   r   Zdescribe_multiKeyErrorr5   )r,   otherr   r   ZgranularityZlocale_nameutcr1   deltasignZdiffr   r   r   r   r   Zself_monthsZother_monthsr   r   Z
timeframestfer   r   r   humanizeb  s   






  

  







  




















 zArrow.humanizer   c           	      C   s   |  | t|ts&tdt|t|tsBtdt||d dk}|d dk}| j}|j}|j}|r|r||ko||kS |r|s||ko||k S |s|r||ko||kS ||ko||k S dS )a   Returns a boolean denoting whether the specified date and time is between
        the start and end dates and times.

        :param start: an :class:`Arrow <arrow.arrow.Arrow>` object.
        :param end: an :class:`Arrow <arrow.arrow.Arrow>` object.
        :param bounds: (optional) a ``str`` of either '()', '(]', '[)', or '[]' that specifies
            whether to include or exclude the start and end values in the range. '(' excludes
            the start, '[' includes the start, ')' excludes the end, and ']' includes the end.
            If the bounds are not specified, the default bound '()' is used.

        Usage::

            >>> start = arrow.get(datetime(2013, 5, 5, 12, 30, 10))
            >>> end = arrow.get(datetime(2013, 5, 5, 12, 30, 36))
            >>> arrow.get(datetime(2013, 5, 5, 12, 30, 27)).is_between(start, end)
            True

            >>> start = arrow.get(datetime(2013, 5, 5))
            >>> end = arrow.get(datetime(2013, 5, 8))
            >>> arrow.get(datetime(2013, 5, 8)).is_between(start, end, '[]')
            True

            >>> start = arrow.get(datetime(2013, 5, 5))
            >>> end = arrow.get(datetime(2013, 5, 8))
            >>> arrow.get(datetime(2013, 5, 8)).is_between(start, end, '[)')
            False

        z,Can't parse start date argument type of '{}'z*Can't parse end date argument type of '{}'r   [r?   ]N)r   r%   r   r   r   r   r   )	r,   rM   rN   rX   Zinclude_startZinclude_endZtarget_timestampZstart_timestampZend_timestampr   r   r   
is_between&  s4    


zArrow.is_betweenc                 C   s(   t |ttfr$| | j| | jjS tS ri   )r%   r   r	   r:   r+   r   NotImplementedr,   r   r   r   r   __add__k  s    zArrow.__add__c                 C   s
   |  |S ri   )r   r   r   r   r   __radd__r  s    zArrow.__radd__c                 C   sR   t |ttfr$| | j| | jjS t |tr8| j| S t |trN| j|j S tS ri   )	r%   r   r	   r:   r+   r   r   r   r   r   r   r   r   __sub__u  s    


zArrow.__sub__c                 C   s   t |tr|| j S tS ri   )r%   r   r+   r   r   r   r   r   __rsub__  s    

zArrow.__rsub__c                 C   s"   t |ttfsdS | j| |kS )NF)r%   r   r   r+   rH   r   r   r   r   __eq__  s    zArrow.__eq__c                 C   s   t |ttfsdS | | S )NT)r%   r   r   r   r   r   r   r   __ne__  s    zArrow.__ne__c                 C   s"   t |ttfstS | j| |kS ri   r%   r   r   r   r+   rH   r   r   r   r   __gt__  s    zArrow.__gt__c                 C   s"   t |ttfstS | j| |kS ri   r   r   r   r   r   __ge__  s    zArrow.__ge__c                 C   s"   t |ttfstS | j| |k S ri   r   r   r   r   r   __lt__  s    zArrow.__lt__c                 C   s"   t |ttfstS | j| |kS ri   r   r   r   r   r   __le__  s    zArrow.__le__c                 C   s8   t jd dk r4t|ttfs4tdt| t|d S )Nr   r   zcan't compare '{}' to '{}')sysversion_infor%   r   r   r   r   r   r   r   r   r   __cmp__  s
    zArrow.__cmp__c                 C   s
   | j  S )z Returns a ``date`` object with the same year, month and day.

        Usage::

            >>> arrow.utcnow().date()
            datetime.date(2019, 1, 23)

        )r+   r;   rg   r   r   r   r;     s    
z
Arrow.datec                 C   s
   | j  S )z Returns a ``time`` object with the same hour, minute, second, microsecond.

        Usage::

            >>> arrow.utcnow().time()
            datetime.time(12, 15, 34, 68352)

        )r+   timerg   r   r   r   r     s    
z
Arrow.timec                 C   s
   | j  S )z Returns a ``time`` object with the same hour, minute, second, microsecond and
        tzinfo.

        Usage::

            >>> arrow.utcnow().timetz()
            datetime.time(12, 5, 18, 298893, tzinfo=tzutc())

        )r+   timetzrg   r   r   r   r     s    zArrow.timetzc                 C   s   | j |S )a   Returns a ``datetime`` object, converted to the specified timezone.

        :param tz: a ``tzinfo`` object.

        Usage::

            >>> pacific=arrow.now('US/Pacific')
            >>> nyc=arrow.now('America/New_York').tzinfo
            >>> pacific.astimezone(nyc)
            datetime.datetime(2019, 1, 20, 10, 24, 22, 328172, tzinfo=tzfile('/usr/share/zoneinfo/America/New_York'))

        )r+   r   )r,   r   r   r   r   r     s    zArrow.astimezonec                 C   s
   | j  S )z Returns a ``timedelta`` object representing the whole number of minutes difference from
        UTC time.

        Usage::

            >>> arrow.now('US/Pacific').utcoffset()
            datetime.timedelta(-1, 57600)

        )r+   	utcoffsetrg   r   r   r   r     s    zArrow.utcoffsetc                 C   s
   | j  S )z Returns the daylight savings time adjustment.

        Usage::

            >>> arrow.utcnow().dst()
            datetime.timedelta(0)

        )r+   dstrg   r   r   r   r      s    
z	Arrow.dstc                 C   s
   | j  S )a   Returns a ``time.struct_time``, in the current timezone.

        Usage::

            >>> arrow.utcnow().timetuple()
            time.struct_time(tm_year=2019, tm_mon=1, tm_mday=20, tm_hour=15, tm_min=17, tm_sec=8, tm_wday=6, tm_yday=20, tm_isdst=0)

        )r+   	timetuplerg   r   r   r   r     s    
zArrow.timetuplec                 C   s
   | j  S )z Returns a ``time.struct_time``, in UTC time.

        Usage::

            >>> arrow.utcnow().utctimetuple()
            time.struct_time(tm_year=2019, tm_mon=1, tm_mday=19, tm_hour=21, tm_min=41, tm_sec=7, tm_wday=5, tm_yday=19, tm_isdst=0)

        )r+   r   rg   r   r   r   r     s    
zArrow.utctimetuplec                 C   s
   | j  S )z Returns the proleptic Gregorian ordinal of the date.

        Usage::

            >>> arrow.utcnow().toordinal()
            737078

        )r+   	toordinalrg   r   r   r   r   $  s    
zArrow.toordinalc                 C   s
   | j  S )z Returns the day of the week as an integer (0-6).

        Usage::

            >>> arrow.utcnow().weekday()
            5

        )r+   r   rg   r   r   r   r   0  s    
zArrow.weekdayc                 C   s
   | j  S )z Returns the ISO day of the week as an integer (1-7).

        Usage::

            >>> arrow.utcnow().isoweekday()
            6

        )r+   r   rg   r   r   r   r   <  s    
zArrow.isoweekdayc                 C   s
   | j  S )z Returns a 3-tuple, (ISO year, ISO week number, ISO weekday).

        Usage::

            >>> arrow.utcnow().isocalendar()
            (2019, 3, 6)

        )r+   rr   rg   r   r   r   rr   H  s    
zArrow.isocalendarTc                 C   s   | j |S )zReturns an ISO 8601 formatted representation of the date and time.

        Usage::

            >>> arrow.utcnow().isoformat()
            '2019-01-19T18:30:52.442118+00:00'

        rj   )r,   sepr   r   r   rk   T  s    
zArrow.isoformatc                 C   s
   | j  S )z Returns a ctime formatted representation of the date and time.

        Usage::

            >>> arrow.utcnow().ctime()
            'Sat Jan 19 18:26:50 2019'

        )r+   ctimerg   r   r   r   r   `  s    
zArrow.ctimec                 C   s   | j |S )z Formats in the style of ``datetime.strftime``.

        :param format: the format string.

        Usage::

            >>> arrow.utcnow().strftime('%d-%m-%Y %H:%M:%S')
            '23-01-2019 12:28:17'

        )r+   strftime)r,   r   r   r   r   r   l  s    zArrow.strftimec                 C   s   |   S )zSerializes for the ``for_json`` protocol of simplejson.

        Usage::

            >>> arrow.utcnow().for_json()
            '2019-01-19T18:25:36.760079+00:00'

        )rk   rg   r   r   r   for_jsonz  s    
zArrow.for_jsonc                 C   sV   | d krt  S t| tr| S ztj| W S  tjk
rP   td	| Y nX d S )Nz!'{}' not recognized as a timezone)
r#   r$   r%   r&   r   r(   r)   ZParserErrorr5   r   )Ztz_exprr   r   r   rG     s    
zArrow._get_tzinfoc                 C   sN   t |tr|jS t |tr|S t|r<t|}| |jS td|dS )z/Get datetime object for a specified expression.z/'{}' not recognized as a datetime or timestamp.N)	r%   r   r   r   r4   r7   r9   r5   r   )r0   exprr8   r   r   r   rH     s    


zArrow._get_datetimec                 C   s   || j kr|d|dfS |d dkrJ|d d | j krJ|d d |dfS |dkrVdS |dkrbdS d	d
ddddddddg	}td||d S )Nr   r?   r   r   )rp   r   )rp   r   r?   )rq   r   )rq   r   r   r   zyear(s)zmonth(s)zday(s)zhour(s)z	minute(s)z	second(s)zmicrosecond(s)zweek(s)z
quarter(s)z<range/span over frame {} not supported. Supported frames: {})rK   r   r   r   )r0   rx   	supportedr   r   r   rF     s4    
 zArrow._get_framesc                 C   s@   |d kr"|d krt d| j|fS |d kr4|tjfS ||fS d S )Nz#one of 'end' or 'limit' is required)r5   r   r   maxsize)r0   rN   rO   r   r   r   rJ     s    

zArrow._get_iteration_params)r   r   r   r   N)N)N)N)N)N)NNN)NNrV   )r?   NrV   )r?   rV   )r   r   )Nr   Fr   )r   )r   )Rre   
__module____qualname____doc__r   
resolutionrK   r   rt   r7   r   r   r   r   r   r   r-   classmethodr/   r2   r6   r9   r:   r<   r=   rU   r_   rc   rh   rf   rn   ro   rz   propertyr   setterr|   r8   r   r   rI   r   r   r   rZ   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r;   r   r   r   r   r   r   r   r   r   r   rr   rk   r   r   r   staticmethodrG   rH   rF   rJ   r   r   r   r   r      s            


"!G66





*6-

D
       
 E
E		



r   )r   
__future__r   r}   r   r   r   r   r&   mathr   Zdateutilr   r#   Zdateutil.relativedeltar	   Zarrowr
   r   r   r   rv   r   r:   minr   r   r   r   r   <module>   s.              HU
    ^b                     @   s   d Z e d Ze d ZdS )g CMBi  i@B N)ZMAX_TIMESTAMPZMAX_TIMESTAMP_MSZMAX_TIMESTAMP_US r   r   PC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-b620trd2\arrow\constants.py<module>   s   U
    ^&                     @   s   d Z ddlmZ ddlZddlmZmZ ddlmZ ddlm	Z	 ddl
mZ ddlmZ dd	lmZ dd
lmZmZmZ G dd deZdS )z
Implements the :class:`ArrowFactory <arrow.factory.ArrowFactory>` class,
providing factory methods for common :class:`Arrow <arrow.arrow.Arrow>`
construction scenarios.

    )absolute_importN)datedatetimetzinfo)struct_time)tz)parser)Arrow)is_timestampiso_to_gregorianisstrc                   @   s6   e Zd ZdZefddZdd Zdd Zdd	d
ZdS )ArrowFactoryz A factory for generating :class:`Arrow <arrow.arrow.Arrow>` objects.

    :param type: (optional) the :class:`Arrow <arrow.arrow.Arrow>`-based class to construct from.
        Defaults to :class:`Arrow <arrow.arrow.Arrow>`.

    c                 C   s
   || _ d S )N)type)selfr    r   NC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-b620trd2\arrow\factory.py__init__   s    zArrowFactory.__init__c           
      O   s  t |}|dd}|dd}t |dkr0d}t |dkrH|dkrHd}|dkrt|rptj|}| j|S t	|t
r| j|S | j S |dkr|d }|dkr| j S t|st|r|dkrt }| jj||dS t	|t r| j|jS t	|tr| j|S t	|tr.| j|S t	|t
rF| j|S t|rnt||}| j||S t	|tr| jt|S t	|trt |dkrt| }| j|S td	t|n|d
kr|d |d  }}	t	|tr0t	|	t
st|	r| j||	S tdt|	nt	|trvt	|	t
sRt|	rb| jj||	dS tdt|	nbt|rt|	st	|	trt||d |d }| jj||dS tdt|t|	n| j||S dS )az   Returns an :class:`Arrow <arrow.arrow.Arrow>` object based on flexible inputs.

        :param locale: (optional) a ``str`` specifying a locale for the parser. Defaults to
            'en_us'.
        :param tzinfo: (optional) a :ref:`timezone expression <tz-expr>` or tzinfo object.
            Replaces the timezone unless using an input form that is explicitly UTC or specifies
            the timezone in a positional argument. Defaults to UTC.

        Usage::

            >>> import arrow

        **No inputs** to get current UTC time::

            >>> arrow.get()
            <Arrow [2013-05-08T05:51:43.316458+00:00]>

        **None** to also get current UTC time::

            >>> arrow.get(None)
            <Arrow [2013-05-08T05:51:49.016458+00:00]>

        **One** :class:`Arrow <arrow.arrow.Arrow>` object, to get a copy.

            >>> arw = arrow.utcnow()
            >>> arrow.get(arw)
            <Arrow [2013-10-23T15:21:54.354846+00:00]>

        **One** ``float`` or ``int``, convertible to a floating-point timestamp, to get
        that timestamp in UTC::

            >>> arrow.get(1367992474.293378)
            <Arrow [2013-05-08T05:54:34.293378+00:00]>

            >>> arrow.get(1367992474)
            <Arrow [2013-05-08T05:54:34+00:00]>

        **One** ISO 8601-formatted ``str``, to parse it::

            >>> arrow.get('2013-09-29T01:26:43.830580')
            <Arrow [2013-09-29T01:26:43.830580+00:00]>

        **One** ISO 8601-formatted ``str``, in basic format, to parse it::

            >>> arrow.get('20160413T133656.456289')
            <Arrow [2016-04-13T13:36:56.456289+00:00]>

        **One** ``tzinfo``, to get the current time **converted** to that timezone::

            >>> arrow.get(tz.tzlocal())
            <Arrow [2013-05-07T22:57:28.484717-07:00]>

        **One** naive ``datetime``, to get that datetime in UTC::

            >>> arrow.get(datetime(2013, 5, 5))
            <Arrow [2013-05-05T00:00:00+00:00]>

        **One** aware ``datetime``, to get that datetime::

            >>> arrow.get(datetime(2013, 5, 5, tzinfo=tz.tzlocal()))
            <Arrow [2013-05-05T00:00:00-07:00]>

        **One** naive ``date``, to get that date in UTC::

            >>> arrow.get(date(2013, 5, 5))
            <Arrow [2013-05-05T00:00:00+00:00]>

        **One** time.struct time::

            >>> arrow.get(gmtime(0))
            <Arrow [1970-01-01T00:00:00+00:00]>

        **One** iso calendar ``tuple``, to get that week date in UTC::

            >>> arrow.get((2013, 18, 7))
            <Arrow [2013-05-05T00:00:00+00:00]>

        **Two** arguments, a naive or aware ``datetime``, and a replacement
        :ref:`timezone expression <tz-expr>`::

            >>> arrow.get(datetime(2013, 5, 5), 'US/Pacific')
            <Arrow [2013-05-05T00:00:00-07:00]>

        **Two** arguments, a naive ``date``, and a replacement
        :ref:`timezone expression <tz-expr>`::

            >>> arrow.get(date(2013, 5, 5), 'US/Pacific')
            <Arrow [2013-05-05T00:00:00-07:00]>

        **Two** arguments, both ``str``, to parse the first according to the format of the second::

            >>> arrow.get('2013-05-05 12:30:45 America/Chicago', 'YYYY-MM-DD HH:mm:ss ZZZ')
            <Arrow [2013-05-05T12:30:45-05:00]>

        **Two** arguments, first a ``str`` to parse and second a ``list`` of formats to try::

            >>> arrow.get('2013-05-05 12:30:45', ['MM/DD/YYYY', 'YYYY-MM-DD HH:mm:ss'])
            <Arrow [2013-05-05T12:30:45+00:00]>

        **Three or more** arguments, as for the constructor of a ``datetime``::

            >>> arrow.get(2013, 5, 5, 12, 30, 45)
            <Arrow [2013-05-05T12:30:45+00:00]>

        localeen_usr   N      r   r   z(Can't parse single argument of type '{}'   z3Can't parse two arguments of types 'datetime', '{}'z/Can't parse two arguments of types 'date', '{}'z0Can't parse two arguments of types '{}' and '{}') lenpopgetr   r	   TzinfoParserparser   now
isinstance	dt_tzinfoutcnowr   dateutil_tzZtzutcfromtimestampr
   Zfromdatetimer   r   ZfromdateZDateTimeParserZ	parse_isor   utcfromtimestampcalendartimegmtupler   	TypeErrorformatlist)
r   argskwargsZ	arg_countr   r   argdtZarg_1Zarg_2r   r   r   r   "   s    k





  zArrowFactory.getc                 C   s
   | j  S )zReturns an :class:`Arrow <arrow.arrow.Arrow>` object, representing "now" in UTC time.

        Usage::

            >>> import arrow
            >>> arrow.utcnow()
            <Arrow [2013-05-08T05:19:07.018993+00:00]>
        )r   r!   )r   r   r   r   r!     s    
zArrowFactory.utcnowNc                 C   s4   |dkrt  }nt|ts(tj|}| j|S )ai  Returns an :class:`Arrow <arrow.arrow.Arrow>` object, representing "now" in the given
        timezone.

        :param tz: (optional) A :ref:`timezone expression <tz-expr>`.  Defaults to local time.

        Usage::

            >>> import arrow
            >>> arrow.now()
            <Arrow [2013-05-07T22:19:11.363410-07:00]>

            >>> arrow.now('US/Pacific')
            <Arrow [2013-05-07T22:19:15.251821-07:00]>

            >>> arrow.now('+02:00')
            <Arrow [2013-05-08T07:19:25.618646+02:00]>

            >>> arrow.now('local')
            <Arrow [2013-05-07T22:19:39.130059-07:00]>
        N)	r"   Ztzlocalr   r    r	   r   r   r   r   )r   r   r   r   r   r     s
    

zArrowFactory.now)N)	__name__
__module____qualname____doc__r
   r   r   r!   r   r   r   r   r   r      s    `r   )r2   
__future__r   r%   r   r   r   r    timer   Zdateutilr   r"   Zarrowr	   Zarrow.arrowr
   Z
arrow.utilr   r   r   objectr   r   r   r   r   <module>   s   U
    ^                     @   sP   d dl mZmZ d dlZd dlZd dlmZ d dlm	Z	m
Z
 G dd deZdS )    )absolute_importdivisionN)tz)localesutilc                   @   s0   e Zd ZedZd
ddZdd Zdd Zd	S )DateTimeFormatterzz(\[(?:(?=(?P<literal>[^]]))(?P=literal))*\]|YYY?Y?|MM?M?M?|Do|DD?D?D?|d?dd?d?|HH?|hh?|mm?|ss?|SS?S?S?S?S?|ZZ?Z?|a|A|X|x|W)en_usc                 C   s   t || _d S )N)r   Z
get_localelocale)selfr	    r   PC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-b620trd2\arrow\formatter.py__init__   s    zDateTimeFormatter.__init__c                    s    j  fdd|S )Nc                    s     | dS )Nr   )_format_tokengroup)mclsdtr   r   <lambda>       z*DateTimeFormatter.format.<locals>.<lambda>)
_FORMAT_REsub)r   r   fmtr   r   r   format   s    zDateTimeFormatter.formatc                 C   sD  |r$| dr$|dr$|dd S |dkr:| j|jS |dkrP| j|jS |dkrf| j|jS |dkr|| j|jS |d	krd
	|jS |dkrt
|jS |dkrd	| jS |dkrt
| jS |dkrd
	|jS |dkrt
|jS |dkr| j|jS |dkr(| j| S |dkrB| j| S |dkrXt
| S |dkrnd
	|jS |dkrt
|jS |dkrd
	d|j  k rdk rn n|jnt|jd S |dkrt
d|j  k rdk rn n|jnt|jd S |dkrd
	|jS |dkr.t
|jS |dkrDd
	|jS |dkrXt
|jS |d krvt
d!	t|jS |d"krt
d#	t|jd$ S |d%krt
d&	t|jd' S |d(krt
d	t|jd) S |d*krt
d
	t|jd+ S |d,krt
t|jd- S |d.kr6t
t| S |d/krht| |jd0  }t
t|d0 S |d1krz| S |d2kr |d3krd4nd5}|jd krt n|j}tt |!|d6 }|dkrd7nd8}t|}t"|d6\}}	d9	||||	S |d:kr| j#|j|S |d;kr@|$ \}
}}d<	|
||S d S )=N[]   ZYYYYZYYZMMMMZMMMZMMz{:02d}MZDDDDz{:03d}ZDDDZDDDZDoZddddZddddZHHHhhr         hmmr   sssZSSSSSSz{:06d}ZSSSSSz{:05d}
   ZSSSSz{:04d}d   ZSSSi  ZSSi'  Si Xxi@B ZZZZ)ZZZr.   : <   +-z{}{:02d}{}{:02d})aAWz{}-W{:02d}-{})%
startswithendswithr	   Z	year_fullyearZyear_abbreviation
month_namemonthZmonth_abbreviationr   str	timetupletm_ydaydayZordinal_numberday_name
isoweekdayZday_abbreviationhourabsminutesecondintmicrosecondcalendartimegmutctimetupletznametzinfodateutil_tzZtzutcr   total_seconds	utcoffsetdivmodZmeridianisocalendar)r
   r   tokents	separatorr   Ztotal_minutessignrC   rE   r:   weekr@   r   r   r   r      s    









8
6

















zDateTimeFormatter._format_tokenN)r   )	__name__
__module____qualname__recompiler   r   r   r   r   r   r   r   r      s   
r   )
__future__r   r   rI   r[   Zdateutilr   rN   Zarrowr   r   objectr   r   r   r   r   <module>   s
   U
    ^r                    @   s  d dl mZmZ d dlZd dlZd dlmZ dd Zdd ZG dd	 d	e	Z
G d
d de
ZG dd de
ZG dd de
ZG dd de
ZG dd de
ZG dd de
ZG dd de
ZG dd de
ZG dd de
ZG dd de
ZG dd de
ZG d d! d!e
ZG d"d# d#e
ZG d$d% d%e
ZG d&d' d'eZG d(d) d)eZG d*d+ d+eZG d,d- d-e
ZG d.d/ d/eZG d0d1 d1eZG d2d3 d3eZG d4d5 d5e
Z G d6d7 d7e e
Z!G d8d9 d9e e
Z"G d:d; d;e e
Z#G d<d= d=e
Z$G d>d? d?e
Z%G d@dA dAe
Z&G dBdC dCe&Z'G dDdE dEe
Z(G dFdG dGe
Z)G dHdI dIe
Z*G dJdK dKe
Z+G dLdM dMe
Z,G dNdO dOe,Z-G dPdQ dQe,Z.G dRdS dSe,Z/G dTdU dUe,Z0G dVdW dWe
Z1G dXdY dYe
Z2G dZd[ d[e
Z3G d\d] d]e
Z4G d^d_ d_e
Z5G d`da dae
Z6G dbdc dce
Z7G ddde dee
Z8G dfdg dge
Z9dhdi Z:G djdk dke
Z;G dldm dme
Z<G dndo doe
Z=G dpdq dqe
Z>G drds dse
Z?G dtdu due
Z@G dvdw dwe
ZAG dxdy dye
ZBG dzd{ d{e
ZCG d|d} d}e
ZDG d~d de
ZEG dd de
ZFe: ZGdS )    )absolute_importunicode_literalsN)truncc                 C   s*   t |  }|dkr$td| | S )zReturns an appropriate :class:`Locale <arrow.locales.Locale>`
    corresponding to an inpute locale name.

    :param name: the name of the locale.

    NUnsupported locale '{}')_localesgetlower
ValueErrorformatnameZ
locale_cls r   NC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-b620trd2\arrow\locales.py
get_locale	   s    r   c                 C   s(   t  | }|dkr"td| | S )zReturns an appropriate :class:`Locale <arrow.locales.Locale>`
    corresponding to an locale class name.

    :param name: the name of the locale class.

    Nr   )globalsr   r	   r
   r   r   r   r   get_locale_by_class_name   s    r   c                   @   s   e Zd ZdZg ZddddddddddddddddZdddddZdZdZdZ	g Z
g Zg Zg ZdZdd Zd)ddZd*ddZdd Zdd Zdd Zdd Zdd Zdd Zdd Zdd Zdd  Zd!d" Zd#d$ Zd%d& Zd'd( ZdS )+Localez4 Represents locale-specific data and functionality.  nowsecondsecondsminuteminuteshourhoursdaydaysweekweeksmonthmonthsyearyearsampmAMPMNz(\d+)c                 C   s
   d | _ d S N)_month_name_to_ordinal)selfr   r   r   __init__P   s    zLocale.__init__r   Fc                 C   s"   |  ||}|s| |||}|S (   Describes a delta within a timeframe in plain language.

        :param timeframe: a string representing a timeframe.
        :param delta: a quantity representing a delta in a timeframe.
        :param only_distance: return only distance eg: "11 seconds" without "in" or "ago" keywords
        )_format_timeframe_format_relativer+   	timeframedeltaonly_distance	humanizedr   r   r   describeT   s    zLocale.describec                 C   s   d}t |D ]^\}\}}|| ||7 }|t|d krR| jrR|d| j d 7 }q|t|d k r|d7 }q|s~| |||}|S )a   Describes a delta within multiple timeframes in plain language.

        :param timeframes: a list of string, quantity pairs each representing a timeframe and delta.
        :param only_distance: return only distance eg: "2 hours and 11 seconds" without "in" or "ago" keywords
        r          )	enumerater/   lenand_wordr0   )r+   
timeframesr4   r5   indexr2   r3   r   r   r   describe_multib   s    
zLocale.describe_multic                 C   s
   | j | S )zx Returns the day name for a specified day of the week.

        :param day: the ``int`` day of the week (1-7).

        )	day_namesr+   r   r   r   r   day_namev   s    zLocale.day_namec                 C   s
   | j | S )z Returns the day abbreviation for a specified day of the week.

        :param day: the ``int`` day of the week (1-7).

        )day_abbreviationsrA   r   r   r   day_abbreviation   s    zLocale.day_abbreviationc                 C   s
   | j | S )z Returns the month name for a specified month of the year.

        :param month: the ``int`` month of the year (1-12).

        )month_namesr+   r    r   r   r   
month_name   s    zLocale.month_namec                 C   s
   | j | S )z Returns the month abbreviation for a specified month of the year.

        :param month: the ``int`` month of the year (1-12).

        )month_abbreviationsrF   r   r   r   month_abbreviation   s    zLocale.month_abbreviationc                 C   s8   | j dkr,| | j| _ | j | | j | j |S )z Returns the month number for a month specified by name or abbreviation.

        :param name: the month name or abbreviation.

        N)r*   _name_to_ordinalrE   updaterH   r   )r+   r   r   r   r   month_number   s    

zLocale.month_numberc                 C   s
   d |S )zm  Returns the year for specific locale if available

        :param name: the ``int`` year (4-digit)
        {:04d}r
   r+   r"   r   r   r   	year_full   s    zLocale.year_fullc                 C   s   d |dd S )zl Returns the year for specific locale if available

        :param name: the ``int`` year (4-digit)
        rM   r7   NrN   rO   r   r   r   year_abbreviation   s    zLocale.year_abbreviationc                 C   sL   |dkr$|dk r| j d S | j d S |dkrH|dk r>| j d S | j d S dS )	z Returns the meridian indicator for a specified hour and format token.

        :param hour: the ``int`` hour of the day.
        :param token: the format token.
        a   r%   r&   Ar'   r(   N)	meridians)r+   r   tokenr   r   r   meridian   s    zLocale.meridianc                 C   s
   |  |S )zU Returns the ordinal format of a given integer

        :param n: an integer
        )_ordinal_numberr+   nr   r   r   ordinal_number   s    zLocale.ordinal_numberc                 C   s
   d |S )Nz{}rN   rY   r   r   r   rX      s    zLocale._ordinal_numberc                 C   s   t tdd t|dd  S )Nc                 S   s   | d   | d d fS )Nr9   r   )r   )ir   r   r   <lambda>       z)Locale._name_to_ordinal.<locals>.<lambda>r9   )dictmapr:   )r+   lstr   r   r   rJ      s    zLocale._name_to_ordinalc                 C   s   | j | tt|S r)   )r=   r
   r   absr+   r2   r3   r   r   r   r/      s    zLocale._format_timeframec                 C   s*   |dkr|S |dk r| j n| j}||S )Nr   r   pastfuturer
   )r+   r5   r2   r3   	directionr   r   r   r0      s    zLocale._format_relative)r   F)F)__name__
__module____qualname____doc__namesr=   rU   re   rf   r<   rE   rH   r@   rC   ordinal_day_rer,   r6   r?   rB   rD   rG   rI   rL   rP   rQ   rW   r[   rX   rJ   r/   r0   r   r   r   r   r   +   sV   

				r   c                       s   e Zd Zddddddddd	g	Zd
ZdZdZddddddddddddddddZdddd d!Zd"d#d$d%d&d'd(d)d*d+d,d-d.gZ	d"d/d0d1d2d'd3d4d5d6d7d8d9gZ
d"d:d;d<d=d>d?d@gZd"dAdBdCdDdEdFdGgZdHZdIdJ ZdO fdMdN	Z  ZS )PEnglishLocaleenen_usen_gben_auen_beZen_jpen_zaen_caen_phz{0} agoin {0}andzjust nowza secondz{0} secondsza minute{0} minuteszan hourz	{0} hoursza dayz{0} daysza weekz	{0} weeksza monthz
{0} monthsza yearz	{0} yearsr   r%   r&   r'   r(   r$   r   JanuaryFebruaryMarchAprilMayJuneJulyAugust	SeptemberOctoberNovemberDecemberJanFebMarAprJunJulAugSepOctNovDecZMondayZTuesdayZ	WednesdayZThursdayZFridayZSaturdayZSundayMonTueWedThuFriSatSunzc((?P<value>[2-3]?1(?=st)|[2-3]?2(?=nd)|[2-3]?3(?=rd)|[1-3]?[04-9](?=th)|1[1-3](?=th))(st|nd|rd|th))c                 C   sX   |d dkrNt |d }|dkr*d|S |dkr<d|S |dkrNd	|S d
|S )Nd   )   rS      
   r9   z{}str7   z{}nd   z{}rdz{}thrb   r
   )r+   rZ   	remainderr   r   r   rX   3  s    


zEnglishLocale._ordinal_numberr   Fc                    s(   t t| |||}|r$|dkr$d}|S )r.   r   Z	instantly)superrn   r6   r1   	__class__r   r   r6   >  s    zEnglishLocale.describe)r   F)rh   ri   rj   rl   re   rf   r<   r=   rU   rE   rH   r@   rC   rm   rX   r6   __classcell__r   r   r   r   rn      s   
rn   c                   @   s   e Zd ZddgZdZdZdZdddd	d
dddddddddddZddddddddddd d!d"gZdd#d$d%d&d'd(d)d*d+d,d-d.gZ	dd/d0d1d2d3d4d5gZ
dd6d%d7d8d9d:d;gZd<Zd=d> Zd?S )@ItalianLocaleitit_itz{0} faztra {0}eZadessoz
un secondoz{0} qualche secondo	un minuto
{0} minutizun'ora{0} orez	un giornoz
{0} giornizuna settimana,z{0} settimanezun mesez{0} mesizun annoz{0} annir   r   ZgennaioZfebbraiomarzoZaprileZmaggioZgiugnoZluglioagostoZ	settembreZottobrenovembreZdicembregenfebmaraprZmagZgiuZlugagosetZottnovdicu   lunedu   martedu
   mercoledu   giovedu   venerdsabatoZdomenicalunmerZgiovensabdom(   ((?P<value>[1-3]?[0-9](?=[]))[])c                 C   s
   d |S Nu   {}rN   rY   r   r   r   rX     s    zItalianLocale._ordinal_numberNrh   ri   rj   rl   re   rf   r<   r=   rE   rH   r@   rC   rm   rX   r   r   r   r   r   M  sx   
r   c                   @   s   e Zd ZddgZdZdZdZdddd	d
dddddddddddZdddddZdddddd d!d"d#d$d%d&d'gZ	dd(d)d*d+d,d-d.d/d0d1d2d3gZ
dd4d5d6d7d8d9d:gZdd;d*d<d=d>d?d@gZdAZdBdC ZdDS )ESpanishLocaleeses_eszhace {0}en {0}yZahoraz
un segundo{0} segundosr   {0} minutosuna hora	{0} horasu   un dau	   {0} dasz
una semana{0} semanasun mes	{0} mesesu   un aou	   {0} aosr   r%   r&   r'   r(   r$   r   ZeneroZfebreror   abrilZmayojuniojulior   Z
septiembreZoctubreZ	noviembreZ	diciembreZener   r   abrmayjunjulr   sepoctr   r   ZlunesZmartesu
   mircolesZjuevesZviernes   sbadodomingor   ZmieZjueZvier   r   r   c                 C   s
   d |S r   rN   rY   r   r   r   rX     s    zSpanishLocale._ordinal_numberN)rh   ri   rj   rl   re   rf   r<   r=   rU   rE   rH   r@   rC   rm   rX   r   r   r   r   r     sz   
r   c                   @   s   e Zd ZddgZdZdZdZdddd	d
dddddddddddZddddddddddd d!d"gZdd#d$dd%ddd&dd'd(d)d*gZ	dd+d,d-d.d/d0d1gZ
dd2d3d4d5d6d7d8gZd9Zd:d; Zd<S )=FrenchLocalefrfr_frz
il y a {0}zdans {0}etZ
maintenantzune secondez{0} quelques secondesz
une minutery   z	une heurez
{0} heureszun jourz	{0} jourszune semainez{0} semaineszun moisz{0} moisun anz{0} ansr   r   Zjanvieru   fvriermarsZavrilmaiZjuinZjuilletu   aotZ	septembreZoctobrer   u	   dcembreZjanvu   fvravrZjuilseptr   r   u   dcZlundimardiZmercrediZjeudiZvendrediZsamediZdimancher   r   r   Zjeur   ZsamdimzB((?P<value>\b1(?=er\b)|[1-3]?[02-9](?=e\b)|[1-3]1(?=e\b))(er|e)\b)c                 C   s    t |dkrd|S d|S )Nr9   z{}erz{}er   rY   r   r   r   rX   (  s    
zFrenchLocale._ordinal_numberNr   r   r   r   r   r     sz   
r   c                   @   s   e Zd ZddgZdZdZdZdddd	d
dddddddddZddddddddddddd gZdd!d"d#d$d%d&d'd(d)d*d+d,gZ	dd-d.d/d0d1d2d3gZ
dd4d5d6d7d8d9d:gZd;S )<GreekLocaleelel_gru   {0} u    {0}u   u   u    u   {0} u    u   {0} u    u   {0} u    u   {0} u    u   {0} u    u   {0} r   r   r   r   r   r   r   r   r   r    r!   r"   r#   r   u   u   u   u   u
   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u
   u   u   u   u   u   u   u   u   u   u   u   u   Nrh   ri   rj   rl   re   rf   r<   r=   rE   rH   r@   rC   r   r   r   r   r   .  sp   
r   c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddddZdddddddddddd d!gZdd"d#d$d%d&d'd(d)d*d+d,d-gZdd.d/d0d1d2d3d4gZ	dd5d6d7d8d9d:d;gZ
d<S )=JapaneseLocalejaja_jp   {0}   {0}u   u   u	   {0}u   1u   {0}u   1u	   {0}u   1u   {0}u   1u	   {0}u   1u	   {0}   1   {0}r   r      1   2   3   4   5   6   7   8   9   10   11   12 1 2 3 4 5 6 7 8 9101112u	   u	   u	   u	   u	   u	   u	   u   u   u   u   u   u      Nrh   ri   rj   rl   re   rf   r=   rE   rH   r@   rC   r   r   r   r   r   r  sb   r   c                   @   s   e Zd ZddgZdZdZdZdddd	d
dddddddddZddddddddddddd gZdd!d"d#d$dd%d&d'd(d)d*d+gZ	dd,d-d.d/d0d1d2gZ
dd3d4d5d6d7d8d9gZd:S );SwedishLocalesvsv_seu   fr {0} senom {0}Zochzjust nuz	en sekundu   {0} ngra sekunderzen minutz{0} minuterzen timmez
{0} timmaren dag	{0} dagar	   en mnad   {0} mnader   ett r   {0} rr   r   januarifebruarir   aprilmajjunijuliZaugusti	septemberoktobernovemberdecemberjanr   r   r   r   r   augr   oktr   dec   mndagZtisdagonsdagtorsdagfredagu   lrdagu   sndagu   mnZtisonstorfreu   lru   snNr   r   r   r   r   r    sp   
r  c                   @   s   e Zd ZddgZdZdZddgddgddgd	d
gddgddgddgddgddgddgddgddgddgdZdddd d!d"d#d$d%d&d'd(d)gZdd*d+d,d-d.d/d0d1d2d3d4d5gZdd6d7d8d9d:d;d<gZ	dd=d>d?d@dAdBdCgZ
dDdE ZdFdG ZdHdI ZdJS )KFinnishLocalefifi_fiz
{0} sittenz{0} kuluttuaz	juuri nytZsekuntiz{0} muutama sekuntiz{0} muutaman sekunninZminuuttiZminuutinz{0} minuuttiaz{0} minuutinZtuntiZtunninz
{0} tuntiaz
{0} tunninu   pivu   {0} pivu   {0} pivnZkuukausiZ	kuukaudenz{0} kuukauttaz{0} kuukaudenZvuosiZvuodenz
{0} vuottaz
{0} vuodenr   r   ZtammikuuZhelmikuuZ	maaliskuuZhuhtikuuZtoukokuuu   keskuuu	   heinkuuZelokuuZsyyskuuZlokakuuZ	marraskuuZjoulukuuZtammiZhelmiZmaalisZhuhtiZtoukou   kesu   heinZeloZsyysZlokaZmarrasZjouluZ	maanantaiZtiistaiZkeskiviikkoZtorstaiZ	perjantaiZlauantaiZ	sunnuntaimatiZketopelasuc                 C   s0   | j | d t|| j | d t|fS Nr   r9   r=   r
   rb   rc   r   r   r   r/   :  s    zFinnishLocale._format_timeframec                 C   sB   |dkr|d S |dk r| j n| j}|dk r0dnd}||| S )Nr   r   r9   rd   )r+   r5   r2   r3   rg   whichr   r   r   r0   @  s
    zFinnishLocale._format_relativec                 C   s
   d |S Nz{}.rN   rY   r   r   r   rX   I  s    zFinnishLocale._ordinal_numberN)rh   ri   rj   rl   re   rf   r=   rE   rH   r@   rC   r/   r0   rX   r   r   r   r   r%    st   	r%  c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddddZdddddddddddd d!gZdd"d#d$d%d&d'd(d)d*d+d,d-gZdd.d/d0d1d2d3d4gZ	dd5d6d7d8d9d:d;gZ
d<S )=ChineseCNLocalezhzh_cnr   u   {0}u   u      {0}u   1u	   {0}u   1u	   {0}   1   {0}u   u   {0}u   1u	   {0}r   r   r   r   u   u   u   u   u   u   u   u   u   u   u	   u	   r   r   r   r   r   r   r   r   r   r  r  r  	   	   	   	   	   	   	                     r  Nr  r   r   r   r   r2  M  sb   r2  c                   @   s   e Zd ZdgZdZdZdZddddd	d
ddddddddddZdddddddddddd d!gZdd"d#d$d%d&d'd(d)d*d+d,d-gZ	dd.d/d0d1d2d3d4gZ
dd5d6d7d8d9d:d;gZd<S )=ChineseTWLocalezh_twr   r   u         1r5     1	   {0}   1	   {0}r6  r7  u   1u   {0}   1	   {0}r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r  r  r  u   u   u   u   u   u   u   r?  r@  rA  rB  rC  rD  r  Nr   r   r   r   r   rE    sd   rE  c                   @   s   e Zd ZdgZdZdZdddddd	d
dddddddddZddddddddddddd gZdd!d"d#d$d%d&d'd(d)d*d+d,gZdd-d.d/d0d1d2d3gZ	dd4d5d6d7d8d9d:gZ
d;S )<HongKongLocalezh_hkr   r   rG  rH  r5  rI  rJ  rK  rL  r6  r7  u   1u	   {0}rM  rN  r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r  r  r  r8  r9  r:  r;  r<  r=  r>  r?  r@  rA  rB  rC  rD  r  Nr  r   r   r   r   rO    sb   rO  c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddZdddddddddddddgZdd d!d"d#d$d%d&d'd(d)d*d+gZdd,d-d.d/d0d1d2gZ	dd3d4d5d6d7d8d9gZ
d:S );KoreanLocalekoko_kru   {0} u   {0} u   u
    u
   {0} u   1u   {0}u   1u	   {0}u   1u   {0}u   1u	   {0}u   1u   {0}r   r   u   1u   2u   3u   4u   5u   6u   7u   8u   9u   10u   11u   12r   r   r   r   r   r   r   r   r   r  r  r  u	   u	   u	   u	   u	   u	   u	   u   u   u   u   u   u   u   Nr  r   r   r   r   rQ    s^   rQ  c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddddZdddddddddddd d!gZdd"d#d$d%dd&d'd(d)d*d+d,gZdd-d.d/d0d1d2d3gZ	dd4d5d6d7d8d9d:gZ
d;S )<DutchLocalenlnl_nlz{0} geledenzover {0}nuzeen secondez{0} secondenz
een minuutz{0} minutenzeen uurz{0} uureen dagz	{0} dagenzeen weekz	{0} weken	een maandz{0} maandeneen jaar{0} jaarr   r   r  r  Zmaartr  Zmeir  r  Zaugustusr  r  r  r  r  r   Zmrtr   r   r   r  r   r  r   r  ZmaandagZdinsdagZwoensdagZ	donderdagZvrijdagZzaterdagZzondagr(  ZdiZwoZdoZvrZzaZzoNr  r   r   r   r   rT  =  sr   
rT  c                   @   s   e Zd Zdd ZdS )SlavicBaseLocalec                 C   s   | j | }t|}t|tr|d dkr>|d dkr>|d }nFd|d   krVdkr|n n"|d dk sr|d dkr||d }n|d }||S )	Nr   r9   r   r   r   r7         )r=   rb   
isinstancelistr
   r+   r2   r3   formr   r   r   r/     s    


4
z"SlavicBaseLocale._format_timeframeN)rh   ri   rj   r/   r   r   r   r   r\    s   r\  c                   @   s   e Zd ZddgZdZdZddddd	d
dgddddgddddgddddgddddgdZdddd d!d"d#d$d%d&d'd(d)gZdd*d+d,d-d.d/d0d1d2d3d4d5gZdd6d7d8d9d:d;d<gZ	dd=d>d?d@dAdBdCgZ
dDS )EBelarusianLocalebebe_byu   {0} u    {0}
   u   u!   {0}  u   u   {0} u   {0} u   {0} u   u   {0} u   {0} u   {0} u
   u   {0} 
   {0} u   {0} 
      {0} u   {0} u   {0}    
   {0} u   {0} u   {0} r   r   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u      u   u   u      u   u   u   u   u   u   u   u      u      u      u            Nr  r   r   r   r   rc    sn   
rc  c                   @   s   e Zd ZddgZdZdZdddddgd	d
dd
gddddgddddddgddddgddddgdZdddddd d!d"d#d$d%d&d'gZdd(d)d*d+d d,d-d.d/d0d1d2gZdd3d4d5d6d7d8d9gZ	dd:d;d<d=d>d?d@gZ
dAS )BPolishLocaleplpl_plz{0} temuzza {0}Zterazu   sekund
{0} sekund{0} sekundyu   minut	{0} minut
{0} minutyu   godzinz
{0} godzinz{0} godzinyu   dzie{0} dniu   tydziez{0} tygodniz{0} tygodnieu   miesicu   {0} miesicyu   {0} miesicerokz{0} latz{0} latar   r   u   styczeZlutyZmarzecu	   kwiecier  ZczerwiecZlipiecu	   sierpieu	   wrzesieu   padzierniklistopadu	   grudzieZstyZlutr   ZkwiZczeZlipZsieZwrzu   palisZgruu   poniedziaekZwtoreku   rodaZczwarteku   piteksobotaZ	niedzielaZPnZWtu   rZCzwZPtSoZNdNr  r   r   r   r   ru    sr   
ru  c                   @   s   e Zd ZddgZdZdZddddd	d
dgddddgddddgddddgddddgddddgd Zd!d"d#d$d%d&d'd(d)d*d+d,d-gZd!d.d/d0d1d2d3d4d5d6d7d8d9gZd!d:d;d<d=d>d?d@gZ	d!dAdBdCdDdEdFdGgZ
dHS )IRussianLocaleruru_ru   {0} u    {0}u   u   u#   {0}  u   u   {0} u   {0} u   {0}    
   {0}    {0} u   {0}       {0} u
   {0} u   {0} u   u   {0} u   {0} u   {0} rh  ri  u   {0} u   {0} rj  rk  u   {0} u
   {0} r   r   u   u   u
   u   u   u   u   u   u   u   u   u   u   u   u         u   u      u      u      u      u
   u   u   u   u   rp     rq     rr  rs  u   Nr  r   r   r   r   r     sr   
r  c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddZdddddddddddddgZdd d!d"d#dd$d%d&d'd(d)d*gZdd+d,d-d.d/d0d1gZ	dd2d3d4d5d6d7d8gZ
d9S ):AfrikaansLocaleafZaf_nlz
{0} gelederw   Znouz	n sekondez{0} sekondesZminuut
{0} minuteZuurz{0} urerX  z{0} daerY  z
{0} maanderZ  r[  r   r   ZJanuarieZ	FebruarieZMaartr}   MeiZJunieZJulieZAugustusr   Oktoberr   Desemberr   r   ZMrtr   r   r   r   r   Oktr   DesZMaandagZDinsdagZWoensdagZ	DonderdagZVrydagZSaterdagZSondagZMaDiZWoDoZVrZZar  Nr  r   r   r   r   r  e  sn   
r  c                   @   s   e Zd ZddgZdZdZddddd	d
d
gddddgddddgddddgddddgdZddddddddd d!d"d#d$gZdd%d&dd'dddd(d)d*d+d,gZdd-d.d/d0d1d2d3gZ	dd4d5d6d7d8d9d:gZ
d;S )<BulgarianLocalebgbg_BGr  u    {0}      u!   {0}  u      {0}    {0} r  r  r  u   
   {0} u
   {0} u
      {0} u   {0} u      {0}    {0} r   r   u   u   u   u
   r  u   u   u   u   u   u   u   u   u   r  r  u   r  u   r  u   r  u
   u   u
   u   u   u   r  rq  u   u   u   u   Nr  r   r   r   r   r    sn   
r  c                   @   s   e Zd ZddgZdZdZddddd	d
dgddddgddddgddddgddddgdZdddd d!d"d#d$d%d&d'd(d)gZdd*d+d,d-d.d/d0d1d2d3d4d5gZdd6d7d8d9d:d;d<gZ	dd=d>d?d@dAdBdCgZ
dDS )EUkrainianLocaleZuauk_uau   {0}     {0}rf  r  u   {0}  u   u   {0} u   {0} u   {0} u   u   {0} r  u   {0} r  r  rg  u   {0} u   u   {0} u   {0} u   {0} u   u
   {0} u   {0} u   {0} r   r   u
   u   u   u   u   u   u
   u   u   u   u   u   u   rl  u   u   rm  u   u   u   rn  u   u   u   u   u   u   u   u   ro  u   rp  r  rq  r  rr  rs  rt  Nr  r   r   r   r   r    sn   
r  c                   @   s   e Zd ZddgZdZdZddddd	d
d
gddddgddddgddddgddddgdZdddddZdddd d!d"d#d$d%d&d'd(d)gZdd*d+d,d-d.d/d0d1d2d3d4d5gZ	dd6d7d8d9d:d;d<gZ
dd=d>d?d@dAdBdCgZdDS )EMacedonianLocalemkmk_mku    {0}r  r  r  u   {0} u    r  r  u    u   {0} u   {0} u    r  u   {0} u    r  u   {0} u    r  r  r   u   u   u   u   r$   r   u   u   u   u
   u   u   u   u   u   u   u   u   u   .u    .u    .u    .u    u    .u    .u    .u
    .u    .u
    .u    .u   u    u    u    u    u    u    u   .u    .u    .u    .u    .u    .u    .Nrh   ri   rj   rl   re   rf   r=   rU   rE   rH   r@   rC   r   r   r   r   r  .  s   r  c                       s   e Zd ZdZdZdZdddddd	d
dddddddddZe Zded< ded< ded< ded< ded< ded< d d!d"d#d$d%d&d'd(d)d*d+d,gZ	d d-d.d/d0d%d1d2d3d4d5d6d7gZ
d d8d9d:d;d<d=d>gZd d?d@dAdBdCdDdEgZdFdG ZdL fdJdK	Z  ZS )MGermanBaseLocalezvor {0}rw   Zundzgerade ebenzeine Sekundez{0} Sekundenzeiner Minutez{0} Minutenzeiner Stundez{0} Stundenz	einem Tagz	{0} Tagenzeiner Wochez
{0} Wochenzeinem Monatz{0} Monatenz
einem Jahrz
{0} Jahrenr   zeine Minuter   zeine Stunder   zein Tagr   z
eine Wocher   z	ein Monatr    zein Jahrr"   r   JanuarFebruar   Mrzr}   MaiJuniJulir   r   r  r   Dezemberr   r      Mrr   r   r   r   r   r  r   DezZMontagZDienstagZMittwochZ
DonnerstagZFreitagZSamstagZSonntagZMor  ZMir  ZFrZSar  c                 C   s
   d |S r1  rN   rY   r   r   r   rX     s    z GermanBaseLocale._ordinal_numberr   Fc                    s4   |st t| |||S | j| tt|}|S r-   )r   r  r6   timeframes_only_distancer
   r   rb   r1   r   r   r   r6     s    
  zGermanBaseLocale.describe)r   F)rh   ri   rj   re   rf   r<   r=   copyr  rE   rH   r@   rC   rX   r6   r   r   r   r   r   r  {  s   r  c                   @   s   e Zd ZddgZdS )GermanLocaledede_deNrh   ri   rj   rl   r   r   r   r   r    s   r  c                   @   s   e Zd ZdgZdS )SwissLocalede_chNr  r   r   r   r   r    s   r  c                   @   s0   e Zd ZdgZdddddddd	d
ddddgZdS )AustrianLocalede_atr   u   Jnnerr  r  r}   r  r  r  r   r   r  r   r  N)rh   ri   rj   rl   rE   r   r   r   r   r    s   r  c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddZdddddddddddddgZdd d!d"d#dd$d%d&d'd(d)d*gZdd+d,d-d.d/d0d1gZ	dd2d3d4d5d6d7d8gZ
d9S ):NorwegianLocalenbnb_nofor {0} sidenr	  u   n nettopp	et sekundz{0} noen sekunder
ett minutt{0} minutteren time	{0} timerr
  z	{0} dager	   en mned   {0} mnederr  r  r   r   januarfebruarr   r  r   r  r  augustr  r  r  desemberr  r   r   r   r   r   r  r   r  r   desmandagtirsdagr  r   r!     lrdag   sndagr(  r)  onr*  r   u   lu   sNr  r   r   r   r   r    sn   
r  c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddZdddddddddddddgZdd d!d"d#dd$d%d&d'd(d)d*gZdd+d,d-d.d/d0d1gZ	dd2d3d4d5d6d7d8gZ
d9S ):NewNorwegianLocalennnn_nozfor {0} sidanr	  z
no nettoppr  z{0} nokre sekundr  z
{0} minuttzein timez	{0} timarzein dagr  r  r  u   eit rr  r   r   r  r  r   r  r   r  r  r  r  r  r  r  r  r   r   r   r   r   r  r   r  r   r  r  Ztysdagr  r   r!  ZlaurdagZsundagu   mtyr  r*  r   r,  r-  Nr  r   r   r   r   r  @  sn   
r  c                   @   s   e Zd ZddgZdZdZdZdddd	d
dddddddddddZddddddddddd d!d"gZdd#d$d%d&dd'd(d)d*d+d,d-gZ	dd.d/d0d1d2d3d4gZ
dd5d6d7d8d9d:d;gZd<S )=PortugueseLocaleptpt_ptu   h {0}em {0}r   agora
um segundor   	um minutor   uma horar   um dia{0} dias
uma semanar      um msr   um ano{0} anosr   r   ZjaneiroZ	fevereirou   maror   ZmaioZjunhoZjulhor   ZsetembroZoutubronovembroZdezembror  Zfevr   r   r   r   r   r   outr   Zdezzsegunda-feirau   tera-feirazquarta-feirazquinta-feirazsexta-feirar   r   segZterZquaZquiZsexr   r   Nr   r   r   r   r   r    st   
r  c                   @   s   e Zd ZdgZdZdZdddddd	d
dddddddddZddddddddddddd gZdd!d"d#d$d%d&d'd(d)d*d+d,gZdd-d.d/d0d1d2d3gZ	dd4d5d6d7d8d9d:gZ
d;S )<BrazilianPortugueseLocalept_brzfaz {0}r  r  r  r   r  r   r  r   r  r  r  r   r  r   r  r  r   r   ZJaneiroZ	Fevereirou   MaroAbrilZMaioZJunhoZJulhoAgostoZSetembroZOutubroZNovembroZDezembror   Fevr   Abrr  r   r   AgoSetZOutr   r  zSegunda-feirau   Tera-feirazQuarta-feirazQuinta-feirazSexta-feirau   SbadoZDomingoZSegZTerZQuaZQuiZSexSabZDomNr  r   r   r   r   r    sr   
r  c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddZdddddddddddddgZdd d!d"d#d$d%d&d'd(d)d*d+gZdd,d-d.d/d0d1d2gZ	dd3d"d4d5d6d7d8gZ
d9d: Zd;S )<TagalogLocaletltl_phznakaraang {0}z{0} mula ngayonzngayon langzisang segundoz{0} segundozisang minutoz
{0} minutoz
isang orasz{0} orasz
isang arawz{0} arawzisang buwanz	{0} buwanz
isang taonz{0} taonr   r   ZEneroZPebreroZMarsor  ZMayoZHunyoZHulyor  Z	SetyembreZOktubreZ	NobyembreZ	DisyembreZEneZPebr   r  r~   ZHunZHulr  r  r  ZNobZDisZLunesZMartesZ
MiyerkulesZHuwebesZBiyernesZSabadoZLinggoLunZMiyZHuwZBiyr  ZLinc                 C   s
   d |S )Nzika-{}rN   rY   r   r   r   rX   O  s    zTagalogLocale._ordinal_numberN)rh   ri   rj   rl   re   rf   r=   rE   rH   r@   rC   rX   r   r   r   r   r    sp   
r  c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddddZdddddddddddd d!gZdd"d#d$d%d&d'd(d)d*d+d,d-gZdd.d/d0d1d2d3d4gZ	dd5d6d7d8d9d:d;gZ
d<S )=VietnameseLocalevivi_vnu   {0} trcu	   {0} nau   hin tiu   mt giyu	   {0} giyu   mt phtu	   {0} phtu   mt giu	   {0} giu   mt ngyu	   {0} ngyu   mt tunu
   {0} tunu   mt thngu
   {0} thngu
   mt nmu   {0} nmr   r   u   Thng Mtu
   Thng Haiu	   Thng Bau
   Thng Tu   Thng Nmu   Thng Suu   Thng Byu   Thng Tmu   Thng Chnu   Thng Miu   Thng Mi Mtu   Thng Mi Haiu   Thng 1u   Thng 2u   Thng 3u   Thng 4u   Thng 5u   Thng 6u   Thng 7u   Thng 8u   Thng 9u	   Thng 10u	   Thng 11u	   Thng 12u	   Th Haiu   Th Bau	   Th Tu
   Th Nmu
   Th Suu   Th Byu   Ch Nhtu   Th 2u   Th 3u   Th 4u   Th 5u   Th 6u   Th 7ZCNNr  r   r   r   r   r  S  sr   
r  c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddZdddddddddddddgZdd d!d"d#d$d%d&d'd(d)d*d+gZdd,d-d.d/d0d1d2gZ	dd3d4d5d6d7d8d9gZ
d:S );TurkishLocaletrtr_tru	   {0} nce	{0} sonrau   imdiz
bir saniyez
{0} saniyez
bir dakikaz
{0} dakikabir saat{0} saat   bir gn   {0} gnbir ay{0} ayu   ylu   {0} ylr   r   ZOcaku   ubatMartZNisanu   MaysZHaziranZTemmuzu   Austosu   EyllZEkimu   Kasmu   AralkZOcau   ubr   ZNisr~   ZHazZTemu   AuZEylZEkiZKasZAraZ	Pazartesiu   Salu
   arambau	   PerembeZCumaZ	CumartesiZPazarZPztZSalu   arZPerZCumZCmtZPazNr  r   r   r   r   r    sn   
r  c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddZdddddddddddddgZdd d!d"d#dd$d%d&d'd(d)d*gZdd+d,d-d.d/d0d1gZ	dd2d3d4d5d6d7d8gZ
d9S ):AzerbaijaniLocaleazaz_azu   {0} vvlr   Zindiu   saniyu   {0} saniyu   bir dqiqu   {0} dqiqr  r  r  r  r  r  Zilz{0} ilr   r   ZYanvarZFevralr  ZAprelr~   u   yunu   yulZAvqustZSentyabrZOktyabrZNoyabrZDekabrZYanr  r   r   u   ynu   ylZAvqZSenr  ZNoyZDeku   Bazar ertsiu   rnb axamu   rnbu   Cm axamu   Cmu   nbZBazarZBeru   axu   rZCaxu   Cmu   nbZBzrNr  r   r   r   r   r    sn   
r  c                   @   s   e Zd Zddddddddd	d
ddddddddgZdZdZddddddddddddd d!d"dd#d$d%d&dd'd(d)d*dd+d,d-d.dd/Zd0d1d2d3d4d5d6d7d8d9d:d;d<gZd0d1d2d3d4d5d6d7d8d9d:d;d<gZd0d=d>d?d@dAdBdCgZ	d0dDdEdFdGdHdIdJgZ
dKdL ZdMS )NArabicLocalearar_aear_bhZar_djar_egZar_ehZar_erZar_kmar_kwar_lyar_omar_qaar_saar_sdZar_soar_ssZar_tdar_yeu
    {0}u    {0}u   u
   u   u   {0} u   {0} )doubletenhigheru
   u   u   {0} u   {0} u   u   u   {0} u   {0} u   u
   u   {0} u
   {0} u   u
   u   {0} u
   {0} u   u
   u   {0} u
   {0} r   r   
         
      
   
   u
               u   u   u   u   u   u
   u
   u
   u   u   u   u   u   u   c                 C   sZ   | j | }t|}t|trP|dkr.|d }n"|dkrH|dkrH|d }n|d }||S )Nr7   r  r   r  r  )r=   rb   r_  r_   r
   ra  r   r   r   r/   r	  s    



zArabicLocale._format_timeframeN)rh   ri   rj   rl   re   rf   r=   rE   rH   r@   rC   r/   r   r   r   r   r  	  s   






r  c                   @   sV   e Zd ZdddddgZdddd	d
ddddddddgZdddd	d
ddddddddgZdS )LevantArabicLocalear_iqar_joar_lbZar_psar_syr   u    u   u   u
   u   u   u   u   u
   u    u    u    Nrh   ri   rj   rl   rE   rH   r   r   r   r   r&  	  s:   r&  c                   @   sP   e Zd ZddgZddddddd	d
dddddgZddddddd	d
dddddgZdS )AlgeriaTunisiaArabicLocalear_tnar_dzr   u
   u
   r  u
      u   u   u   r"  r#  r$  r%  Nr+  r   r   r   r   r,  	  s:   r,  c                   @   sN   e Zd ZdgZdddddddd	d
ddddgZdddddddd	d
ddddgZdS )MauritaniaArabicLocaleZar_mrr   r  r  r  u
   r  r   r!  u   u
   r#  r$  u
   Nr+  r   r   r   r   r0  	  s:   r0  c                   @   sN   e Zd ZdgZdddddddd	d
ddddgZdddddddd	d
ddddgZdS )MoroccoArabicLocalear_mar   r  r  r  r  r/  r   u   u   u
   r#  u
   u
   Nr+  r   r   r   r   r1  	  s:   r1  c                   @   s   e Zd Zdd ZddgZdZdZddd	d
ddddddddddZdddddZddddddddd d!d"d#d$gZ	dd%d&d'd(dd)d*d+d,d-d.d/gZ
dd0d1d2d3d4d5d6gZdd7d8d9d:d;d<d=gZd>S )?IcelandicLocalec                 C   s:   | j | }|dk r|d }n|dkr,|d }|t|S r.  r/  rc   r   r   r   r/   	
  s    

z!IcelandicLocale._format_timeframeisis_isu   fyrir {0} sanz	eftir {0}u   rtt  essu)   sekndur6  )u   {0} nokkrum sekndumu   nokkrar sekndur)u   einni mntuu   eina mntu)u   {0} mntumu   {0} mntur)u   einum tmau
   einn tma)u
   {0} tmumu	   {0} tma)z
einum degizeinn dag)u
   {0} dgumz{0} daga)u   einum mnuiu   einn mnu)u   {0} mnuumu   {0} mnui)u	   einu riu   eitt r)u	   {0} rumu   {0} rr   zf.h.ze.h.r$   r   u   janaru   febrarr      aprlu   mau   jnu   jlu   gstr     oktberu	   nvemberr  r  r   r   r      jn   jlu   gr   r  u   nvr  u
   mnudaguru   rijudaguru   mivikudagurZfimmtudaguru   fstudagurZlaugardagurZ
sunnudaguru   mnu   riu   miZfimu   fsZlausunN)rh   ri   rj   r/   rl   re   rf   r=   rU   rE   rH   r@   rC   r   r   r   r   r3  
  sr   

r3  c                   @   s   e Zd ZddgZdZdZdZdddd	d
dddddddddZddddddddddddd gZdd!d"d#d$dd%d&d'd(d)d*d+gZ	dd,d-d.d/d0d1d2gZ
dd3d4d5d6d7d8d9gZd:S );DanishLocaledada_dkr  z	efter {0}ogzlige nur  z{0} et par sekunderzet minutr  r  r  r
  z{0} dager  r  u   et rr  r   r   r  r  Zmartsr  r  r  r  r  r  r  r  r  r  r   r   r   r   r   r  r   r  r   r  r  r  r  r   r!  r  r  ZmanZtirr"  r#  r$  u   lru   snNr   r   r   r   r   r<  V
  sp   
r<  c                   @   s   e Zd ZdgZdZdZdddddd	d
dddddddZdddddZdddddddddddd d!gZdd"d#d$d%d&ddd'd(d)d*d+gZ	dd,d-d.d/d0d1d2gZ
dd,d-d.d/d0d1d2gZd3S )4MalayalamLocalemlu   {0} u   {0} u   u    u"   {0} u"    u   {0} u"    u   {0} u     u   {0}  u     u   {0}  u     u   {0}  r   u   u%    r$   r   u   u   u   u    u    u   u   u   u   u   u   u   u	   u    u	   u   u   u   u   u   u	   u   u   u   u   u   u   u	   u   Nr  r   r   r   r   r@  
  sx   r@  c                   @   s   e Zd ZdgZdZdZdddddd	d
dddddddZdddddZdddddddddddd d!gZdd"d#dd$dddd%d&d'd(d)gZ	dd*d+d,d-d.d/d0gZ
dd1d2d3d-d4d5d6gZd7S )8HindiLocalehiu   {0} u   {0} u	   u    u   {0} u     u   {0}  u    u   {0}        {0} u     u   {0}       u   {0}  r   u   u	   r$   r      u      u    u   	      u   u   u   u   u      u   u   u   u	   u	   u	   u	                        	      	      	   	   Nr  r   r   r   r   rB  
  sp   
rB  c                   @   s  e Zd ZddgZddddddddgd	d
ddddddgd	dddddddgd	dddddddgd	dddddddgd	ddddd d!dgd	d"Zd#Zd$Zd%d&d'd(d)d*d+d,d-d.d/d0d1gZd%d2d3d4d5d6d7d8d9d:d;d<d=gZd%d>d?d@dAdBdCdDgZ	d%dEdFdGdHdIdJdKgZ
dLdM ZdNS )OCzechLocalecscs_czu   Teu   vteinare   rf   zeroz{0} sekundamiry  rx  re   rf   ZminutouZminuturz  {0} minutamir{  hodinouhodinuz	{0} hodin{0} hodinami
{0} hodinyZdnemZdenu   {0} dnz{0} dnyu	   mscemu   mscu   {0} mscu   {0} msciu   {0} msceZrokemr}  {0} letz{0} lety{0} rokyr   u	   Ped {0}zZa {0}r   Zledenu   noru   bezenZdubenu   kvtenu   ervenu	   ervenecZsrpenu   zu   jenr~  ZprosinecZledu   nou   beZdubu   kvu   vnu   vcZsrpu   zu   jr  prou	   pondlu   teru   stedau   tvrteku   ptekr  u   nedlepou   tstu   tu   psonec                 C   s   | j | }t|tr@|dkr&|d }n|dkr8|d }n|d }t|}t|trd|d   krjdkrn n"|d dk s|d d	kr|d }n|d
 }||S )zqCzech aware time frame format function, takes into account
        the differences between past and future forms.r   r]  rf   re   r7   r   r]  r   r^  r9   r=   r_  r_   rb   r`  r
   ra  r   r   r   r/   j  s    




4
zCzechLocale._format_timeframeN)rh   ri   rj   rl   r=   re   rf   rE   rH   r@   rC   r/   r   r   r   r   rY  )  sp   






rY  c                   @   s  e Zd ZddgZddddddddgd	d
ddddddgd	dddddddgd	dddddddgd	dddddddgd	ddd dd!d"d gd	d#Zd$Zd%Zd&Zd'd(d)d*d+d,d-d.d/d0d1d2d3gZd'd4d5d6d7d,d-d.d8d9d:d;d<gZ	d'd=d>d?d@dAdBdCgZ
d'dDdEdFdGdHdIdJgZdKdL ZdMS )NSlovakLocalesksk_skZTerazu   druhr\  u   pr sekundamiry  u   {0} sekndr^  u   mintouu   mintuu
   {0} mintu   {0} mintamiu   {0} mintyr`  ra  u
   {0} hodnrb  rc  u   domu   deu   {0} dnu
   {0} damir|  ZmesiacomZmesiacz{0} mesiacovz{0} mesiacmiz{0} mesiaceZrokomr}  z	{0} rokovz	{0} rokmire  r   zPred {0}zO {0}rR   r      janur   februrZmarecr7     mjr9  r:  r  r  r8  r  r  r  r   r   r   r  r   r  r   r  ZpondelokZutorokZstredau   tvrtokZpiatokr  u   nedearg  utrh  u   tpiri  rj  c                 C   s   | j | }t|tr@|dkr&|d }n|dkr8|d }n|d }t|}t|trd|d   krjdkrn n"|d dk s|d d	kr|d }n|d
 }||S )zrSlovak aware time frame format function, takes into account
        the differences between past and future forms.r   r]  rf   re   r7   r   r]  r   r^  r9   rk  ra  r   r   r   r/     s    




4
zSlovakLocale._format_timeframeN)rh   ri   rj   rl   r=   re   rf   r<   rE   rH   r@   rC   r/   r   r   r   r   rl    sr   






rl  c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddZdddddZddddddddddd d!d"gZdd#d$d%d&dd'd(d)d*d+d,d-gZ	dd.d/d0d1d2d3d4gZ
dd5d6d7d8d9d:d;gZd<S )=FarsiLocalefafa_iru
   {0} u    {0}u
   u    u   {0} u    u   {0} u    u   {0} u    u
   {0} u    u
   {0} u    u
   {0} r   u     u     r$   r   rz   r{   r|   r}   r~   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   u    u    u   u   u   u   u   r   r   r   r   r   r   r   Nr  r   r   r   r   rt    sx   
rt  c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddddddZdddddZddddd d!d"d#d$d%d&d'd(gZdd)d*dd+d!d"d#d,d-d.d/d0gZ	dd1d2d3d4d5d6d7gZ
dd8d9d:d;d<d=d>gZd?d@ ZdAS )BHebrewLocalehehe_ILu    {0}u    {0}u   u
   u   {0} u   u   {0} u   u   {0} u   u   u   {0} u   u   u   {0} u   u   u   {0} u   )r   r   r   r   r   r   r   z2-hoursr   r   z2-daysr    r!   z2-monthsr"   r#   z2-yearsu	   "u	   "u    u    r$   r   u
   u   u   u
   u   u   u   u   u   u   u   u
   u   u   u   u   u   u   u   u   u   u
   u
   u
   u   u   u
   u   u   u   u   u   u   u   c                 C   sL   d |}t|dkr4|| jkr4| j|  t|S | j|  t|S dS )z"Hebrew couple of <timeframe> awarez2-{}r7   N)r
   rb   r=   )r+   r2   r3   Zcoupler   r   r   r/   f  s    
zHebrewLocale._format_timeframeN)rh   ri   rj   rl   re   rf   r=   rU   rE   rH   r@   rC   r/   r   r   r   r   rw  "  sr   rw  c                   @   s   e Zd ZdgZdZdZdddddd	d
dddddddZdddddZdddddddddddd d!gZdd"d#dd$dddd%d&d'd(d)gZ	dd*d+d,d-d.d/d0gZ
dd1d2d3d4d5d6d7gZd8S )9MarathiLocalemru   {0} u   {0} u   u    u   {0} u     u   {0}  u    u   {0} u    u   {0} u     u   {0}  rF  u   {0}  r   u   u   r$   r   u   u   rH  u      rI  u   u   u   u   u   u   u	   u   u   u	   u   u   u   u   rL  u   rN  rO  rP  rQ  rR  rS  u   rU  u   rV  rW  rX  Nr  r   r   r   r   rz  o  sp   
rz  c                  C   sH   i } t tjt t jD ]*\}}t|tr|jD ]}|| |	 < q0q| S r)   )
inspect
getmemberssysmodulesrh   isclass
issubclassr   rl   r   )Zlocales_clsr   r   r   r   _map_locales  s    

r  c                   @   s   e Zd ZdddddgZdZdZdZd	d
ddddddddddddZdddddddddd d!d"d#gZdddddddddd d!d"d#gZ	dd$d%d&d'd(d)d*gZ
dd$d%d&d'd(d)d*gZd+S ),CatalanLocalecaca_esca_adca_frca_itzFa {0}zEn {0}r\   z
Ara mateixzun segonz
{0} segonsz1 minutz
{0} minutsr   z	{0} horeszun diaz{0} diesr   z	{0} mesoszun anyz{0} anysr   r   ZGenerZFebreru   Marr  ZMaigZJunyZJuliolZAgostZSetembreZOctubreZNovembreZDesembreZDillunsZDimartsZDimecresZDijousZ	DivendresZDissabteZDiumengeNr   r   r   r   r   r    s   r  c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddZdddddddddddddgZdd d!d"d#d$d%d&d'd(d)d*d+gZdd,d-d.d/d0d1d2gZ	dd3d4d5d6d7d8d9gZ
d:S );BasqueLocaleeuZeu_euz	duela {0}z{0}ZOrainzsegundo batz{0} segunduz
minutu batz
{0} minutuzordu batz{0} orduzegun batz{0} egunzhilabete batz{0} hilabetzurte batz{0} urter   r   Z
urtarrilakZotsailakZmartxoakZapirilakZmaiatzakZekainakZuztailakZabuztuakZirailakZurriakZazaroakZabenduakZurtZotsr   apir   ZekaZuztZabuZiraZurrZazaZabeZ
astelehenaZ	astearteaZ
asteazkenaZostegunaZostiralaZ	larunbataZigandeaalr  r	  r?  ollrZigNr  r   r   r   r   r  
  sn   
r  c                   @   s   e Zd ZddgZdZdZdddddd	dd
ddddddddddddddddddddddddddddddZdd d!d"d#d$d%d&d'd(d)d*d+gZdd,d-d.d/d0d1d2d3d4d5d6d7gZdd8d9d:d;d<d=d>gZ	dd?d9d@dAdBdCdDgZ
dEdFdGdHdIZdJdK ZdLS )MHungarianLocalehuhu_huu   {0} ezelttu
   {0} mlvau   ppen mostu   egy msodikr^  u   {0} msodpercekkelu   {0} pr msodperczegy perccelzegy percz{0} perccelz{0} percu   egy rvalu   egy rau   {0} rvalu   {0} raz
egy nappalzegy napz
{0} nappalz{0} napu   egy hnappalu
   egy hnapu   {0} hnappalu
   {0} hnapu
   egy vvelu   egy vu
   {0} vvelu   {0} vr   r   ro  rp  u   mrciusu   prilisu   mjusu   jniusu   jliusZ	augusztusZ
szeptemberr8  r  r  r  febru   mrcu   prrq  r9  r:  r  Zszeptr  r   r  u   htfZkeddZszerdau   cstrtku   pntekZszombatu	   vasrnapu   htZszeru   cstu   pntZszomZvasr  duZDEZDUr$   c                 C   s<   | j | }t|tr.|dkr&|d }n|d }|t|S Nr   rf   re   )r=   r_  r_   r
   rb   ra  r   r   r   r/     s    


z!HungarianLocale._format_timeframeN)rh   ri   rj   rl   re   rf   r=   rE   rH   r@   rC   rU   r/   r   r   r   r   r  J  sr   
r  c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddZdddddddddddddgZdd d!d"d#d$d%d&d'd(d)d*d+gZdd,d-d.d/d0d1d2gZ	dd3d"d4d5d6d7d8gZ
d9d:d;d<d=Zd>Zd?d@ ZdAS )BEsperantoLocaleeoeo_xxu
   anta {0}zpost {0}Znunsekundoz{0} kelkaj sekundojz
unu minutoz{0} minutojzun horoz	{0} horojzunu tagoz	{0} tagojz
unu monatoz{0} monatojzunu jaroz	{0} jarojr   r   ZjanuaroZfebruaroZmartoZapriloZmajor   r   u   agustoZ	septembroZoktobror  Zdecembror  r   r   r   r  r   r   u   agr   r  r   r  ZlundoZmardoZmerkredou   adoZvendredor   u   dimanor   r   u   ar   r   r   ZatmZptmZATMZPTMr$   z((?P<value>[1-3]?[0-9](?=a))a)c                 C   s
   d |S )Nz{}arN   rY   r   r   r   rX     s    zEsperantoLocale._ordinal_numberN)rh   ri   rj   rl   re   rf   r=   rE   rH   r@   rC   rU   rm   rX   r   r   r   r   r    st   
r  c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddZdddddddddddddgZdd d!d"d#d$d%d&d'd(d)d*d+gZdd,d-d.d/d0d1d2gZ	dd3d4d5d6d7d8d9gZ
d:d;d<d=d>Zd?Zd@dA ZdBdC ZdDdE ZdFS )G
ThaiLocalethth_thu!   {0}{1}u   {1}{0}u   u   u(   {0} u   1 u   {0} u   1 u   {0} u   1 u   {0} u   1 u   {0} u   1 u
   {0} r   r   u   u   u   u   u   u   u   u   u   u   u   u   u   ..u   ..u   ..u   ..u   ..u   ..u   ..u   ..u   ..u   ..u   ..u   ..u   u   u	   u   u   u   u   u   u   u   u   u   u   u   r%   r&   r'   r(   r$   i  c                 C   s   || j 7 }d|S )3Thai always use Buddhist Era (BE) which is CE + 543rM   	BE_OFFSETr
   rO   r   r   r   rP     s    
zThaiLocale.year_fullc                 C   s   || j 7 }d|dd S )r  rM   r7   Nr  rO   r   r   r   rQ   $  s    
zThaiLocale.year_abbreviationc                 C   s<   |dkr|S |dkrdnd}|dk r*| j n| j}|||S )z2Thai normally doesn't have any space between wordsr   r   r   r8   r   rd   )r+   r5   r2   r3   spacerg   r   r   r   r0   )  s
    zThaiLocale._format_relativeN)rh   ri   rj   rl   re   rf   r=   rE   rH   r@   rC   rU   r  rP   rQ   r0   r   r   r   r   r    sh   r  c                   @   s   e Zd ZdddgZdZdZdddd	d
dddddddddZdddddZdddddddddd d!d"d#gZdd$d%dd&ddd'd(d)d*d+d,gZ	dd-d.d/d0d1d2d3gZ
dd4d5d6d7d8d9d:gZd;d< Zd=S )>BengaliLocaleZbnbn_bdbn_inu   {0} u   {0} u	   u%    u   {0} u    u   {0} u    u   {0} u    u   {0} u    u   {0}  u    u   {0} r   u   u   r$   r   u   u   u   u   u   u	   u   u   u   u   u   u   u   u	   u   u	   u	   u   u   u	   u   u   u   u   u!   u   u   u   u	   u   u	   u   u   u	   u	   c                 C   sf   |dks|dkrd |S |dkr,d |S |dkr>d |S |dkrPd	 |S |d
krbd |S d S )Nr   r   u   {})r9            	   r   u   {})r7   r   u   {}r]  u   {}   u   {}rN   rY   r   r   r   rX   w  s    



zBengaliLocale._ordinal_numberN)rh   ri   rj   rl   re   rf   r=   rU   rE   rH   r@   rC   rX   r   r   r   r   r  3  sr   

r  c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddZdddddddddddddgZdd d!dd"dd#d$d%d&d'd(d)gZdd*d+d,d-d.d/d0gZ	dd1d2d3d4d5d6d7gZ
d8S )9RomanshLocaleZrmZrm_chz	avant {0}r   zen quest mumentz
in secundaz{0} secundasz
ina minutaz{0} minutaszin'uraz{0} urazin diz{0} diszin maisz{0} maiszin onnz{0} onnsr   r   ZschanerZfavrerr   ZavriglZmatgZ	zercladurZfanadurZavustZ	settemberoctoberr  r  ZschanZfavr   ZzerZfanZavur   r   r   r  Z	glindesdir   ZmesemnaZgievgiaZvenderdiZsondaZdumengiaZglir(  meZgieveri  r  Nr  r   r   r   r   r    sn   r  c                   @   s   e Zd ZddgZdZdZdZdddd	d
dddddddddZddddddddddddd gZdd!d"d#d$dd%d&d'd(d)d*d+gZ	dd,d-d.d/d0d1d2gZ
dd3d4d5d6d7d8d9gZd:S );RomanianLocaleroro_rou   {0} n urmz	peste {0}u   iZacumz	o secundau   {0} cteva secundezun minutr  u   o orr   zo ziz{0} zileu   o lunz{0} lunir   z{0} anir   r   ZianuarieZ	februarieZmartieZaprilier   ZiunieZiulier  Z
septembrieZ	octombrieZ	noiembrieZ	decembrieZianr  Zmartr   ZiunZiulr  r   r   r   r  Zluniu   mariZmiercuriZjoiZvineriu
   smbtu	   duminicr  r   ZMieZJoiZVinu   SmZDumNr   r   r   r   r   r    sp   
r  c                   @   s   e Zd ZddgZdZdZdZdddd	d
dddddddddZdddddZdddddddddddd d!gZ	dd"d#d$d%dd&d'd(d)d*d+d,gZ
dd-d.d/d0d1d2d3gZdd4d5d6d7d8d9d:gZd;S )<SlovenianLocaleslsl_sizpred {0}u   ez {0}inZzdajr  rx  Zminutar_  Zuroz{0} urdanr|  Zmesecz{0} mesecevZletord  r   r   r$   r  r  ZMarecr}   ZMajZJunijZJulijZAvgustr   r  r   r   r   r   r   r   r   r   ZAvgr   r  r   r   Z
PonedeljekZTorekZSredau   etrtekZPetekZSobotaZNedeljaZPonZTorZSreu   etZPetZSobZNedNrh   ri   rj   rl   re   rf   r<   r=   rU   rE   rH   r@   rC   r   r   r   r   r    sr   r  c                   @   s   e Zd ZddgZdZdZdZdddd	d
dddddddddZdddddZdddddddddddd d!gZ	dd"d#d$d%dd&d'd(d)d*d+d,gZ
dd-d.d/d0d1d2d3gZdd-d.d/d0d1d2d3gZd4S )5IndonesianLocaleidid_idz{0} yang laluz	dalam {0}r  z	baru sajaz
1 sebentarz	{0} detikz1 menitz	{0} menitz1 jamz{0} jamz1 hariz{0} hariz1 bulanz	{0} bulanz1 tahunz	{0} tahunr   r   r$   ZJanuariZFebruariZMaretr}   r  r  r  ZAgustusr   r  r   r  r   r   r   r   r   r   ZAgsZSeptr  r   r  ZSeninZSelasaZRabuZKamisZJumatZSabtuZMingguNr  r   r   r   r   r  S  sr   r  c                   @   s   e Zd ZddgZdZdZddddd	d
ddddddddZdddddZddddddddddd d!d"gZdd#d$dddddd%d&d'd(d)gZ	dd*d+d,d-d.d/d0gZ
dd1d2d3d4d5d6d7gZd8S )9NepaliLocalerj  ne_npu   {0} u   {0} u   u    u   {0} u   u   {0} u    u   {0} rD  rE  u    u   {0} u    u   r   u   u   r$   r   rG  u   rH  u   r|  u	   rJ  u   u   u   u   u   rK  u	   u   u	   u   u	   u	   rL  rM  rN  u   rP  rQ  u   rS  rT  rU  u   rV  rW  u	   Nr  r   r   r   r   r    sp   r  c                   @   s   e Zd ZddgZdZdZdZddddd	dd
dddddddddddddddddddddddddddddddddZd d!d"d#d$d%d&d'd(d)d*d+d,gZd d-d.d/d0d%d1d2d3d4d5d6d7gZ	d d8d9d:d;d<d=d>gZ
d d?d@dAdBdCdDdEgZdFdG ZdHS )IEstonianLocaleeer   z
{0} tagasiu   {0} prastr   u   just ndr^  u   ks sekundu   he sekundiz{0} sekunditz{0} sekundiu
   ks minutu   he minutiz{0} minutitr   z	tund aegaz	tunni ajaz	{0} tundiz	{0} tunniu
   ks pevu   he pevau
   {0} pevau   ks kuuu   he kuuz{0} kuudz{0} kuuu
   ks aastau
   he aastaz
{0} aastatz	{0} aastar   r   ZJaanuarZVeebruaru   MrtsZAprillr  ZJuuniZJuulir   r   ZOktooberr   Z	Detsemberr   ZVebr  r   r   r   r   r   r  r   ZDetsu
   Esmaspevu
   Teisipevu
   Kolmapevu
   NeljapevZReedeu   Laupevu
   PhapevZEsmZTeisZKolmZNeljZReZLauu   Phc                 C   s2   | j | }|dkr|d }n|d }|t|S r  r/  ra  r   r   r   r/   "  s
    

z EstonianLocale._format_timeframeN)rh   ri   rj   rl   re   rf   r<   r=   rE   rH   r@   rC   r/   r   r   r   r   r    sr   
r  )H
__future__r   r   r}  r  mathr   r   r   objectr   rn   r   r   r   r   r   r  r%  r2  rE  rO  rQ  rT  r\  rc  ru  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r&  r,  r0  r1  r3  r<  r@  rB  rY  rl  rt  rw  rz  r  r  r  r  r  r  r  r  r  r  r  r  r  r   r   r   r   r   <module>   s    6mIKMD<D[<=<;GCGECCCMcCCEEFECCb""""NDJEWXJMEJ@PHQQECGHEKU
    ^GO                     @   s   d dl mZmZ d dlZd dlmZmZ d dlmZ d dlm	Z	 d dl
mZmZmZ d dlmZ zd dlmZ W n  ek
r   d dlmZ Y nX G d	d
 d
eZG dd deZG dd deZG dd deZdS )    )absolute_importunicode_literalsN)datetime	timedeltatz)locales)MAX_TIMESTAMPMAX_TIMESTAMP_MSMAX_TIMESTAMP_US)iso_to_gregorian)	lru_cachec                   @   s   e Zd ZdS )ParserErrorN__name__
__module____qualname__ r   r   MC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-b620trd2\arrow\parser.pyr      s   r   c                   @   s   e Zd ZdS )ParserMatchErrorNr   r   r   r   r   r      s   r   c                   @   s,  e Zd ZedZedZedZedZedZ	edZ
edZedZed	Zed
ZedZedZedZedZedZee
e
eeee
ee
ee
ee
ee
eeeeeee	edZdddgZd'ddZdd Zdd Zdd Zdd Zed d! Zd"d# Zed(d$d%Zd&S ))DateTimeParserzF(YYY?Y?|MM?M?M?|Do|DD?D?D?|d?d?d?d|HH?|hh?|mm?|ss?|S+|ZZ?Z?|a|A|x|X|W)z\[[^\[\]]*\]z\d{1,2}z\d{1,3}z\d+z\d{2}z\d{3}z\d{4}z([\+\-])(\d{2})(?:(\d{2}))?|Zz([\+\-])(\d{2})(?:\:(\d{2}))?|Zz\w[\w+\-/]+z^\-?\d+\.?\d+$z^\-?\d+$z9^(\d{2})(?:\:?(\d{2}))?(?:\:?(\d{2}))?(?:([\.\,])(\d+))?$z5(?P<year>\d{4})[\-]?W(?P<week>\d{2})[\-]?(?P<day>\d)?)YYYYYYMMMDDDDDDDDDDHHHhhhmmmsssXxZZZZZZSW-/.en_usr   c                 C   s   t || _| j | _| j| | jjdd  t	j
| | jjdd  t	j
t	| jj| | jjdd  t	j
| | jjdd  t	j
t	d| | jjd | jjd f| | jj d |dkrt|d| j| _d S )N   z[1-7]ampm)MMMMMMMDoZddddZddddaAr   )maxsize)r   Z
get_localelocale_BASE_INPUT_RE_MAPcopy_input_re_mapupdate_generate_choice_reZmonth_namesre
IGNORECASEZmonth_abbreviationscompileZordinal_day_reZ	day_namesZday_abbreviations	meridiansvaluesr   _generate_pattern_re)selfr<   Z
cache_sizer   r   r   __init__S   s>        zDateTimeParser.__init__c                    s  d|k}d|k}| d}|r&|dks2|r@|dkr@td||pF|}d}ddd	d
dddddddddddddg}|r|r|dd\} n|dd\} td dtj}	| j|	d }
|
d krtd|
 \}}}}}t	|	dk}|d k	}|d k	}|d k	}d|	d k}d|r.d|	d kr.d|r8dnd}|rRdj||d  n,|rfd!j|d" n|rzd#j|d" nd$ |r fd%d&|D }n fd'd&|D }|r|rfd(d&|D }| 
||S ))N Tr2   r   zeExpected an ISO 8601-like string, but was given '{}'. Try passing in a format string to resolve this.Fz
YYYY-MM-DDz	YYYY-M-DDzYYYY-M-Dz
YYYY/MM/DDz	YYYY/M/DDzYYYY/M/Dz
YYYY.MM.DDz	YYYY.M.DDzYYYY.M.DZYYYYMMDDz	YYYY-DDDDZYYYYDDDDzYYYY-MMzYYYY/MMzYYYY.MMr   r-   z[\+\-Z]zInvalid time component provided. Please specify a format or provide a valid time component in the basic or extended ISO 8601 time format.   :r+   r*    z+HH{time_sep}mm{time_sep}ss{subseconds_sep}S)time_sepsubseconds_sepzHH{time_sep}mm{time_sep}ss)rO   zHH{time_sep}mmr   c                    s   g | ]}d  | qS )z{} {}format.0ftime_stringr   r   
<listcomp>   s     z,DateTimeParser.parse_iso.<locals>.<listcomp>c                    s   g | ]}d  | qS )z{}T{}rQ   rS   rV   r   r   rX      s     c                    s   g | ]}d  | qS )z{}{}rQ   rS   )	tz_formatr   r   rX      s     )countr   rR   splitrB   rC   _TIME_REmatchgroupslen_parse_multiformat)rH   datetime_stringZhas_space_dividerZhas_t_dividerZ
num_spacesZhas_timeZhas_tzformatsdate_stringZ
time_partsZtime_componentshoursminutessecondsrP   Z
subsecondsZhas_minutesZhas_secondsZhas_subsecondsZis_basic_time_formatrO   r   )rW   rY   r   	parse_isov   s    

 zDateTimeParser.parse_isoc           	      C   s   t |tr| ||S | |\}}||}|d krFtd||i }|D ]V}|dkrf|d}n0|dkr|d|d|df}n
||}| ||| qN| 	|S )Nz&Failed to match '{}' when parsing '{}'r7   valuer-   yearweekday)

isinstancelistr`   rG   searchr   rR   group_parse_token_build_datetime)	rH   ra   fmtZ
fmt_tokensZfmt_pattern_rer]   partstokenrh   r   r   r   parse   s"    



zDateTimeParser.parsec              	   C   sj  g }d}t |}t | jd|}t dd|}t | j|}|}| j|D ]}|d}z| j| }	W n" t	k
r   t
d|Y nX d||	j}
|| |d | |  |
 || | d   }|t|
| |   7 }qNd}|d}tt|D ]4}||| 7 }|t|k r
||| d	d
 7 }q
d}d}d|||}|t j|t jdfS )Nr   #zS+r,   zUnrecognized token '{}'z
(?P<{}>{})rN   z\#r2   z9(?<!\S\S)(?<![^\,\.\;\:\?\!\"\'\`\[\]\{\}\(\)<>\s])(\b|^)z/(?=[\,\.\;\:\?\!\"\'\`\[\]\{\}\(\)\<\>]?(?!\S))z{}{}{}flags)rB   escapesub
_ESCAPE_REfindall
_FORMAT_REfinditerro   r?   KeyErrorr   rR   patternappendstartendr_   r[   rangerD   rC   )rH   rr   tokensoffsetZescaped_fmtZescaped_dataZfmt_patternr$   rt   Zinput_reZinput_patternZfinal_fmt_patternZ	split_fmtiZstarting_word_boundaryZending_word_boundaryZbounded_fmt_patternr   r   r   rG      sL    



  z#DateTimeParser._generate_pattern_rec                 C   s@  |dkrt ||d< n$|dkrHt |}|dkr8d| nd| |d< n|dkrh| j| |d< n|d	krt ||d< n|d
krt ||d< n|dkrt ||d< n|dkrt ||d< nt| dkrt ||d< nX|dkrt ||d< n@|dkrt ||d< n&|dkr|dtd}t |d }|dkrXt |d d }n|dkrhd}nd}t |d d | |d< n|dkrt||d< n|d krt ||d!< n|d"krt	||d#< nl|d$kr*|| jj
d% | jj
d& fkrd%|d'< n&|| jj
d( | jj
d) fkr<d(|d'< n|d*kr<||d+< d S ),Nr   ri   r   D   il  i  )r5   r6   month)r   r   )r   r   day_of_year)r   r   rk   )r7   )r   r    hour)r#   r$   minute)r%   r&   secondr,      0      rL   r2   r   microsecondr'   	timestampr(   expanded_timestamp)r)   r*   r+   tzinfo)r9   r:   r3   ZAMam_pmr4   ZPMr-   weekdate)intr<   month_numberlowerupperljuststrfloatTzinfoParserru   rE   )rH   rt   rh   rs   Zseventh_digitroundingr   r   r   rp   A  sV     










zDateTimeParser._parse_tokenc                 C   s  |  d}|d k	rtt|d t|d  }}|d d k	rFt|d }nd}t|||}|j| d< |j| d< |j| d< |  d}|d k	rtj|t	 d	S |  d
}|d k	r|t
kr|tk r|d }n |tk r|d }ntd|tj|t	 d	S |  d}|d k	r|  d}|  d}	|d kr0td|	d k	rBtdd||}
zt|
d}W n$ tk
r   td|Y nX |j| d< |j| d< |j| d< |  d}|  dd}|dkr|dk r|d7 }n|dkr|dkrd}|dkrP|  dddkrtd|  dddkr,td|  dddkrFtdd}d}nd}|  dd}|d krtd}d}nd}t||d!}t|  dd|  dd|  dd||  dd|  dd||  d"d#| S )$Nr   r   r2   rL   ri   r   rk   r   r   r   g     @@g    .Az*The specified timestamp '{}' is too large.r   z8Year component is required with the DDD and DDDD tokens.z<Month component is not allowed with the DDD and DDDD tokens.z{}-{}z%Y-%jz)The provided day of year '{}' is invalid.r   r   r4      r3      r   z3Midnight at the end of day must not contain minutesr   z3Midnight at the end of day must not contain secondsr   z8Midnight at the end of day must not contain microsecondsi@B )daysrf   r   )ri   r   rk   r   r   r   r   r   )getr   r   ri   r   rk   r   fromtimestampr   tzutcr	   r
   r   
ValueErrorrR   r   strptimer   )rs   r   ri   rj   rk   dtr   r   r   r   rc   r   r   Zday_incrementr   Zsecond_increment	incrementr   r   r   rq     s    



























zDateTimeParser._build_datetimec              	   C   s\   d }|D ]0}z|  ||}W  q:W q tk
r6   Y qX q|d krXtd|d||S )Nz>Could not match input '{}' to any of the following formats: {}z, )ru   r   r   rR   join)rH   stringrb   	_datetimerr   r   r   r   r`     s    
 z!DateTimeParser._parse_multiformatc                 C   s   t jdd| |dS )Nz({})|rx   )rB   rD   rR   r   )choicesry   r   r   r   rA     s    z"DateTimeParser._generate_choice_reN)r1   r   )r   )r   r   r   rB   rD   r~   r|   Z_ONE_OR_TWO_DIGIT_REZ_ONE_OR_TWO_OR_THREE_DIGIT_REZ_ONE_OR_MORE_DIGIT_REZ_TWO_DIGIT_REZ_THREE_DIGIT_REZ_FOUR_DIGIT_REZ_TZ_Z_REZ	_TZ_ZZ_REZ_TZ_NAME_REZ_TIMESTAMP_REZ_TIMESTAMP_EXPANDED_REr\   Z_WEEK_DATE_REr=   Z
SEPARATORSrI   rg   ru   rG   rp   staticmethodrq   r`   rA   r   r   r   r   r       sh   















#cND
tr   c                   @   s"   e Zd ZedZedd ZdS )r   z!^([\+\-])?(\d{2})(?:\:?(\d{2}))?$c                 C   s   d }|dkrt  }n||dkr(t  }nj| j|}|r| \}}}|d krRd}t|d t|d  }|dkrz|d9 }t d |}n
t |}|d krt	d
||S )	Nlocal)utcUTCr+   r   i  <   r.   rw   z(Could not parse timezone expression "{}")r   Ztzlocalr   
_TZINFO_REr]   r^   r   tzoffsetZgettzr   rR   )clsZtzinfo_stringr   Z	iso_matchsignrd   re   rf   r   r   r   ru     s(    


zTzinfoParser.parseN)r   r   r   rB   rD   r   classmethodru   r   r   r   r   r     s   
r   )
__future__r   r   rB   r   r   Zdateutilr   Zarrowr   Zarrow.constantsr	   r
   r   Z
arrow.utilr   	functoolsr   ImportErrorZbackports.functools_lru_cacher   r   r   objectr   r   r   r   r   r   <module>   s"   	   wU
    ^
                     @   sj   d dl mZ d dlZdd Zdd Zdd Zze d	d
 ZW n ek
rX   dd
 ZY nX ddd
dgZ	dS )    )absolute_importNc                 C   s   |   S )z Get total seconds for timedelta.)total_seconds)td r   KC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-b620trd2\arrow\util.pyr      s    r   c                 C   sZ   t | trdS t | ts0t | ts0t | ts0dS zt|  W dS  tk
rT   Y dS X dS )z$Check if value is a valid timestamp.FTN)
isinstanceboolintfloatstr
ValueError)valuer   r   r   is_timestamp   s    
r   c                 C   s   d|  krdksn t dd|  kr2dks<n t dt| dd}t| d }|| }|tj|d |d d }|S )z7Converts an ISO week date tuple into a datetime object.   5   z-ISO Calendar week value must be between 1-53.   z*ISO Calendar day value must be between 1-7   )daysweeks)r   datetimedate	timedelta
isoweekday)Ziso_yearZiso_weekZiso_dayZ
fourth_jandeltaZ
year_startZ	gregorianr   r   r   iso_to_gregorian   s    r   c                 C   s
   t | tS N)r   
basestringsr   r   r   isstr3   s    r   c                 C   s
   t | tS r   )r   r   r   r   r   r   r   9   s    )

__future__r   r   r   r   r   r   r   	NameError__all__r   r   r   r   <module>   s   U
    ^                      @   s   d Z dS )z0.15.6N)__version__ r   r   OC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-b620trd2\arrow\_version.py<module>       U
    ^                      @   sH   d dl mZ d dlmZmZmZ d dlmZ d dlm	Z	 d dl
mZ dS )   )__version__)getnowutcnow)Arrow)ArrowFactory)ParserErrorN)_versionr   apir   r   r   Zarrowr   factoryr   parserr    r   r   OC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-b620trd2\arrow\__init__.py<module>   s   # -*- coding: utf-8 -*-
"""
This module offers a generic easter computing method for any given year, using
Western, Orthodox or Julian algorithms.
"""

import datetime

__all__ = ["easter", "EASTER_JULIAN", "EASTER_ORTHODOX", "EASTER_WESTERN"]

EASTER_JULIAN = 1
EASTER_ORTHODOX = 2
EASTER_WESTERN = 3


def easter(year, method=EASTER_WESTERN):
    """
    This method was ported from the work done by GM Arts,
    on top of the algorithm by Claus Tondering, which was
    based in part on the algorithm of Ouding (1940), as
    quoted in "Explanatory Supplement to the Astronomical
    Almanac", P.  Kenneth Seidelmann, editor.

    This algorithm implements three different easter
    calculation methods:

    1 - Original calculation in Julian calendar, valid in
        dates after 326 AD
    2 - Original method, with date converted to Gregorian
        calendar, valid in years 1583 to 4099
    3 - Revised method, in Gregorian calendar, valid in
        years 1583 to 4099 as well

    These methods are represented by the constants:

    * ``EASTER_JULIAN   = 1``
    * ``EASTER_ORTHODOX = 2``
    * ``EASTER_WESTERN  = 3``

    The default method is method 3.

    More about the algorithm may be found at:

    `GM Arts: Easter Algorithms <http://www.gmarts.org/index.php?go=415>`_

    and

    `The Calendar FAQ: Easter <https://www.tondering.dk/claus/cal/easter.php>`_

    """

    if not (1 <= method <= 3):
        raise ValueError("invalid method")

    # g - Golden year - 1
    # c - Century
    # h - (23 - Epact) mod 30
    # i - Number of days from March 21 to Paschal Full Moon
    # j - Weekday for PFM (0=Sunday, etc)
    # p - Number of days from March 21 to Sunday on or before PFM
    #     (-6 to 28 methods 1 & 3, to 56 for method 2)
    # e - Extra days to add for method 2 (converting Julian
    #     date to Gregorian date)

    y = year
    g = y % 19
    e = 0
    if method < 3:
        # Old method
        i = (19*g + 15) % 30
        j = (y + y//4 + i) % 7
        if method == 2:
            # Extra dates to convert Julian to Gregorian date
            e = 10
            if y > 1600:
                e = e + y//100 - 16 - (y//100 - 16)//4
    else:
        # New method
        c = y//100
        h = (c - c//4 - (8*c + 13)//25 + 19*g + 15) % 30
        i = h - (h//28)*(1 - (h//28)*(29//(h + 1))*((21 - g)//11))
        j = (y + y//4 + i + 2 - c + c//4) % 7

    # p can be from -6 to 56 corresponding to dates 22 March to 23 May
    # (later dates apply to method 2, although 23 May never actually occurs)
    p = i - j + e
    d = 1 + (p + 27 + (p + 6)//40) % 31
    m = 3 + (p + 26)//30
    return datetime.date(int(y), int(m), int(d))
# -*- coding: utf-8 -*-
import datetime
import calendar

import operator
from math import copysign

from six import integer_types
from warnings import warn

from ._common import weekday

MO, TU, WE, TH, FR, SA, SU = weekdays = tuple(weekday(x) for x in range(7))

__all__ = ["relativedelta", "MO", "TU", "WE", "TH", "FR", "SA", "SU"]


class relativedelta(object):
    """
    The relativedelta type is designed to be applied to an existing datetime and
    can replace specific components of that datetime, or represents an interval
    of time.

    It is based on the specification of the excellent work done by M.-A. Lemburg
    in his
    `mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/>`_ extension.
    However, notice that this type does *NOT* implement the same algorithm as
    his work. Do *NOT* expect it to behave like mx.DateTime's counterpart.

    There are two different ways to build a relativedelta instance. The
    first one is passing it two date/datetime classes::

        relativedelta(datetime1, datetime2)

    The second one is passing it any number of the following keyword arguments::

        relativedelta(arg1=x,arg2=y,arg3=z...)

        year, month, day, hour, minute, second, microsecond:
            Absolute information (argument is singular); adding or subtracting a
            relativedelta with absolute information does not perform an arithmetic
            operation, but rather REPLACES the corresponding value in the
            original datetime with the value(s) in relativedelta.

        years, months, weeks, days, hours, minutes, seconds, microseconds:
            Relative information, may be negative (argument is plural); adding
            or subtracting a relativedelta with relative information performs
            the corresponding arithmetic operation on the original datetime value
            with the information in the relativedelta.

        weekday: 
            One of the weekday instances (MO, TU, etc) available in the
            relativedelta module. These instances may receive a parameter N,
            specifying the Nth weekday, which could be positive or negative
            (like MO(+1) or MO(-2)). Not specifying it is the same as specifying
            +1. You can also use an integer, where 0=MO. This argument is always
            relative e.g. if the calculated date is already Monday, using MO(1)
            or MO(-1) won't change the day. To effectively make it absolute, use
            it in combination with the day argument (e.g. day=1, MO(1) for first
            Monday of the month).

        leapdays:
            Will add given days to the date found, if year is a leap
            year, and the date found is post 28 of february.

        yearday, nlyearday:
            Set the yearday or the non-leap year day (jump leap days).
            These are converted to day/month/leapdays information.

    There are relative and absolute forms of the keyword
    arguments. The plural is relative, and the singular is
    absolute. For each argument in the order below, the absolute form
    is applied first (by setting each attribute to that value) and
    then the relative form (by adding the value to the attribute).

    The order of attributes considered when this relativedelta is
    added to a datetime is:

    1. Year
    2. Month
    3. Day
    4. Hours
    5. Minutes
    6. Seconds
    7. Microseconds

    Finally, weekday is applied, using the rule described above.

    For example

    >>> from datetime import datetime
    >>> from dateutil.relativedelta import relativedelta, MO
    >>> dt = datetime(2018, 4, 9, 13, 37, 0)
    >>> delta = relativedelta(hours=25, day=1, weekday=MO(1))
    >>> dt + delta
    datetime.datetime(2018, 4, 2, 14, 37)

    First, the day is set to 1 (the first of the month), then 25 hours
    are added, to get to the 2nd day and 14th hour, finally the
    weekday is applied, but since the 2nd is already a Monday there is
    no effect.

    """

    def __init__(self, dt1=None, dt2=None,
                 years=0, months=0, days=0, leapdays=0, weeks=0,
                 hours=0, minutes=0, seconds=0, microseconds=0,
                 year=None, month=None, day=None, weekday=None,
                 yearday=None, nlyearday=None,
                 hour=None, minute=None, second=None, microsecond=None):

        if dt1 and dt2:
            # datetime is a subclass of date. So both must be date
            if not (isinstance(dt1, datetime.date) and
                    isinstance(dt2, datetime.date)):
                raise TypeError("relativedelta only diffs datetime/date")

            # We allow two dates, or two datetimes, so we coerce them to be
            # of the same type
            if (isinstance(dt1, datetime.datetime) !=
                    isinstance(dt2, datetime.datetime)):
                if not isinstance(dt1, datetime.datetime):
                    dt1 = datetime.datetime.fromordinal(dt1.toordinal())
                elif not isinstance(dt2, datetime.datetime):
                    dt2 = datetime.datetime.fromordinal(dt2.toordinal())

            self.years = 0
            self.months = 0
            self.days = 0
            self.leapdays = 0
            self.hours = 0
            self.minutes = 0
            self.seconds = 0
            self.microseconds = 0
            self.year = None
            self.month = None
            self.day = None
            self.weekday = None
            self.hour = None
            self.minute = None
            self.second = None
            self.microsecond = None
            self._has_time = 0

            # Get year / month delta between the two
            months = (dt1.year - dt2.year) * 12 + (dt1.month - dt2.month)
            self._set_months(months)

            # Remove the year/month delta so the timedelta is just well-defined
            # time units (seconds, days and microseconds)
            dtm = self.__radd__(dt2)

            # If we've overshot our target, make an adjustment
            if dt1 < dt2:
                compare = operator.gt
                increment = 1
            else:
                compare = operator.lt
                increment = -1

            while compare(dt1, dtm):
                months += increment
                self._set_months(months)
                dtm = self.__radd__(dt2)

            # Get the timedelta between the "months-adjusted" date and dt1
            delta = dt1 - dtm
            self.seconds = delta.seconds + delta.days * 86400
            self.microseconds = delta.microseconds
        else:
            # Check for non-integer values in integer-only quantities
            if any(x is not None and x != int(x) for x in (years, months)):
                raise ValueError("Non-integer years and months are "
                                 "ambiguous and not currently supported.")

            # Relative information
            self.years = int(years)
            self.months = int(months)
            self.days = days + weeks * 7
            self.leapdays = leapdays
            self.hours = hours
            self.minutes = minutes
            self.seconds = seconds
            self.microseconds = microseconds

            # Absolute information
            self.year = year
            self.month = month
            self.day = day
            self.hour = hour
            self.minute = minute
            self.second = second
            self.microsecond = microsecond

            if any(x is not None and int(x) != x
                   for x in (year, month, day, hour,
                             minute, second, microsecond)):
                # For now we'll deprecate floats - later it'll be an error.
                warn("Non-integer value passed as absolute information. " +
                     "This is not a well-defined condition and will raise " +
                     "errors in future versions.", DeprecationWarning)

            if isinstance(weekday, integer_types):
                self.weekday = weekdays[weekday]
            else:
                self.weekday = weekday

            yday = 0
            if nlyearday:
                yday = nlyearday
            elif yearday:
                yday = yearday
                if yearday > 59:
                    self.leapdays = -1
            if yday:
                ydayidx = [31, 59, 90, 120, 151, 181, 212,
                           243, 273, 304, 334, 366]
                for idx, ydays in enumerate(ydayidx):
                    if yday <= ydays:
                        self.month = idx+1
                        if idx == 0:
                            self.day = yday
                        else:
                            self.day = yday-ydayidx[idx-1]
                        break
                else:
                    raise ValueError("invalid year day (%d)" % yday)

        self._fix()

    def _fix(self):
        if abs(self.microseconds) > 999999:
            s = _sign(self.microseconds)
            div, mod = divmod(self.microseconds * s, 1000000)
            self.microseconds = mod * s
            self.seconds += div * s
        if abs(self.seconds) > 59:
            s = _sign(self.seconds)
            div, mod = divmod(self.seconds * s, 60)
            self.seconds = mod * s
            self.minutes += div * s
        if abs(self.minutes) > 59:
            s = _sign(self.minutes)
            div, mod = divmod(self.minutes * s, 60)
            self.minutes = mod * s
            self.hours += div * s
        if abs(self.hours) > 23:
            s = _sign(self.hours)
            div, mod = divmod(self.hours * s, 24)
            self.hours = mod * s
            self.days += div * s
        if abs(self.months) > 11:
            s = _sign(self.months)
            div, mod = divmod(self.months * s, 12)
            self.months = mod * s
            self.years += div * s
        if (self.hours or self.minutes or self.seconds or self.microseconds
                or self.hour is not None or self.minute is not None or
                self.second is not None or self.microsecond is not None):
            self._has_time = 1
        else:
            self._has_time = 0

    @property
    def weeks(self):
        return int(self.days / 7.0)

    @weeks.setter
    def weeks(self, value):
        self.days = self.days - (self.weeks * 7) + value * 7

    def _set_months(self, months):
        self.months = months
        if abs(self.months) > 11:
            s = _sign(self.months)
            div, mod = divmod(self.months * s, 12)
            self.months = mod * s
            self.years = div * s
        else:
            self.years = 0

    def normalized(self):
        """
        Return a version of this object represented entirely using integer
        values for the relative attributes.

        >>> relativedelta(days=1.5, hours=2).normalized()
        relativedelta(days=+1, hours=+14)

        :return:
            Returns a :class:`dateutil.relativedelta.relativedelta` object.
        """
        # Cascade remainders down (rounding each to roughly nearest microsecond)
        days = int(self.days)

        hours_f = round(self.hours + 24 * (self.days - days), 11)
        hours = int(hours_f)

        minutes_f = round(self.minutes + 60 * (hours_f - hours), 10)
        minutes = int(minutes_f)

        seconds_f = round(self.seconds + 60 * (minutes_f - minutes), 8)
        seconds = int(seconds_f)

        microseconds = round(self.microseconds + 1e6 * (seconds_f - seconds))

        # Constructor carries overflow back up with call to _fix()
        return self.__class__(years=self.years, months=self.months,
                              days=days, hours=hours, minutes=minutes,
                              seconds=seconds, microseconds=microseconds,
                              leapdays=self.leapdays, year=self.year,
                              month=self.month, day=self.day,
                              weekday=self.weekday, hour=self.hour,
                              minute=self.minute, second=self.second,
                              microsecond=self.microsecond)

    def __add__(self, other):
        if isinstance(other, relativedelta):
            return self.__class__(years=other.years + self.years,
                                 months=other.months + self.months,
                                 days=other.days + self.days,
                                 hours=other.hours + self.hours,
                                 minutes=other.minutes + self.minutes,
                                 seconds=other.seconds + self.seconds,
                                 microseconds=(other.microseconds +
                                               self.microseconds),
                                 leapdays=other.leapdays or self.leapdays,
                                 year=(other.year if other.year is not None
                                       else self.year),
                                 month=(other.month if other.month is not None
                                        else self.month),
                                 day=(other.day if other.day is not None
                                      else self.day),
                                 weekday=(other.weekday if other.weekday is not None
                                          else self.weekday),
                                 hour=(other.hour if other.hour is not None
                                       else self.hour),
                                 minute=(other.minute if other.minute is not None
                                         else self.minute),
                                 second=(other.second if other.second is not None
                                         else self.second),
                                 microsecond=(other.microsecond if other.microsecond
                                              is not None else
                                              self.microsecond))
        if isinstance(other, datetime.timedelta):
            return self.__class__(years=self.years,
                                  months=self.months,
                                  days=self.days + other.days,
                                  hours=self.hours,
                                  minutes=self.minutes,
                                  seconds=self.seconds + other.seconds,
                                  microseconds=self.microseconds + other.microseconds,
                                  leapdays=self.leapdays,
                                  year=self.year,
                                  month=self.month,
                                  day=self.day,
                                  weekday=self.weekday,
                                  hour=self.hour,
                                  minute=self.minute,
                                  second=self.second,
                                  microsecond=self.microsecond)
        if not isinstance(other, datetime.date):
            return NotImplemented
        elif self._has_time and not isinstance(other, datetime.datetime):
            other = datetime.datetime.fromordinal(other.toordinal())
        year = (self.year or other.year)+self.years
        month = self.month or other.month
        if self.months:
            assert 1 <= abs(self.months) <= 12
            month += self.months
            if month > 12:
                year += 1
                month -= 12
            elif month < 1:
                year -= 1
                month += 12
        day = min(calendar.monthrange(year, month)[1],
                  self.day or other.day)
        repl = {"year": year, "month": month, "day": day}
        for attr in ["hour", "minute", "second", "microsecond"]:
            value = getattr(self, attr)
            if value is not None:
                repl[attr] = value
        days = self.days
        if self.leapdays and month > 2 and calendar.isleap(year):
            days += self.leapdays
        ret = (other.replace(**repl)
               + datetime.timedelta(days=days,
                                    hours=self.hours,
                                    minutes=self.minutes,
                                    seconds=self.seconds,
                                    microseconds=self.microseconds))
        if self.weekday:
            weekday, nth = self.weekday.weekday, self.weekday.n or 1
            jumpdays = (abs(nth) - 1) * 7
            if nth > 0:
                jumpdays += (7 - ret.weekday() + weekday) % 7
            else:
                jumpdays += (ret.weekday() - weekday) % 7
                jumpdays *= -1
            ret += datetime.timedelta(days=jumpdays)
        return ret

    def __radd__(self, other):
        return self.__add__(other)

    def __rsub__(self, other):
        return self.__neg__().__radd__(other)

    def __sub__(self, other):
        if not isinstance(other, relativedelta):
            return NotImplemented   # In case the other object defines __rsub__
        return self.__class__(years=self.years - other.years,
                             months=self.months - other.months,
                             days=self.days - other.days,
                             hours=self.hours - other.hours,
                             minutes=self.minutes - other.minutes,
                             seconds=self.seconds - other.seconds,
                             microseconds=self.microseconds - other.microseconds,
                             leapdays=self.leapdays or other.leapdays,
                             year=(self.year if self.year is not None
                                   else other.year),
                             month=(self.month if self.month is not None else
                                    other.month),
                             day=(self.day if self.day is not None else
                                  other.day),
                             weekday=(self.weekday if self.weekday is not None else
                                      other.weekday),
                             hour=(self.hour if self.hour is not None else
                                   other.hour),
                             minute=(self.minute if self.minute is not None else
                                     other.minute),
                             second=(self.second if self.second is not None else
                                     other.second),
                             microsecond=(self.microsecond if self.microsecond
                                          is not None else
                                          other.microsecond))

    def __abs__(self):
        return self.__class__(years=abs(self.years),
                              months=abs(self.months),
                              days=abs(self.days),
                              hours=abs(self.hours),
                              minutes=abs(self.minutes),
                              seconds=abs(self.seconds),
                              microseconds=abs(self.microseconds),
                              leapdays=self.leapdays,
                              year=self.year,
                              month=self.month,
                              day=self.day,
                              weekday=self.weekday,
                              hour=self.hour,
                              minute=self.minute,
                              second=self.second,
                              microsecond=self.microsecond)

    def __neg__(self):
        return self.__class__(years=-self.years,
                             months=-self.months,
                             days=-self.days,
                             hours=-self.hours,
                             minutes=-self.minutes,
                             seconds=-self.seconds,
                             microseconds=-self.microseconds,
                             leapdays=self.leapdays,
                             year=self.year,
                             month=self.month,
                             day=self.day,
                             weekday=self.weekday,
                             hour=self.hour,
                             minute=self.minute,
                             second=self.second,
                             microsecond=self.microsecond)

    def __bool__(self):
        return not (not self.years and
                    not self.months and
                    not self.days and
                    not self.hours and
                    not self.minutes and
                    not self.seconds and
                    not self.microseconds and
                    not self.leapdays and
                    self.year is None and
                    self.month is None and
                    self.day is None and
                    self.weekday is None and
                    self.hour is None and
                    self.minute is None and
                    self.second is None and
                    self.microsecond is None)
    # Compatibility with Python 2.x
    __nonzero__ = __bool__

    def __mul__(self, other):
        try:
            f = float(other)
        except TypeError:
            return NotImplemented

        return self.__class__(years=int(self.years * f),
                             months=int(self.months * f),
                             days=int(self.days * f),
                             hours=int(self.hours * f),
                             minutes=int(self.minutes * f),
                             seconds=int(self.seconds * f),
                             microseconds=int(self.microseconds * f),
                             leapdays=self.leapdays,
                             year=self.year,
                             month=self.month,
                             day=self.day,
                             weekday=self.weekday,
                             hour=self.hour,
                             minute=self.minute,
                             second=self.second,
                             microsecond=self.microsecond)

    __rmul__ = __mul__

    def __eq__(self, other):
        if not isinstance(other, relativedelta):
            return NotImplemented
        if self.weekday or other.weekday:
            if not self.weekday or not other.weekday:
                return False
            if self.weekday.weekday != other.weekday.weekday:
                return False
            n1, n2 = self.weekday.n, other.weekday.n
            if n1 != n2 and not ((not n1 or n1 == 1) and (not n2 or n2 == 1)):
                return False
        return (self.years == other.years and
                self.months == other.months and
                self.days == other.days and
                self.hours == other.hours and
                self.minutes == other.minutes and
                self.seconds == other.seconds and
                self.microseconds == other.microseconds and
                self.leapdays == other.leapdays and
                self.year == other.year and
                self.month == other.month and
                self.day == other.day and
                self.hour == other.hour and
                self.minute == other.minute and
                self.second == other.second and
                self.microsecond == other.microsecond)

    def __hash__(self):
        return hash((
            self.weekday,
            self.years,
            self.months,
            self.days,
            self.hours,
            self.minutes,
            self.seconds,
            self.microseconds,
            self.leapdays,
            self.year,
            self.month,
            self.day,
            self.hour,
            self.minute,
            self.second,
            self.microsecond,
        ))

    def __ne__(self, other):
        return not self.__eq__(other)

    def __div__(self, other):
        try:
            reciprocal = 1 / float(other)
        except TypeError:
            return NotImplemented

        return self.__mul__(reciprocal)

    __truediv__ = __div__

    def __repr__(self):
        l = []
        for attr in ["years", "months", "days", "leapdays",
                     "hours", "minutes", "seconds", "microseconds"]:
            value = getattr(self, attr)
            if value:
                l.append("{attr}={value:+g}".format(attr=attr, value=value))
        for attr in ["year", "month", "day", "weekday",
                     "hour", "minute", "second", "microsecond"]:
            value = getattr(self, attr)
            if value is not None:
                l.append("{attr}={value}".format(attr=attr, value=repr(value)))
        return "{classname}({attrs})".format(classname=self.__class__.__name__,
                                             attrs=", ".join(l))


def _sign(x):
    return int(copysign(1, x))

# vim:ts=4:sw=4:et
# -*- coding: utf-8 -*-
"""
The rrule module offers a small, complete, and very fast, implementation of
the recurrence rules documented in the
`iCalendar RFC <https://tools.ietf.org/html/rfc5545>`_,
including support for caching of results.
"""
import itertools
import datetime
import calendar
import re
import sys

try:
    from math import gcd
except ImportError:
    from fractions import gcd

from six import advance_iterator, integer_types
from six.moves import _thread, range
import heapq

from ._common import weekday as weekdaybase

# For warning about deprecation of until and count
from warnings import warn

__all__ = ["rrule", "rruleset", "rrulestr",
           "YEARLY", "MONTHLY", "WEEKLY", "DAILY",
           "HOURLY", "MINUTELY", "SECONDLY",
           "MO", "TU", "WE", "TH", "FR", "SA", "SU"]

# Every mask is 7 days longer to handle cross-year weekly periods.
M366MASK = tuple([1]*31+[2]*29+[3]*31+[4]*30+[5]*31+[6]*30 +
                 [7]*31+[8]*31+[9]*30+[10]*31+[11]*30+[12]*31+[1]*7)
M365MASK = list(M366MASK)
M29, M30, M31 = list(range(1, 30)), list(range(1, 31)), list(range(1, 32))
MDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])
MDAY365MASK = list(MDAY366MASK)
M29, M30, M31 = list(range(-29, 0)), list(range(-30, 0)), list(range(-31, 0))
NMDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])
NMDAY365MASK = list(NMDAY366MASK)
M366RANGE = (0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366)
M365RANGE = (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365)
WDAYMASK = [0, 1, 2, 3, 4, 5, 6]*55
del M29, M30, M31, M365MASK[59], MDAY365MASK[59], NMDAY365MASK[31]
MDAY365MASK = tuple(MDAY365MASK)
M365MASK = tuple(M365MASK)

FREQNAMES = ['YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY', 'HOURLY', 'MINUTELY', 'SECONDLY']

(YEARLY,
 MONTHLY,
 WEEKLY,
 DAILY,
 HOURLY,
 MINUTELY,
 SECONDLY) = list(range(7))

# Imported on demand.
easter = None
parser = None


class weekday(weekdaybase):
    """
    This version of weekday does not allow n = 0.
    """
    def __init__(self, wkday, n=None):
        if n == 0:
            raise ValueError("Can't create weekday with n==0")

        super(weekday, self).__init__(wkday, n)


MO, TU, WE, TH, FR, SA, SU = weekdays = tuple(weekday(x) for x in range(7))


def _invalidates_cache(f):
    """
    Decorator for rruleset methods which may invalidate the
    cached length.
    """
    def inner_func(self, *args, **kwargs):
        rv = f(self, *args, **kwargs)
        self._invalidate_cache()
        return rv

    return inner_func


class rrulebase(object):
    def __init__(self, cache=False):
        if cache:
            self._cache = []
            self._cache_lock = _thread.allocate_lock()
            self._invalidate_cache()
        else:
            self._cache = None
            self._cache_complete = False
            self._len = None

    def __iter__(self):
        if self._cache_complete:
            return iter(self._cache)
        elif self._cache is None:
            return self._iter()
        else:
            return self._iter_cached()

    def _invalidate_cache(self):
        if self._cache is not None:
            self._cache = []
            self._cache_complete = False
            self._cache_gen = self._iter()

            if self._cache_lock.locked():
                self._cache_lock.release()

        self._len = None

    def _iter_cached(self):
        i = 0
        gen = self._cache_gen
        cache = self._cache
        acquire = self._cache_lock.acquire
        release = self._cache_lock.release
        while gen:
            if i == len(cache):
                acquire()
                if self._cache_complete:
                    break
                try:
                    for j in range(10):
                        cache.append(advance_iterator(gen))
                except StopIteration:
                    self._cache_gen = gen = None
                    self._cache_complete = True
                    break
                release()
            yield cache[i]
            i += 1
        while i < self._len:
            yield cache[i]
            i += 1

    def __getitem__(self, item):
        if self._cache_complete:
            return self._cache[item]
        elif isinstance(item, slice):
            if item.step and item.step < 0:
                return list(iter(self))[item]
            else:
                return list(itertools.islice(self,
                                             item.start or 0,
                                             item.stop or sys.maxsize,
                                             item.step or 1))
        elif item >= 0:
            gen = iter(self)
            try:
                for i in range(item+1):
                    res = advance_iterator(gen)
            except StopIteration:
                raise IndexError
            return res
        else:
            return list(iter(self))[item]

    def __contains__(self, item):
        if self._cache_complete:
            return item in self._cache
        else:
            for i in self:
                if i == item:
                    return True
                elif i > item:
                    return False
        return False

    # __len__() introduces a large performance penalty.
    def count(self):
        """ Returns the number of recurrences in this set. It will have go
            trough the whole recurrence, if this hasn't been done before. """
        if self._len is None:
            for x in self:
                pass
        return self._len

    def before(self, dt, inc=False):
        """ Returns the last recurrence before the given datetime instance. The
            inc keyword defines what happens if dt is an occurrence. With
            inc=True, if dt itself is an occurrence, it will be returned. """
        if self._cache_complete:
            gen = self._cache
        else:
            gen = self
        last = None
        if inc:
            for i in gen:
                if i > dt:
                    break
                last = i
        else:
            for i in gen:
                if i >= dt:
                    break
                last = i
        return last

    def after(self, dt, inc=False):
        """ Returns the first recurrence after the given datetime instance. The
            inc keyword defines what happens if dt is an occurrence. With
            inc=True, if dt itself is an occurrence, it will be returned.  """
        if self._cache_complete:
            gen = self._cache
        else:
            gen = self
        if inc:
            for i in gen:
                if i >= dt:
                    return i
        else:
            for i in gen:
                if i > dt:
                    return i
        return None

    def xafter(self, dt, count=None, inc=False):
        """
        Generator which yields up to `count` recurrences after the given
        datetime instance, equivalent to `after`.

        :param dt:
            The datetime at which to start generating recurrences.

        :param count:
            The maximum number of recurrences to generate. If `None` (default),
            dates are generated until the recurrence rule is exhausted.

        :param inc:
            If `dt` is an instance of the rule and `inc` is `True`, it is
            included in the output.

        :yields: Yields a sequence of `datetime` objects.
        """

        if self._cache_complete:
            gen = self._cache
        else:
            gen = self

        # Select the comparison function
        if inc:
            comp = lambda dc, dtc: dc >= dtc
        else:
            comp = lambda dc, dtc: dc > dtc

        # Generate dates
        n = 0
        for d in gen:
            if comp(d, dt):
                if count is not None:
                    n += 1
                    if n > count:
                        break

                yield d

    def between(self, after, before, inc=False, count=1):
        """ Returns all the occurrences of the rrule between after and before.
        The inc keyword defines what happens if after and/or before are
        themselves occurrences. With inc=True, they will be included in the
        list, if they are found in the recurrence set. """
        if self._cache_complete:
            gen = self._cache
        else:
            gen = self
        started = False
        l = []
        if inc:
            for i in gen:
                if i > before:
                    break
                elif not started:
                    if i >= after:
                        started = True
                        l.append(i)
                else:
                    l.append(i)
        else:
            for i in gen:
                if i >= before:
                    break
                elif not started:
                    if i > after:
                        started = True
                        l.append(i)
                else:
                    l.append(i)
        return l


class rrule(rrulebase):
    """
    That's the base of the rrule operation. It accepts all the keywords
    defined in the RFC as its constructor parameters (except byday,
    which was renamed to byweekday) and more. The constructor prototype is::

            rrule(freq)

    Where freq must be one of YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY,
    or SECONDLY.

    .. note::
        Per RFC section 3.3.10, recurrence instances falling on invalid dates
        and times are ignored rather than coerced:

            Recurrence rules may generate recurrence instances with an invalid
            date (e.g., February 30) or nonexistent local time (e.g., 1:30 AM
            on a day where the local time is moved forward by an hour at 1:00
            AM).  Such recurrence instances MUST be ignored and MUST NOT be
            counted as part of the recurrence set.

        This can lead to possibly surprising behavior when, for example, the
        start date occurs at the end of the month:

        >>> from dateutil.rrule import rrule, MONTHLY
        >>> from datetime import datetime
        >>> start_date = datetime(2014, 12, 31)
        >>> list(rrule(freq=MONTHLY, count=4, dtstart=start_date))
        ... # doctest: +NORMALIZE_WHITESPACE
        [datetime.datetime(2014, 12, 31, 0, 0),
         datetime.datetime(2015, 1, 31, 0, 0),
         datetime.datetime(2015, 3, 31, 0, 0),
         datetime.datetime(2015, 5, 31, 0, 0)]

    Additionally, it supports the following keyword arguments:

    :param dtstart:
        The recurrence start. Besides being the base for the recurrence,
        missing parameters in the final recurrence instances will also be
        extracted from this date. If not given, datetime.now() will be used
        instead.
    :param interval:
        The interval between each freq iteration. For example, when using
        YEARLY, an interval of 2 means once every two years, but with HOURLY,
        it means once every two hours. The default interval is 1.
    :param wkst:
        The week start day. Must be one of the MO, TU, WE constants, or an
        integer, specifying the first day of the week. This will affect
        recurrences based on weekly periods. The default week start is got
        from calendar.firstweekday(), and may be modified by
        calendar.setfirstweekday().
    :param count:
        If given, this determines how many occurrences will be generated.

        .. note::
            As of version 2.5.0, the use of the keyword ``until`` in conjunction
            with ``count`` is deprecated, to make sure ``dateutil`` is fully
            compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/
            html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``
            **must not** occur in the same call to ``rrule``.
    :param until:
        If given, this must be a datetime instance specifying the upper-bound
        limit of the recurrence. The last recurrence in the rule is the greatest
        datetime that is less than or equal to the value specified in the
        ``until`` parameter.

        .. note::
            As of version 2.5.0, the use of the keyword ``until`` in conjunction
            with ``count`` is deprecated, to make sure ``dateutil`` is fully
            compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/
            html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``
            **must not** occur in the same call to ``rrule``.
    :param bysetpos:
        If given, it must be either an integer, or a sequence of integers,
        positive or negative. Each given integer will specify an occurrence
        number, corresponding to the nth occurrence of the rule inside the
        frequency period. For example, a bysetpos of -1 if combined with a
        MONTHLY frequency, and a byweekday of (MO, TU, WE, TH, FR), will
        result in the last work day of every month.
    :param bymonth:
        If given, it must be either an integer, or a sequence of integers,
        meaning the months to apply the recurrence to.
    :param bymonthday:
        If given, it must be either an integer, or a sequence of integers,
        meaning the month days to apply the recurrence to.
    :param byyearday:
        If given, it must be either an integer, or a sequence of integers,
        meaning the year days to apply the recurrence to.
    :param byeaster:
        If given, it must be either an integer, or a sequence of integers,
        positive or negative. Each integer will define an offset from the
        Easter Sunday. Passing the offset 0 to byeaster will yield the Easter
        Sunday itself. This is an extension to the RFC specification.
    :param byweekno:
        If given, it must be either an integer, or a sequence of integers,
        meaning the week numbers to apply the recurrence to. Week numbers
        have the meaning described in ISO8601, that is, the first week of
        the year is that containing at least four days of the new year.
    :param byweekday:
        If given, it must be either an integer (0 == MO), a sequence of
        integers, one of the weekday constants (MO, TU, etc), or a sequence
        of these constants. When given, these variables will define the
        weekdays where the recurrence will be applied. It's also possible to
        use an argument n for the weekday instances, which will mean the nth
        occurrence of this weekday in the period. For example, with MONTHLY,
        or with YEARLY and BYMONTH, using FR(+1) in byweekday will specify the
        first friday of the month where the recurrence happens. Notice that in
        the RFC documentation, this is specified as BYDAY, but was renamed to
        avoid the ambiguity of that keyword.
    :param byhour:
        If given, it must be either an integer, or a sequence of integers,
        meaning the hours to apply the recurrence to.
    :param byminute:
        If given, it must be either an integer, or a sequence of integers,
        meaning the minutes to apply the recurrence to.
    :param bysecond:
        If given, it must be either an integer, or a sequence of integers,
        meaning the seconds to apply the recurrence to.
    :param cache:
        If given, it must be a boolean value specifying to enable or disable
        caching of results. If you will use the same rrule instance multiple
        times, enabling caching will improve the performance considerably.
     """
    def __init__(self, freq, dtstart=None,
                 interval=1, wkst=None, count=None, until=None, bysetpos=None,
                 bymonth=None, bymonthday=None, byyearday=None, byeaster=None,
                 byweekno=None, byweekday=None,
                 byhour=None, byminute=None, bysecond=None,
                 cache=False):
        super(rrule, self).__init__(cache)
        global easter
        if not dtstart:
            if until and until.tzinfo:
                dtstart = datetime.datetime.now(tz=until.tzinfo).replace(microsecond=0)
            else:
                dtstart = datetime.datetime.now().replace(microsecond=0)
        elif not isinstance(dtstart, datetime.datetime):
            dtstart = datetime.datetime.fromordinal(dtstart.toordinal())
        else:
            dtstart = dtstart.replace(microsecond=0)
        self._dtstart = dtstart
        self._tzinfo = dtstart.tzinfo
        self._freq = freq
        self._interval = interval
        self._count = count

        # Cache the original byxxx rules, if they are provided, as the _byxxx
        # attributes do not necessarily map to the inputs, and this can be
        # a problem in generating the strings. Only store things if they've
        # been supplied (the string retrieval will just use .get())
        self._original_rule = {}

        if until and not isinstance(until, datetime.datetime):
            until = datetime.datetime.fromordinal(until.toordinal())
        self._until = until

        if self._dtstart and self._until:
            if (self._dtstart.tzinfo is not None) != (self._until.tzinfo is not None):
                # According to RFC5545 Section 3.3.10:
                # https://tools.ietf.org/html/rfc5545#section-3.3.10
                #
                # > If the "DTSTART" property is specified as a date with UTC
                # > time or a date with local time and time zone reference,
                # > then the UNTIL rule part MUST be specified as a date with
                # > UTC time.
                raise ValueError(
                    'RRULE UNTIL values must be specified in UTC when DTSTART '
                    'is timezone-aware'
                )

        if count is not None and until:
            warn("Using both 'count' and 'until' is inconsistent with RFC 5545"
                 " and has been deprecated in dateutil. Future versions will "
                 "raise an error.", DeprecationWarning)

        if wkst is None:
            self._wkst = calendar.firstweekday()
        elif isinstance(wkst, integer_types):
            self._wkst = wkst
        else:
            self._wkst = wkst.weekday

        if bysetpos is None:
            self._bysetpos = None
        elif isinstance(bysetpos, integer_types):
            if bysetpos == 0 or not (-366 <= bysetpos <= 366):
                raise ValueError("bysetpos must be between 1 and 366, "
                                 "or between -366 and -1")
            self._bysetpos = (bysetpos,)
        else:
            self._bysetpos = tuple(bysetpos)
            for pos in self._bysetpos:
                if pos == 0 or not (-366 <= pos <= 366):
                    raise ValueError("bysetpos must be between 1 and 366, "
                                     "or between -366 and -1")

        if self._bysetpos:
            self._original_rule['bysetpos'] = self._bysetpos

        if (byweekno is None and byyearday is None and bymonthday is None and
                byweekday is None and byeaster is None):
            if freq == YEARLY:
                if bymonth is None:
                    bymonth = dtstart.month
                    self._original_rule['bymonth'] = None
                bymonthday = dtstart.day
                self._original_rule['bymonthday'] = None
            elif freq == MONTHLY:
                bymonthday = dtstart.day
                self._original_rule['bymonthday'] = None
            elif freq == WEEKLY:
                byweekday = dtstart.weekday()
                self._original_rule['byweekday'] = None

        # bymonth
        if bymonth is None:
            self._bymonth = None
        else:
            if isinstance(bymonth, integer_types):
                bymonth = (bymonth,)

            self._bymonth = tuple(sorted(set(bymonth)))

            if 'bymonth' not in self._original_rule:
                self._original_rule['bymonth'] = self._bymonth

        # byyearday
        if byyearday is None:
            self._byyearday = None
        else:
            if isinstance(byyearday, integer_types):
                byyearday = (byyearday,)

            self._byyearday = tuple(sorted(set(byyearday)))
            self._original_rule['byyearday'] = self._byyearday

        # byeaster
        if byeaster is not None:
            if not easter:
                from dateutil import easter
            if isinstance(byeaster, integer_types):
                self._byeaster = (byeaster,)
            else:
                self._byeaster = tuple(sorted(byeaster))

            self._original_rule['byeaster'] = self._byeaster
        else:
            self._byeaster = None

        # bymonthday
        if bymonthday is None:
            self._bymonthday = ()
            self._bynmonthday = ()
        else:
            if isinstance(bymonthday, integer_types):
                bymonthday = (bymonthday,)

            bymonthday = set(bymonthday)            # Ensure it's unique

            self._bymonthday = tuple(sorted(x for x in bymonthday if x > 0))
            self._bynmonthday = tuple(sorted(x for x in bymonthday if x < 0))

            # Storing positive numbers first, then negative numbers
            if 'bymonthday' not in self._original_rule:
                self._original_rule['bymonthday'] = tuple(
                    itertools.chain(self._bymonthday, self._bynmonthday))

        # byweekno
        if byweekno is None:
            self._byweekno = None
        else:
            if isinstance(byweekno, integer_types):
                byweekno = (byweekno,)

            self._byweekno = tuple(sorted(set(byweekno)))

            self._original_rule['byweekno'] = self._byweekno

        # byweekday / bynweekday
        if byweekday is None:
            self._byweekday = None
            self._bynweekday = None
        else:
            # If it's one of the valid non-sequence types, convert to a
            # single-element sequence before the iterator that builds the
            # byweekday set.
            if isinstance(byweekday, integer_types) or hasattr(byweekday, "n"):
                byweekday = (byweekday,)

            self._byweekday = set()
            self._bynweekday = set()
            for wday in byweekday:
                if isinstance(wday, integer_types):
                    self._byweekday.add(wday)
                elif not wday.n or freq > MONTHLY:
                    self._byweekday.add(wday.weekday)
                else:
                    self._bynweekday.add((wday.weekday, wday.n))

            if not self._byweekday:
                self._byweekday = None
            elif not self._bynweekday:
                self._bynweekday = None

            if self._byweekday is not None:
                self._byweekday = tuple(sorted(self._byweekday))
                orig_byweekday = [weekday(x) for x in self._byweekday]
            else:
                orig_byweekday = ()

            if self._bynweekday is not None:
                self._bynweekday = tuple(sorted(self._bynweekday))
                orig_bynweekday = [weekday(*x) for x in self._bynweekday]
            else:
                orig_bynweekday = ()

            if 'byweekday' not in self._original_rule:
                self._original_rule['byweekday'] = tuple(itertools.chain(
                    orig_byweekday, orig_bynweekday))

        # byhour
        if byhour is None:
            if freq < HOURLY:
                self._byhour = {dtstart.hour}
            else:
                self._byhour = None
        else:
            if isinstance(byhour, integer_types):
                byhour = (byhour,)

            if freq == HOURLY:
                self._byhour = self.__construct_byset(start=dtstart.hour,
                                                      byxxx=byhour,
                                                      base=24)
            else:
                self._byhour = set(byhour)

            self._byhour = tuple(sorted(self._byhour))
            self._original_rule['byhour'] = self._byhour

        # byminute
        if byminute is None:
            if freq < MINUTELY:
                self._byminute = {dtstart.minute}
            else:
                self._byminute = None
        else:
            if isinstance(byminute, integer_types):
                byminute = (byminute,)

            if freq == MINUTELY:
                self._byminute = self.__construct_byset(start=dtstart.minute,
                                                        byxxx=byminute,
                                                        base=60)
            else:
                self._byminute = set(byminute)

            self._byminute = tuple(sorted(self._byminute))
            self._original_rule['byminute'] = self._byminute

        # bysecond
        if bysecond is None:
            if freq < SECONDLY:
                self._bysecond = ((dtstart.second,))
            else:
                self._bysecond = None
        else:
            if isinstance(bysecond, integer_types):
                bysecond = (bysecond,)

            self._bysecond = set(bysecond)

            if freq == SECONDLY:
                self._bysecond = self.__construct_byset(start=dtstart.second,
                                                        byxxx=bysecond,
                                                        base=60)
            else:
                self._bysecond = set(bysecond)

            self._bysecond = tuple(sorted(self._bysecond))
            self._original_rule['bysecond'] = self._bysecond

        if self._freq >= HOURLY:
            self._timeset = None
        else:
            self._timeset = []
            for hour in self._byhour:
                for minute in self._byminute:
                    for second in self._bysecond:
                        self._timeset.append(
                            datetime.time(hour, minute, second,
                                          tzinfo=self._tzinfo))
            self._timeset.sort()
            self._timeset = tuple(self._timeset)

    def __str__(self):
        """
        Output a string that would generate this RRULE if passed to rrulestr.
        This is mostly compatible with RFC5545, except for the
        dateutil-specific extension BYEASTER.
        """

        output = []
        h, m, s = [None] * 3
        if self._dtstart:
            output.append(self._dtstart.strftime('DTSTART:%Y%m%dT%H%M%S'))
            h, m, s = self._dtstart.timetuple()[3:6]

        parts = ['FREQ=' + FREQNAMES[self._freq]]
        if self._interval != 1:
            parts.append('INTERVAL=' + str(self._interval))

        if self._wkst:
            parts.append('WKST=' + repr(weekday(self._wkst))[0:2])

        if self._count is not None:
            parts.append('COUNT=' + str(self._count))

        if self._until:
            parts.append(self._until.strftime('UNTIL=%Y%m%dT%H%M%S'))

        if self._original_rule.get('byweekday') is not None:
            # The str() method on weekday objects doesn't generate
            # RFC5545-compliant strings, so we should modify that.
            original_rule = dict(self._original_rule)
            wday_strings = []
            for wday in original_rule['byweekday']:
                if wday.n:
                    wday_strings.append('{n:+d}{wday}'.format(
                        n=wday.n,
                        wday=repr(wday)[0:2]))
                else:
                    wday_strings.append(repr(wday))

            original_rule['byweekday'] = wday_strings
        else:
            original_rule = self._original_rule

        partfmt = '{name}={vals}'
        for name, key in [('BYSETPOS', 'bysetpos'),
                          ('BYMONTH', 'bymonth'),
                          ('BYMONTHDAY', 'bymonthday'),
                          ('BYYEARDAY', 'byyearday'),
                          ('BYWEEKNO', 'byweekno'),
                          ('BYDAY', 'byweekday'),
                          ('BYHOUR', 'byhour'),
                          ('BYMINUTE', 'byminute'),
                          ('BYSECOND', 'bysecond'),
                          ('BYEASTER', 'byeaster')]:
            value = original_rule.get(key)
            if value:
                parts.append(partfmt.format(name=name, vals=(','.join(str(v)
                                                             for v in value))))

        output.append('RRULE:' + ';'.join(parts))
        return '\n'.join(output)

    def replace(self, **kwargs):
        """Return new rrule with same attributes except for those attributes given new
           values by whichever keyword arguments are specified."""
        new_kwargs = {"interval": self._interval,
                      "count": self._count,
                      "dtstart": self._dtstart,
                      "freq": self._freq,
                      "until": self._until,
                      "wkst": self._wkst,
                      "cache": False if self._cache is None else True }
        new_kwargs.update(self._original_rule)
        new_kwargs.update(kwargs)
        return rrule(**new_kwargs)

    def _iter(self):
        year, month, day, hour, minute, second, weekday, yearday, _ = \
            self._dtstart.timetuple()

        # Some local variables to speed things up a bit
        freq = self._freq
        interval = self._interval
        wkst = self._wkst
        until = self._until
        bymonth = self._bymonth
        byweekno = self._byweekno
        byyearday = self._byyearday
        byweekday = self._byweekday
        byeaster = self._byeaster
        bymonthday = self._bymonthday
        bynmonthday = self._bynmonthday
        bysetpos = self._bysetpos
        byhour = self._byhour
        byminute = self._byminute
        bysecond = self._bysecond

        ii = _iterinfo(self)
        ii.rebuild(year, month)

        getdayset = {YEARLY: ii.ydayset,
                     MONTHLY: ii.mdayset,
                     WEEKLY: ii.wdayset,
                     DAILY: ii.ddayset,
                     HOURLY: ii.ddayset,
                     MINUTELY: ii.ddayset,
                     SECONDLY: ii.ddayset}[freq]

        if freq < HOURLY:
            timeset = self._timeset
        else:
            gettimeset = {HOURLY: ii.htimeset,
                          MINUTELY: ii.mtimeset,
                          SECONDLY: ii.stimeset}[freq]
            if ((freq >= HOURLY and
                 self._byhour and hour not in self._byhour) or
                (freq >= MINUTELY and
                 self._byminute and minute not in self._byminute) or
                (freq >= SECONDLY and
                 self._bysecond and second not in self._bysecond)):
                timeset = ()
            else:
                timeset = gettimeset(hour, minute, second)

        total = 0
        count = self._count
        while True:
            # Get dayset with the right frequency
            dayset, start, end = getdayset(year, month, day)

            # Do the "hard" work ;-)
            filtered = False
            for i in dayset[start:end]:
                if ((bymonth and ii.mmask[i] not in bymonth) or
                    (byweekno and not ii.wnomask[i]) or
                    (byweekday and ii.wdaymask[i] not in byweekday) or
                    (ii.nwdaymask and not ii.nwdaymask[i]) or
                    (byeaster and not ii.eastermask[i]) or
                    ((bymonthday or bynmonthday) and
                     ii.mdaymask[i] not in bymonthday and
                     ii.nmdaymask[i] not in bynmonthday) or
                    (byyearday and
                     ((i < ii.yearlen and i+1 not in byyearday and
                       -ii.yearlen+i not in byyearday) or
                      (i >= ii.yearlen and i+1-ii.yearlen not in byyearday and
                       -ii.nextyearlen+i-ii.yearlen not in byyearday)))):
                    dayset[i] = None
                    filtered = True

            # Output results
            if bysetpos and timeset:
                poslist = []
                for pos in bysetpos:
                    if pos < 0:
                        daypos, timepos = divmod(pos, len(timeset))
                    else:
                        daypos, timepos = divmod(pos-1, len(timeset))
                    try:
                        i = [x for x in dayset[start:end]
                             if x is not None][daypos]
                        time = timeset[timepos]
                    except IndexError:
                        pass
                    else:
                        date = datetime.date.fromordinal(ii.yearordinal+i)
                        res = datetime.datetime.combine(date, time)
                        if res not in poslist:
                            poslist.append(res)
                poslist.sort()
                for res in poslist:
                    if until and res > until:
                        self._len = total
                        return
                    elif res >= self._dtstart:
                        if count is not None:
                            count -= 1
                            if count < 0:
                                self._len = total
                                return
                        total += 1
                        yield res
            else:
                for i in dayset[start:end]:
                    if i is not None:
                        date = datetime.date.fromordinal(ii.yearordinal + i)
                        for time in timeset:
                            res = datetime.datetime.combine(date, time)
                            if until and res > until:
                                self._len = total
                                return
                            elif res >= self._dtstart:
                                if count is not None:
                                    count -= 1
                                    if count < 0:
                                        self._len = total
                                        return

                                total += 1
                                yield res

            # Handle frequency and interval
            fixday = False
            if freq == YEARLY:
                year += interval
                if year > datetime.MAXYEAR:
                    self._len = total
                    return
                ii.rebuild(year, month)
            elif freq == MONTHLY:
                month += interval
                if month > 12:
                    div, mod = divmod(month, 12)
                    month = mod
                    year += div
                    if month == 0:
                        month = 12
                        year -= 1
                    if year > datetime.MAXYEAR:
                        self._len = total
                        return
                ii.rebuild(year, month)
            elif freq == WEEKLY:
                if wkst > weekday:
                    day += -(weekday+1+(6-wkst))+self._interval*7
                else:
                    day += -(weekday-wkst)+self._interval*7
                weekday = wkst
                fixday = True
            elif freq == DAILY:
                day += interval
                fixday = True
            elif freq == HOURLY:
                if filtered:
                    # Jump to one iteration before next day
                    hour += ((23-hour)//interval)*interval

                if byhour:
                    ndays, hour = self.__mod_distance(value=hour,
                                                      byxxx=self._byhour,
                                                      base=24)
                else:
                    ndays, hour = divmod(hour+interval, 24)

                if ndays:
                    day += ndays
                    fixday = True

                timeset = gettimeset(hour, minute, second)
            elif freq == MINUTELY:
                if filtered:
                    # Jump to one iteration before next day
                    minute += ((1439-(hour*60+minute))//interval)*interval

                valid = False
                rep_rate = (24*60)
                for j in range(rep_rate // gcd(interval, rep_rate)):
                    if byminute:
                        nhours, minute = \
                            self.__mod_distance(value=minute,
                                                byxxx=self._byminute,
                                                base=60)
                    else:
                        nhours, minute = divmod(minute+interval, 60)

                    div, hour = divmod(hour+nhours, 24)
                    if div:
                        day += div
                        fixday = True
                        filtered = False

                    if not byhour or hour in byhour:
                        valid = True
                        break

                if not valid:
                    raise ValueError('Invalid combination of interval and ' +
                                     'byhour resulting in empty rule.')

                timeset = gettimeset(hour, minute, second)
            elif freq == SECONDLY:
                if filtered:
                    # Jump to one iteration before next day
                    second += (((86399 - (hour * 3600 + minute * 60 + second))
                                // interval) * interval)

                rep_rate = (24 * 3600)
                valid = False
                for j in range(0, rep_rate // gcd(interval, rep_rate)):
                    if bysecond:
                        nminutes, second = \
                            self.__mod_distance(value=second,
                                                byxxx=self._bysecond,
                                                base=60)
                    else:
                        nminutes, second = divmod(second+interval, 60)

                    div, minute = divmod(minute+nminutes, 60)
                    if div:
                        hour += div
                        div, hour = divmod(hour, 24)
                        if div:
                            day += div
                            fixday = True

                    if ((not byhour or hour in byhour) and
                            (not byminute or minute in byminute) and
                            (not bysecond or second in bysecond)):
                        valid = True
                        break

                if not valid:
                    raise ValueError('Invalid combination of interval, ' +
                                     'byhour and byminute resulting in empty' +
                                     ' rule.')

                timeset = gettimeset(hour, minute, second)

            if fixday and day > 28:
                daysinmonth = calendar.monthrange(year, month)[1]
                if day > daysinmonth:
                    while day > daysinmonth:
                        day -= daysinmonth
                        month += 1
                        if month == 13:
                            month = 1
                            year += 1
                            if year > datetime.MAXYEAR:
                                self._len = total
                                return
                        daysinmonth = calendar.monthrange(year, month)[1]
                    ii.rebuild(year, month)

    def __construct_byset(self, start, byxxx, base):
        """
        If a `BYXXX` sequence is passed to the constructor at the same level as
        `FREQ` (e.g. `FREQ=HOURLY,BYHOUR={2,4,7},INTERVAL=3`), there are some
        specifications which cannot be reached given some starting conditions.

        This occurs whenever the interval is not coprime with the base of a
        given unit and the difference between the starting position and the
        ending position is not coprime with the greatest common denominator
        between the interval and the base. For example, with a FREQ of hourly
        starting at 17:00 and an interval of 4, the only valid values for
        BYHOUR would be {21, 1, 5, 9, 13, 17}, because 4 and 24 are not
        coprime.

        :param start:
            Specifies the starting position.
        :param byxxx:
            An iterable containing the list of allowed values.
        :param base:
            The largest allowable value for the specified frequency (e.g.
            24 hours, 60 minutes).

        This does not preserve the type of the iterable, returning a set, since
        the values should be unique and the order is irrelevant, this will
        speed up later lookups.

        In the event of an empty set, raises a :exception:`ValueError`, as this
        results in an empty rrule.
        """

        cset = set()

        # Support a single byxxx value.
        if isinstance(byxxx, integer_types):
            byxxx = (byxxx, )

        for num in byxxx:
            i_gcd = gcd(self._interval, base)
            # Use divmod rather than % because we need to wrap negative nums.
            if i_gcd == 1 or divmod(num - start, i_gcd)[1] == 0:
                cset.add(num)

        if len(cset) == 0:
            raise ValueError("Invalid rrule byxxx generates an empty set.")

        return cset

    def __mod_distance(self, value, byxxx, base):
        """
        Calculates the next value in a sequence where the `FREQ` parameter is
        specified along with a `BYXXX` parameter at the same "level"
        (e.g. `HOURLY` specified with `BYHOUR`).

        :param value:
            The old value of the component.
        :param byxxx:
            The `BYXXX` set, which should have been generated by
            `rrule._construct_byset`, or something else which checks that a
            valid rule is present.
        :param base:
            The largest allowable value for the specified frequency (e.g.
            24 hours, 60 minutes).

        If a valid value is not found after `base` iterations (the maximum
        number before the sequence would start to repeat), this raises a
        :exception:`ValueError`, as no valid values were found.

        This returns a tuple of `divmod(n*interval, base)`, where `n` is the
        smallest number of `interval` repetitions until the next specified
        value in `byxxx` is found.
        """
        accumulator = 0
        for ii in range(1, base + 1):
            # Using divmod() over % to account for negative intervals
            div, value = divmod(value + self._interval, base)
            accumulator += div
            if value in byxxx:
                return (accumulator, value)


class _iterinfo(object):
    __slots__ = ["rrule", "lastyear", "lastmonth",
                 "yearlen", "nextyearlen", "yearordinal", "yearweekday",
                 "mmask", "mrange", "mdaymask", "nmdaymask",
                 "wdaymask", "wnomask", "nwdaymask", "eastermask"]

    def __init__(self, rrule):
        for attr in self.__slots__:
            setattr(self, attr, None)
        self.rrule = rrule

    def rebuild(self, year, month):
        # Every mask is 7 days longer to handle cross-year weekly periods.
        rr = self.rrule
        if year != self.lastyear:
            self.yearlen = 365 + calendar.isleap(year)
            self.nextyearlen = 365 + calendar.isleap(year + 1)
            firstyday = datetime.date(year, 1, 1)
            self.yearordinal = firstyday.toordinal()
            self.yearweekday = firstyday.weekday()

            wday = datetime.date(year, 1, 1).weekday()
            if self.yearlen == 365:
                self.mmask = M365MASK
                self.mdaymask = MDAY365MASK
                self.nmdaymask = NMDAY365MASK
                self.wdaymask = WDAYMASK[wday:]
                self.mrange = M365RANGE
            else:
                self.mmask = M366MASK
                self.mdaymask = MDAY366MASK
                self.nmdaymask = NMDAY366MASK
                self.wdaymask = WDAYMASK[wday:]
                self.mrange = M366RANGE

            if not rr._byweekno:
                self.wnomask = None
            else:
                self.wnomask = [0]*(self.yearlen+7)
                # no1wkst = firstwkst = self.wdaymask.index(rr._wkst)
                no1wkst = firstwkst = (7-self.yearweekday+rr._wkst) % 7
                if no1wkst >= 4:
                    no1wkst = 0
                    # Number of days in the year, plus the days we got
                    # from last year.
                    wyearlen = self.yearlen+(self.yearweekday-rr._wkst) % 7
                else:
                    # Number of days in the year, minus the days we
                    # left in last year.
                    wyearlen = self.yearlen-no1wkst
                div, mod = divmod(wyearlen, 7)
                numweeks = div+mod//4
                for n in rr._byweekno:
                    if n < 0:
                        n += numweeks+1
                    if not (0 < n <= numweeks):
                        continue
                    if n > 1:
                        i = no1wkst+(n-1)*7
                        if no1wkst != firstwkst:
                            i -= 7-firstwkst
                    else:
                        i = no1wkst
                    for j in range(7):
                        self.wnomask[i] = 1
                        i += 1
                        if self.wdaymask[i] == rr._wkst:
                            break
                if 1 in rr._byweekno:
                    # Check week number 1 of next year as well
                    # TODO: Check -numweeks for next year.
                    i = no1wkst+numweeks*7
                    if no1wkst != firstwkst:
                        i -= 7-firstwkst
                    if i < self.yearlen:
                        # If week starts in next year, we
                        # don't care about it.
                        for j in range(7):
                            self.wnomask[i] = 1
                            i += 1
                            if self.wdaymask[i] == rr._wkst:
                                break
                if no1wkst:
                    # Check last week number of last year as
                    # well. If no1wkst is 0, either the year
                    # started on week start, or week number 1
                    # got days from last year, so there are no
                    # days from last year's last week number in
                    # this year.
                    if -1 not in rr._byweekno:
                        lyearweekday = datetime.date(year-1, 1, 1).weekday()
                        lno1wkst = (7-lyearweekday+rr._wkst) % 7
                        lyearlen = 365+calendar.isleap(year-1)
                        if lno1wkst >= 4:
                            lno1wkst = 0
                            lnumweeks = 52+(lyearlen +
                                            (lyearweekday-rr._wkst) % 7) % 7//4
                        else:
                            lnumweeks = 52+(self.yearlen-no1wkst) % 7//4
                    else:
                        lnumweeks = -1
                    if lnumweeks in rr._byweekno:
                        for i in range(no1wkst):
                            self.wnomask[i] = 1

        if (rr._bynweekday and (month != self.lastmonth or
                                year != self.lastyear)):
            ranges = []
            if rr._freq == YEARLY:
                if rr._bymonth:
                    for month in rr._bymonth:
                        ranges.append(self.mrange[month-1:month+1])
                else:
                    ranges = [(0, self.yearlen)]
            elif rr._freq == MONTHLY:
                ranges = [self.mrange[month-1:month+1]]
            if ranges:
                # Weekly frequency won't get here, so we may not
                # care about cross-year weekly periods.
                self.nwdaymask = [0]*self.yearlen
                for first, last in ranges:
                    last -= 1
                    for wday, n in rr._bynweekday:
                        if n < 0:
                            i = last+(n+1)*7
                            i -= (self.wdaymask[i]-wday) % 7
                        else:
                            i = first+(n-1)*7
                            i += (7-self.wdaymask[i]+wday) % 7
                        if first <= i <= last:
                            self.nwdaymask[i] = 1

        if rr._byeaster:
            self.eastermask = [0]*(self.yearlen+7)
            eyday = easter.easter(year).toordinal()-self.yearordinal
            for offset in rr._byeaster:
                self.eastermask[eyday+offset] = 1

        self.lastyear = year
        self.lastmonth = month

    def ydayset(self, year, month, day):
        return list(range(self.yearlen)), 0, self.yearlen

    def mdayset(self, year, month, day):
        dset = [None]*self.yearlen
        start, end = self.mrange[month-1:month+1]
        for i in range(start, end):
            dset[i] = i
        return dset, start, end

    def wdayset(self, year, month, day):
        # We need to handle cross-year weeks here.
        dset = [None]*(self.yearlen+7)
        i = datetime.date(year, month, day).toordinal()-self.yearordinal
        start = i
        for j in range(7):
            dset[i] = i
            i += 1
            # if (not (0 <= i < self.yearlen) or
            #    self.wdaymask[i] == self.rrule._wkst):
            # This will cross the year boundary, if necessary.
            if self.wdaymask[i] == self.rrule._wkst:
                break
        return dset, start, i

    def ddayset(self, year, month, day):
        dset = [None] * self.yearlen
        i = datetime.date(year, month, day).toordinal() - self.yearordinal
        dset[i] = i
        return dset, i, i + 1

    def htimeset(self, hour, minute, second):
        tset = []
        rr = self.rrule
        for minute in rr._byminute:
            for second in rr._bysecond:
                tset.append(datetime.time(hour, minute, second,
                                          tzinfo=rr._tzinfo))
        tset.sort()
        return tset

    def mtimeset(self, hour, minute, second):
        tset = []
        rr = self.rrule
        for second in rr._bysecond:
            tset.append(datetime.time(hour, minute, second, tzinfo=rr._tzinfo))
        tset.sort()
        return tset

    def stimeset(self, hour, minute, second):
        return (datetime.time(hour, minute, second,
                tzinfo=self.rrule._tzinfo),)


class rruleset(rrulebase):
    """ The rruleset type allows more complex recurrence setups, mixing
    multiple rules, dates, exclusion rules, and exclusion dates. The type
    constructor takes the following keyword arguments:

    :param cache: If True, caching of results will be enabled, improving
                  performance of multiple queries considerably. """

    class _genitem(object):
        def __init__(self, genlist, gen):
            try:
                self.dt = advance_iterator(gen)
                genlist.append(self)
            except StopIteration:
                pass
            self.genlist = genlist
            self.gen = gen

        def __next__(self):
            try:
                self.dt = advance_iterator(self.gen)
            except StopIteration:
                if self.genlist[0] is self:
                    heapq.heappop(self.genlist)
                else:
                    self.genlist.remove(self)
                    heapq.heapify(self.genlist)

        next = __next__

        def __lt__(self, other):
            return self.dt < other.dt

        def __gt__(self, other):
            return self.dt > other.dt

        def __eq__(self, other):
            return self.dt == other.dt

        def __ne__(self, other):
            return self.dt != other.dt

    def __init__(self, cache=False):
        super(rruleset, self).__init__(cache)
        self._rrule = []
        self._rdate = []
        self._exrule = []
        self._exdate = []

    @_invalidates_cache
    def rrule(self, rrule):
        """ Include the given :py:class:`rrule` instance in the recurrence set
            generation. """
        self._rrule.append(rrule)

    @_invalidates_cache
    def rdate(self, rdate):
        """ Include the given :py:class:`datetime` instance in the recurrence
            set generation. """
        self._rdate.append(rdate)

    @_invalidates_cache
    def exrule(self, exrule):
        """ Include the given rrule instance in the recurrence set exclusion
            list. Dates which are part of the given recurrence rules will not
            be generated, even if some inclusive rrule or rdate matches them.
        """
        self._exrule.append(exrule)

    @_invalidates_cache
    def exdate(self, exdate):
        """ Include the given datetime instance in the recurrence set
            exclusion list. Dates included that way will not be generated,
            even if some inclusive rrule or rdate matches them. """
        self._exdate.append(exdate)

    def _iter(self):
        rlist = []
        self._rdate.sort()
        self._genitem(rlist, iter(self._rdate))
        for gen in [iter(x) for x in self._rrule]:
            self._genitem(rlist, gen)
        exlist = []
        self._exdate.sort()
        self._genitem(exlist, iter(self._exdate))
        for gen in [iter(x) for x in self._exrule]:
            self._genitem(exlist, gen)
        lastdt = None
        total = 0
        heapq.heapify(rlist)
        heapq.heapify(exlist)
        while rlist:
            ritem = rlist[0]
            if not lastdt or lastdt != ritem.dt:
                while exlist and exlist[0] < ritem:
                    exitem = exlist[0]
                    advance_iterator(exitem)
                    if exlist and exlist[0] is exitem:
                        heapq.heapreplace(exlist, exitem)
                if not exlist or ritem != exlist[0]:
                    total += 1
                    yield ritem.dt
                lastdt = ritem.dt
            advance_iterator(ritem)
            if rlist and rlist[0] is ritem:
                heapq.heapreplace(rlist, ritem)
        self._len = total




class _rrulestr(object):
    """ Parses a string representation of a recurrence rule or set of
    recurrence rules.

    :param s:
        Required, a string defining one or more recurrence rules.

    :param dtstart:
        If given, used as the default recurrence start if not specified in the
        rule string.

    :param cache:
        If set ``True`` caching of results will be enabled, improving
        performance of multiple queries considerably.

    :param unfold:
        If set ``True`` indicates that a rule string is split over more
        than one line and should be joined before processing.

    :param forceset:
        If set ``True`` forces a :class:`dateutil.rrule.rruleset` to
        be returned.

    :param compatible:
        If set ``True`` forces ``unfold`` and ``forceset`` to be ``True``.

    :param ignoretz:
        If set ``True``, time zones in parsed strings are ignored and a naive
        :class:`datetime.datetime` object is returned.

    :param tzids:
        If given, a callable or mapping used to retrieve a
        :class:`datetime.tzinfo` from a string representation.
        Defaults to :func:`dateutil.tz.gettz`.

    :param tzinfos:
        Additional time zone names / aliases which may be present in a string
        representation.  See :func:`dateutil.parser.parse` for more
        information.

    :return:
        Returns a :class:`dateutil.rrule.rruleset` or
        :class:`dateutil.rrule.rrule`
    """

    _freq_map = {"YEARLY": YEARLY,
                 "MONTHLY": MONTHLY,
                 "WEEKLY": WEEKLY,
                 "DAILY": DAILY,
                 "HOURLY": HOURLY,
                 "MINUTELY": MINUTELY,
                 "SECONDLY": SECONDLY}

    _weekday_map = {"MO": 0, "TU": 1, "WE": 2, "TH": 3,
                    "FR": 4, "SA": 5, "SU": 6}

    def _handle_int(self, rrkwargs, name, value, **kwargs):
        rrkwargs[name.lower()] = int(value)

    def _handle_int_list(self, rrkwargs, name, value, **kwargs):
        rrkwargs[name.lower()] = [int(x) for x in value.split(',')]

    _handle_INTERVAL = _handle_int
    _handle_COUNT = _handle_int
    _handle_BYSETPOS = _handle_int_list
    _handle_BYMONTH = _handle_int_list
    _handle_BYMONTHDAY = _handle_int_list
    _handle_BYYEARDAY = _handle_int_list
    _handle_BYEASTER = _handle_int_list
    _handle_BYWEEKNO = _handle_int_list
    _handle_BYHOUR = _handle_int_list
    _handle_BYMINUTE = _handle_int_list
    _handle_BYSECOND = _handle_int_list

    def _handle_FREQ(self, rrkwargs, name, value, **kwargs):
        rrkwargs["freq"] = self._freq_map[value]

    def _handle_UNTIL(self, rrkwargs, name, value, **kwargs):
        global parser
        if not parser:
            from dateutil import parser
        try:
            rrkwargs["until"] = parser.parse(value,
                                             ignoretz=kwargs.get("ignoretz"),
                                             tzinfos=kwargs.get("tzinfos"))
        except ValueError:
            raise ValueError("invalid until date")

    def _handle_WKST(self, rrkwargs, name, value, **kwargs):
        rrkwargs["wkst"] = self._weekday_map[value]

    def _handle_BYWEEKDAY(self, rrkwargs, name, value, **kwargs):
        """
        Two ways to specify this: +1MO or MO(+1)
        """
        l = []
        for wday in value.split(','):
            if '(' in wday:
                # If it's of the form TH(+1), etc.
                splt = wday.split('(')
                w = splt[0]
                n = int(splt[1][:-1])
            elif len(wday):
                # If it's of the form +1MO
                for i in range(len(wday)):
                    if wday[i] not in '+-0123456789':
                        break
                n = wday[:i] or None
                w = wday[i:]
                if n:
                    n = int(n)
            else:
                raise ValueError("Invalid (empty) BYDAY specification.")

            l.append(weekdays[self._weekday_map[w]](n))
        rrkwargs["byweekday"] = l

    _handle_BYDAY = _handle_BYWEEKDAY

    def _parse_rfc_rrule(self, line,
                         dtstart=None,
                         cache=False,
                         ignoretz=False,
                         tzinfos=None):
        if line.find(':') != -1:
            name, value = line.split(':')
            if name != "RRULE":
                raise ValueError("unknown parameter name")
        else:
            value = line
        rrkwargs = {}
        for pair in value.split(';'):
            name, value = pair.split('=')
            name = name.upper()
            value = value.upper()
            try:
                getattr(self, "_handle_"+name)(rrkwargs, name, value,
                                               ignoretz=ignoretz,
                                               tzinfos=tzinfos)
            except AttributeError:
                raise ValueError("unknown parameter '%s'" % name)
            except (KeyError, ValueError):
                raise ValueError("invalid '%s': %s" % (name, value))
        return rrule(dtstart=dtstart, cache=cache, **rrkwargs)

    def _parse_date_value(self, date_value, parms, rule_tzids,
                          ignoretz, tzids, tzinfos):
        global parser
        if not parser:
            from dateutil import parser

        datevals = []
        value_found = False
        TZID = None

        for parm in parms:
            if parm.startswith("TZID="):
                try:
                    tzkey = rule_tzids[parm.split('TZID=')[-1]]
                except KeyError:
                    continue
                if tzids is None:
                    from . import tz
                    tzlookup = tz.gettz
                elif callable(tzids):
                    tzlookup = tzids
                else:
                    tzlookup = getattr(tzids, 'get', None)
                    if tzlookup is None:
                        msg = ('tzids must be a callable, mapping, or None, '
                               'not %s' % tzids)
                        raise ValueError(msg)

                TZID = tzlookup(tzkey)
                continue

            # RFC 5445 3.8.2.4: The VALUE parameter is optional, but may be found
            # only once.
            if parm not in {"VALUE=DATE-TIME", "VALUE=DATE"}:
                raise ValueError("unsupported parm: " + parm)
            else:
                if value_found:
                    msg = ("Duplicate value parameter found in: " + parm)
                    raise ValueError(msg)
                value_found = True

        for datestr in date_value.split(','):
            date = parser.parse(datestr, ignoretz=ignoretz, tzinfos=tzinfos)
            if TZID is not None:
                if date.tzinfo is None:
                    date = date.replace(tzinfo=TZID)
                else:
                    raise ValueError('DTSTART/EXDATE specifies multiple timezone')
            datevals.append(date)

        return datevals

    def _parse_rfc(self, s,
                   dtstart=None,
                   cache=False,
                   unfold=False,
                   forceset=False,
                   compatible=False,
                   ignoretz=False,
                   tzids=None,
                   tzinfos=None):
        global parser
        if compatible:
            forceset = True
            unfold = True

        TZID_NAMES = dict(map(
            lambda x: (x.upper(), x),
            re.findall('TZID=(?P<name>[^:]+):', s)
        ))
        s = s.upper()
        if not s.strip():
            raise ValueError("empty string")
        if unfold:
            lines = s.splitlines()
            i = 0
            while i < len(lines):
                line = lines[i].rstrip()
                if not line:
                    del lines[i]
                elif i > 0 and line[0] == " ":
                    lines[i-1] += line[1:]
                    del lines[i]
                else:
                    i += 1
        else:
            lines = s.split()
        if (not forceset and len(lines) == 1 and (s.find(':') == -1 or
                                                  s.startswith('RRULE:'))):
            return self._parse_rfc_rrule(lines[0], cache=cache,
                                         dtstart=dtstart, ignoretz=ignoretz,
                                         tzinfos=tzinfos)
        else:
            rrulevals = []
            rdatevals = []
            exrulevals = []
            exdatevals = []
            for line in lines:
                if not line:
                    continue
                if line.find(':') == -1:
                    name = "RRULE"
                    value = line
                else:
                    name, value = line.split(':', 1)
                parms = name.split(';')
                if not parms:
                    raise ValueError("empty property name")
                name = parms[0]
                parms = parms[1:]
                if name == "RRULE":
                    for parm in parms:
                        raise ValueError("unsupported RRULE parm: "+parm)
                    rrulevals.append(value)
                elif name == "RDATE":
                    for parm in parms:
                        if parm != "VALUE=DATE-TIME":
                            raise ValueError("unsupported RDATE parm: "+parm)
                    rdatevals.append(value)
                elif name == "EXRULE":
                    for parm in parms:
                        raise ValueError("unsupported EXRULE parm: "+parm)
                    exrulevals.append(value)
                elif name == "EXDATE":
                    exdatevals.extend(
                        self._parse_date_value(value, parms,
                                               TZID_NAMES, ignoretz,
                                               tzids, tzinfos)
                    )
                elif name == "DTSTART":
                    dtvals = self._parse_date_value(value, parms, TZID_NAMES,
                                                    ignoretz, tzids, tzinfos)
                    if len(dtvals) != 1:
                        raise ValueError("Multiple DTSTART values specified:" +
                                         value)
                    dtstart = dtvals[0]
                else:
                    raise ValueError("unsupported property: "+name)
            if (forceset or len(rrulevals) > 1 or rdatevals
                    or exrulevals or exdatevals):
                if not parser and (rdatevals or exdatevals):
                    from dateutil import parser
                rset = rruleset(cache=cache)
                for value in rrulevals:
                    rset.rrule(self._parse_rfc_rrule(value, dtstart=dtstart,
                                                     ignoretz=ignoretz,
                                                     tzinfos=tzinfos))
                for value in rdatevals:
                    for datestr in value.split(','):
                        rset.rdate(parser.parse(datestr,
                                                ignoretz=ignoretz,
                                                tzinfos=tzinfos))
                for value in exrulevals:
                    rset.exrule(self._parse_rfc_rrule(value, dtstart=dtstart,
                                                      ignoretz=ignoretz,
                                                      tzinfos=tzinfos))
                for value in exdatevals:
                    rset.exdate(value)
                if compatible and dtstart:
                    rset.rdate(dtstart)
                return rset
            else:
                return self._parse_rfc_rrule(rrulevals[0],
                                             dtstart=dtstart,
                                             cache=cache,
                                             ignoretz=ignoretz,
                                             tzinfos=tzinfos)

    def __call__(self, s, **kwargs):
        return self._parse_rfc(s, **kwargs)


rrulestr = _rrulestr()

# vim:ts=4:sw=4:et
# tzwin has moved to dateutil.tz.win
from .tz.win import *
# -*- coding: utf-8 -*-
"""
This module offers general convenience and utility functions for dealing with
datetimes.

.. versionadded:: 2.7.0
"""
from __future__ import unicode_literals

from datetime import datetime, time


def today(tzinfo=None):
    """
    Returns a :py:class:`datetime` representing the current day at midnight

    :param tzinfo:
        The time zone to attach (also used to determine the current day).

    :return:
        A :py:class:`datetime.datetime` object representing the current day
        at midnight.
    """

    dt = datetime.now(tzinfo)
    return datetime.combine(dt.date(), time(0, tzinfo=tzinfo))


def default_tzinfo(dt, tzinfo):
    """
    Sets the ``tzinfo`` parameter on naive datetimes only

    This is useful for example when you are provided a datetime that may have
    either an implicit or explicit time zone, such as when parsing a time zone
    string.

    .. doctest::

        >>> from dateutil.tz import tzoffset
        >>> from dateutil.parser import parse
        >>> from dateutil.utils import default_tzinfo
        >>> dflt_tz = tzoffset("EST", -18000)
        >>> print(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))
        2014-01-01 12:30:00+00:00
        >>> print(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))
        2014-01-01 12:30:00-05:00

    :param dt:
        The datetime on which to replace the time zone

    :param tzinfo:
        The :py:class:`datetime.tzinfo` subclass instance to assign to
        ``dt`` if (and only if) it is naive.

    :return:
        Returns an aware :py:class:`datetime.datetime`.
    """
    if dt.tzinfo is not None:
        return dt
    else:
        return dt.replace(tzinfo=tzinfo)


def within_delta(dt1, dt2, delta):
    """
    Useful for comparing two datetimes that may a negilible difference
    to be considered equal.
    """
    delta = abs(delta)
    difference = dt1 - dt2
    return -delta <= difference <= delta
"""
Common code used in multiple modules.
"""


class weekday(object):
    __slots__ = ["weekday", "n"]

    def __init__(self, weekday, n=None):
        self.weekday = weekday
        self.n = n

    def __call__(self, n):
        if n == self.n:
            return self
        else:
            return self.__class__(self.weekday, n)

    def __eq__(self, other):
        try:
            if self.weekday != other.weekday or self.n != other.n:
                return False
        except AttributeError:
            return False
        return True

    def __hash__(self):
        return hash((
          self.weekday,
          self.n,
        ))

    def __ne__(self, other):
        return not (self == other)

    def __repr__(self):
        s = ("MO", "TU", "WE", "TH", "FR", "SA", "SU")[self.weekday]
        if not self.n:
            return s
        else:
            return "%s(%+d)" % (s, self.n)

# vim:ts=4:sw=4:et
# coding: utf-8
# file generated by setuptools_scm
# don't change, don't track in version control
version = '2.8.1'
# -*- coding: utf-8 -*-
try:
    from ._version import version as __version__
except ImportError:
    __version__ = 'unknown'

__all__ = ['easter', 'parser', 'relativedelta', 'rrule', 'tz',
           'utils', 'zoneinfo']
# -*- coding: utf-8 -*-
"""
This module offers a parser for ISO-8601 strings

It is intended to support all valid date, time and datetime formats per the
ISO-8601 specification.

..versionadded:: 2.7.0
"""
from datetime import datetime, timedelta, time, date
import calendar
from dateutil import tz

from functools import wraps

import re
import six

__all__ = ["isoparse", "isoparser"]


def _takes_ascii(f):
    @wraps(f)
    def func(self, str_in, *args, **kwargs):
        # If it's a stream, read the whole thing
        str_in = getattr(str_in, 'read', lambda: str_in)()

        # If it's unicode, turn it into bytes, since ISO-8601 only covers ASCII
        if isinstance(str_in, six.text_type):
            # ASCII is the same in UTF-8
            try:
                str_in = str_in.encode('ascii')
            except UnicodeEncodeError as e:
                msg = 'ISO-8601 strings should contain only ASCII characters'
                six.raise_from(ValueError(msg), e)

        return f(self, str_in, *args, **kwargs)

    return func


class isoparser(object):
    def __init__(self, sep=None):
        """
        :param sep:
            A single character that separates date and time portions. If
            ``None``, the parser will accept any single character.
            For strict ISO-8601 adherence, pass ``'T'``.
        """
        if sep is not None:
            if (len(sep) != 1 or ord(sep) >= 128 or sep in '0123456789'):
                raise ValueError('Separator must be a single, non-numeric ' +
                                 'ASCII character')

            sep = sep.encode('ascii')

        self._sep = sep

    @_takes_ascii
    def isoparse(self, dt_str):
        """
        Parse an ISO-8601 datetime string into a :class:`datetime.datetime`.

        An ISO-8601 datetime string consists of a date portion, followed
        optionally by a time portion - the date and time portions are separated
        by a single character separator, which is ``T`` in the official
        standard. Incomplete date formats (such as ``YYYY-MM``) may *not* be
        combined with a time portion.

        Supported date formats are:

        Common:

        - ``YYYY``
        - ``YYYY-MM`` or ``YYYYMM``
        - ``YYYY-MM-DD`` or ``YYYYMMDD``

        Uncommon:

        - ``YYYY-Www`` or ``YYYYWww`` - ISO week (day defaults to 0)
        - ``YYYY-Www-D`` or ``YYYYWwwD`` - ISO week and day

        The ISO week and day numbering follows the same logic as
        :func:`datetime.date.isocalendar`.

        Supported time formats are:

        - ``hh``
        - ``hh:mm`` or ``hhmm``
        - ``hh:mm:ss`` or ``hhmmss``
        - ``hh:mm:ss.ssssss`` (Up to 6 sub-second digits)

        Midnight is a special case for `hh`, as the standard supports both
        00:00 and 24:00 as a representation. The decimal separator can be
        either a dot or a comma.


        .. caution::

            Support for fractional components other than seconds is part of the
            ISO-8601 standard, but is not currently implemented in this parser.

        Supported time zone offset formats are:

        - `Z` (UTC)
        - `HH:MM`
        - `HHMM`
        - `HH`

        Offsets will be represented as :class:`dateutil.tz.tzoffset` objects,
        with the exception of UTC, which will be represented as
        :class:`dateutil.tz.tzutc`. Time zone offsets equivalent to UTC (such
        as `+00:00`) will also be represented as :class:`dateutil.tz.tzutc`.

        :param dt_str:
            A string or stream containing only an ISO-8601 datetime string

        :return:
            Returns a :class:`datetime.datetime` representing the string.
            Unspecified components default to their lowest value.

        .. warning::

            As of version 2.7.0, the strictness of the parser should not be
            considered a stable part of the contract. Any valid ISO-8601 string
            that parses correctly with the default settings will continue to
            parse correctly in future versions, but invalid strings that
            currently fail (e.g. ``2017-01-01T00:00+00:00:00``) are not
            guaranteed to continue failing in future versions if they encode
            a valid date.

        .. versionadded:: 2.7.0
        """
        components, pos = self._parse_isodate(dt_str)

        if len(dt_str) > pos:
            if self._sep is None or dt_str[pos:pos + 1] == self._sep:
                components += self._parse_isotime(dt_str[pos + 1:])
            else:
                raise ValueError('String contains unknown ISO components')

        if len(components) > 3 and components[3] == 24:
            components[3] = 0
            return datetime(*components) + timedelta(days=1)

        return datetime(*components)

    @_takes_ascii
    def parse_isodate(self, datestr):
        """
        Parse the date portion of an ISO string.

        :param datestr:
            The string portion of an ISO string, without a separator

        :return:
            Returns a :class:`datetime.date` object
        """
        components, pos = self._parse_isodate(datestr)
        if pos < len(datestr):
            raise ValueError('String contains unknown ISO ' +
                             'components: {}'.format(datestr))
        return date(*components)

    @_takes_ascii
    def parse_isotime(self, timestr):
        """
        Parse the time portion of an ISO string.

        :param timestr:
            The time portion of an ISO string, without a separator

        :return:
            Returns a :class:`datetime.time` object
        """
        components = self._parse_isotime(timestr)
        if components[0] == 24:
            components[0] = 0
        return time(*components)

    @_takes_ascii
    def parse_tzstr(self, tzstr, zero_as_utc=True):
        """
        Parse a valid ISO time zone string.

        See :func:`isoparser.isoparse` for details on supported formats.

        :param tzstr:
            A string representing an ISO time zone offset

        :param zero_as_utc:
            Whether to return :class:`dateutil.tz.tzutc` for zero-offset zones

        :return:
            Returns :class:`dateutil.tz.tzoffset` for offsets and
            :class:`dateutil.tz.tzutc` for ``Z`` and (if ``zero_as_utc`` is
            specified) offsets equivalent to UTC.
        """
        return self._parse_tzstr(tzstr, zero_as_utc=zero_as_utc)

    # Constants
    _DATE_SEP = b'-'
    _TIME_SEP = b':'
    _FRACTION_REGEX = re.compile(b'[\\.,]([0-9]+)')

    def _parse_isodate(self, dt_str):
        try:
            return self._parse_isodate_common(dt_str)
        except ValueError:
            return self._parse_isodate_uncommon(dt_str)

    def _parse_isodate_common(self, dt_str):
        len_str = len(dt_str)
        components = [1, 1, 1]

        if len_str < 4:
            raise ValueError('ISO string too short')

        # Year
        components[0] = int(dt_str[0:4])
        pos = 4
        if pos >= len_str:
            return components, pos

        has_sep = dt_str[pos:pos + 1] == self._DATE_SEP
        if has_sep:
            pos += 1

        # Month
        if len_str - pos < 2:
            raise ValueError('Invalid common month')

        components[1] = int(dt_str[pos:pos + 2])
        pos += 2

        if pos >= len_str:
            if has_sep:
                return components, pos
            else:
                raise ValueError('Invalid ISO format')

        if has_sep:
            if dt_str[pos:pos + 1] != self._DATE_SEP:
                raise ValueError('Invalid separator in ISO string')
            pos += 1

        # Day
        if len_str - pos < 2:
            raise ValueError('Invalid common day')
        components[2] = int(dt_str[pos:pos + 2])
        return components, pos + 2

    def _parse_isodate_uncommon(self, dt_str):
        if len(dt_str) < 4:
            raise ValueError('ISO string too short')

        # All ISO formats start with the year
        year = int(dt_str[0:4])

        has_sep = dt_str[4:5] == self._DATE_SEP

        pos = 4 + has_sep       # Skip '-' if it's there
        if dt_str[pos:pos + 1] == b'W':
            # YYYY-?Www-?D?
            pos += 1
            weekno = int(dt_str[pos:pos + 2])
            pos += 2

            dayno = 1
            if len(dt_str) > pos:
                if (dt_str[pos:pos + 1] == self._DATE_SEP) != has_sep:
                    raise ValueError('Inconsistent use of dash separator')

                pos += has_sep

                dayno = int(dt_str[pos:pos + 1])
                pos += 1

            base_date = self._calculate_weekdate(year, weekno, dayno)
        else:
            # YYYYDDD or YYYY-DDD
            if len(dt_str) - pos < 3:
                raise ValueError('Invalid ordinal day')

            ordinal_day = int(dt_str[pos:pos + 3])
            pos += 3

            if ordinal_day < 1 or ordinal_day > (365 + calendar.isleap(year)):
                raise ValueError('Invalid ordinal day' +
                                 ' {} for year {}'.format(ordinal_day, year))

            base_date = date(year, 1, 1) + timedelta(days=ordinal_day - 1)

        components = [base_date.year, base_date.month, base_date.day]
        return components, pos

    def _calculate_weekdate(self, year, week, day):
        """
        Calculate the day of corresponding to the ISO year-week-day calendar.

        This function is effectively the inverse of
        :func:`datetime.date.isocalendar`.

        :param year:
            The year in the ISO calendar

        :param week:
            The week in the ISO calendar - range is [1, 53]

        :param day:
            The day in the ISO calendar - range is [1 (MON), 7 (SUN)]

        :return:
            Returns a :class:`datetime.date`
        """
        if not 0 < week < 54:
            raise ValueError('Invalid week: {}'.format(week))

        if not 0 < day < 8:     # Range is 1-7
            raise ValueError('Invalid weekday: {}'.format(day))

        # Get week 1 for the specific year:
        jan_4 = date(year, 1, 4)   # Week 1 always has January 4th in it
        week_1 = jan_4 - timedelta(days=jan_4.isocalendar()[2] - 1)

        # Now add the specific number of weeks and days to get what we want
        week_offset = (week - 1) * 7 + (day - 1)
        return week_1 + timedelta(days=week_offset)

    def _parse_isotime(self, timestr):
        len_str = len(timestr)
        components = [0, 0, 0, 0, None]
        pos = 0
        comp = -1

        if len(timestr) < 2:
            raise ValueError('ISO time too short')

        has_sep = len_str >= 3 and timestr[2:3] == self._TIME_SEP

        while pos < len_str and comp < 5:
            comp += 1

            if timestr[pos:pos + 1] in b'-+Zz':
                # Detect time zone boundary
                components[-1] = self._parse_tzstr(timestr[pos:])
                pos = len_str
                break

            if comp < 3:
                # Hour, minute, second
                components[comp] = int(timestr[pos:pos + 2])
                pos += 2
                if (has_sep and pos < len_str and
                        timestr[pos:pos + 1] == self._TIME_SEP):
                    pos += 1

            if comp == 3:
                # Fraction of a second
                frac = self._FRACTION_REGEX.match(timestr[pos:])
                if not frac:
                    continue

                us_str = frac.group(1)[:6]  # Truncate to microseconds
                components[comp] = int(us_str) * 10**(6 - len(us_str))
                pos += len(frac.group())

        if pos < len_str:
            raise ValueError('Unused components in ISO string')

        if components[0] == 24:
            # Standard supports 00:00 and 24:00 as representations of midnight
            if any(component != 0 for component in components[1:4]):
                raise ValueError('Hour may only be 24 at 24:00:00.000')

        return components

    def _parse_tzstr(self, tzstr, zero_as_utc=True):
        if tzstr == b'Z' or tzstr == b'z':
            return tz.UTC

        if len(tzstr) not in {3, 5, 6}:
            raise ValueError('Time zone offset must be 1, 3, 5 or 6 characters')

        if tzstr[0:1] == b'-':
            mult = -1
        elif tzstr[0:1] == b'+':
            mult = 1
        else:
            raise ValueError('Time zone offset requires sign')

        hours = int(tzstr[1:3])
        if len(tzstr) == 3:
            minutes = 0
        else:
            minutes = int(tzstr[(4 if tzstr[3:4] == self._TIME_SEP else 3):])

        if zero_as_utc and hours == 0 and minutes == 0:
            return tz.UTC
        else:
            if minutes > 59:
                raise ValueError('Invalid minutes in time zone offset')

            if hours > 23:
                raise ValueError('Invalid hours in time zone offset')

            return tz.tzoffset(None, mult * (hours * 60 + minutes) * 60)


DEFAULT_ISOPARSER = isoparser()
isoparse = DEFAULT_ISOPARSER.isoparse
# -*- coding: utf-8 -*-
"""
This module offers a generic date/time string parser which is able to parse
most known formats to represent a date and/or time.

This module attempts to be forgiving with regards to unlikely input formats,
returning a datetime object even for dates which are ambiguous. If an element
of a date/time stamp is omitted, the following rules are applied:

- If AM or PM is left unspecified, a 24-hour clock is assumed, however, an hour
  on a 12-hour clock (``0 <= hour <= 12``) *must* be specified if AM or PM is
  specified.
- If a time zone is omitted, a timezone-naive datetime is returned.

If any other elements are missing, they are taken from the
:class:`datetime.datetime` object passed to the parameter ``default``. If this
results in a day number exceeding the valid number of days per month, the
value falls back to the end of the month.

Additional resources about date/time string formats can be found below:

- `A summary of the international standard date and time notation
  <http://www.cl.cam.ac.uk/~mgk25/iso-time.html>`_
- `W3C Date and Time Formats <http://www.w3.org/TR/NOTE-datetime>`_
- `Time Formats (Planetary Rings Node) <https://pds-rings.seti.org:443/tools/time_formats.html>`_
- `CPAN ParseDate module
  <http://search.cpan.org/~muir/Time-modules-2013.0912/lib/Time/ParseDate.pm>`_
- `Java SimpleDateFormat Class
  <https://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html>`_
"""
from __future__ import unicode_literals

import datetime
import re
import string
import time
import warnings

from calendar import monthrange
from io import StringIO

import six
from six import integer_types, text_type

from decimal import Decimal

from warnings import warn

from .. import relativedelta
from .. import tz

__all__ = ["parse", "parserinfo", "ParserError"]


# TODO: pandas.core.tools.datetimes imports this explicitly.  Might be worth
# making public and/or figuring out if there is something we can
# take off their plate.
class _timelex(object):
    # Fractional seconds are sometimes split by a comma
    _split_decimal = re.compile("([.,])")

    def __init__(self, instream):
        if six.PY2:
            # In Python 2, we can't duck type properly because unicode has
            # a 'decode' function, and we'd be double-decoding
            if isinstance(instream, (bytes, bytearray)):
                instream = instream.decode()
        else:
            if getattr(instream, 'decode', None) is not None:
                instream = instream.decode()

        if isinstance(instream, text_type):
            instream = StringIO(instream)
        elif getattr(instream, 'read', None) is None:
            raise TypeError('Parser must be a string or character stream, not '
                            '{itype}'.format(itype=instream.__class__.__name__))

        self.instream = instream
        self.charstack = []
        self.tokenstack = []
        self.eof = False

    def get_token(self):
        """
        This function breaks the time string into lexical units (tokens), which
        can be parsed by the parser. Lexical units are demarcated by changes in
        the character set, so any continuous string of letters is considered
        one unit, any continuous string of numbers is considered one unit.

        The main complication arises from the fact that dots ('.') can be used
        both as separators (e.g. "Sep.20.2009") or decimal points (e.g.
        "4:30:21.447"). As such, it is necessary to read the full context of
        any dot-separated strings before breaking it into tokens; as such, this
        function maintains a "token stack", for when the ambiguous context
        demands that multiple tokens be parsed at once.
        """
        if self.tokenstack:
            return self.tokenstack.pop(0)

        seenletters = False
        token = None
        state = None

        while not self.eof:
            # We only realize that we've reached the end of a token when we
            # find a character that's not part of the current token - since
            # that character may be part of the next token, it's stored in the
            # charstack.
            if self.charstack:
                nextchar = self.charstack.pop(0)
            else:
                nextchar = self.instream.read(1)
                while nextchar == '\x00':
                    nextchar = self.instream.read(1)

            if not nextchar:
                self.eof = True
                break
            elif not state:
                # First character of the token - determines if we're starting
                # to parse a word, a number or something else.
                token = nextchar
                if self.isword(nextchar):
                    state = 'a'
                elif self.isnum(nextchar):
                    state = '0'
                elif self.isspace(nextchar):
                    token = ' '
                    break  # emit token
                else:
                    break  # emit token
            elif state == 'a':
                # If we've already started reading a word, we keep reading
                # letters until we find something that's not part of a word.
                seenletters = True
                if self.isword(nextchar):
                    token += nextchar
                elif nextchar == '.':
                    token += nextchar
                    state = 'a.'
                else:
                    self.charstack.append(nextchar)
                    break  # emit token
            elif state == '0':
                # If we've already started reading a number, we keep reading
                # numbers until we find something that doesn't fit.
                if self.isnum(nextchar):
                    token += nextchar
                elif nextchar == '.' or (nextchar == ',' and len(token) >= 2):
                    token += nextchar
                    state = '0.'
                else:
                    self.charstack.append(nextchar)
                    break  # emit token
            elif state == 'a.':
                # If we've seen some letters and a dot separator, continue
                # parsing, and the tokens will be broken up later.
                seenletters = True
                if nextchar == '.' or self.isword(nextchar):
                    token += nextchar
                elif self.isnum(nextchar) and token[-1] == '.':
                    token += nextchar
                    state = '0.'
                else:
                    self.charstack.append(nextchar)
                    break  # emit token
            elif state == '0.':
                # If we've seen at least one dot separator, keep going, we'll
                # break up the tokens later.
                if nextchar == '.' or self.isnum(nextchar):
                    token += nextchar
                elif self.isword(nextchar) and token[-1] == '.':
                    token += nextchar
                    state = 'a.'
                else:
                    self.charstack.append(nextchar)
                    break  # emit token

        if (state in ('a.', '0.') and (seenletters or token.count('.') > 1 or
                                       token[-1] in '.,')):
            l = self._split_decimal.split(token)
            token = l[0]
            for tok in l[1:]:
                if tok:
                    self.tokenstack.append(tok)

        if state == '0.' and token.count('.') == 0:
            token = token.replace(',', '.')

        return token

    def __iter__(self):
        return self

    def __next__(self):
        token = self.get_token()
        if token is None:
            raise StopIteration

        return token

    def next(self):
        return self.__next__()  # Python 2.x support

    @classmethod
    def split(cls, s):
        return list(cls(s))

    @classmethod
    def isword(cls, nextchar):
        """ Whether or not the next character is part of a word """
        return nextchar.isalpha()

    @classmethod
    def isnum(cls, nextchar):
        """ Whether the next character is part of a number """
        return nextchar.isdigit()

    @classmethod
    def isspace(cls, nextchar):
        """ Whether the next character is whitespace """
        return nextchar.isspace()


class _resultbase(object):

    def __init__(self):
        for attr in self.__slots__:
            setattr(self, attr, None)

    def _repr(self, classname):
        l = []
        for attr in self.__slots__:
            value = getattr(self, attr)
            if value is not None:
                l.append("%s=%s" % (attr, repr(value)))
        return "%s(%s)" % (classname, ", ".join(l))

    def __len__(self):
        return (sum(getattr(self, attr) is not None
                    for attr in self.__slots__))

    def __repr__(self):
        return self._repr(self.__class__.__name__)


class parserinfo(object):
    """
    Class which handles what inputs are accepted. Subclass this to customize
    the language and acceptable values for each parameter.

    :param dayfirst:
        Whether to interpret the first value in an ambiguous 3-integer date
        (e.g. 01/05/09) as the day (``True``) or month (``False``). If
        ``yearfirst`` is set to ``True``, this distinguishes between YDM
        and YMD. Default is ``False``.

    :param yearfirst:
        Whether to interpret the first value in an ambiguous 3-integer date
        (e.g. 01/05/09) as the year. If ``True``, the first number is taken
        to be the year, otherwise the last number is taken to be the year.
        Default is ``False``.
    """

    # m from a.m/p.m, t from ISO T separator
    JUMP = [" ", ".", ",", ";", "-", "/", "'",
            "at", "on", "and", "ad", "m", "t", "of",
            "st", "nd", "rd", "th"]

    WEEKDAYS = [("Mon", "Monday"),
                ("Tue", "Tuesday"),     # TODO: "Tues"
                ("Wed", "Wednesday"),
                ("Thu", "Thursday"),    # TODO: "Thurs"
                ("Fri", "Friday"),
                ("Sat", "Saturday"),
                ("Sun", "Sunday")]
    MONTHS = [("Jan", "January"),
              ("Feb", "February"),      # TODO: "Febr"
              ("Mar", "March"),
              ("Apr", "April"),
              ("May", "May"),
              ("Jun", "June"),
              ("Jul", "July"),
              ("Aug", "August"),
              ("Sep", "Sept", "September"),
              ("Oct", "October"),
              ("Nov", "November"),
              ("Dec", "December")]
    HMS = [("h", "hour", "hours"),
           ("m", "minute", "minutes"),
           ("s", "second", "seconds")]
    AMPM = [("am", "a"),
            ("pm", "p")]
    UTCZONE = ["UTC", "GMT", "Z", "z"]
    PERTAIN = ["of"]
    TZOFFSET = {}
    # TODO: ERA = ["AD", "BC", "CE", "BCE", "Stardate",
    #              "Anno Domini", "Year of Our Lord"]

    def __init__(self, dayfirst=False, yearfirst=False):
        self._jump = self._convert(self.JUMP)
        self._weekdays = self._convert(self.WEEKDAYS)
        self._months = self._convert(self.MONTHS)
        self._hms = self._convert(self.HMS)
        self._ampm = self._convert(self.AMPM)
        self._utczone = self._convert(self.UTCZONE)
        self._pertain = self._convert(self.PERTAIN)

        self.dayfirst = dayfirst
        self.yearfirst = yearfirst

        self._year = time.localtime().tm_year
        self._century = self._year // 100 * 100

    def _convert(self, lst):
        dct = {}
        for i, v in enumerate(lst):
            if isinstance(v, tuple):
                for v in v:
                    dct[v.lower()] = i
            else:
                dct[v.lower()] = i
        return dct

    def jump(self, name):
        return name.lower() in self._jump

    def weekday(self, name):
        try:
            return self._weekdays[name.lower()]
        except KeyError:
            pass
        return None

    def month(self, name):
        try:
            return self._months[name.lower()] + 1
        except KeyError:
            pass
        return None

    def hms(self, name):
        try:
            return self._hms[name.lower()]
        except KeyError:
            return None

    def ampm(self, name):
        try:
            return self._ampm[name.lower()]
        except KeyError:
            return None

    def pertain(self, name):
        return name.lower() in self._pertain

    def utczone(self, name):
        return name.lower() in self._utczone

    def tzoffset(self, name):
        if name in self._utczone:
            return 0

        return self.TZOFFSET.get(name)

    def convertyear(self, year, century_specified=False):
        """
        Converts two-digit years to year within [-50, 49]
        range of self._year (current local time)
        """

        # Function contract is that the year is always positive
        assert year >= 0

        if year < 100 and not century_specified:
            # assume current century to start
            year += self._century

            if year >= self._year + 50:  # if too far in future
                year -= 100
            elif year < self._year - 50:  # if too far in past
                year += 100

        return year

    def validate(self, res):
        # move to info
        if res.year is not None:
            res.year = self.convertyear(res.year, res.century_specified)

        if ((res.tzoffset == 0 and not res.tzname) or
             (res.tzname == 'Z' or res.tzname == 'z')):
            res.tzname = "UTC"
            res.tzoffset = 0
        elif res.tzoffset != 0 and res.tzname and self.utczone(res.tzname):
            res.tzoffset = 0
        return True


class _ymd(list):
    def __init__(self, *args, **kwargs):
        super(self.__class__, self).__init__(*args, **kwargs)
        self.century_specified = False
        self.dstridx = None
        self.mstridx = None
        self.ystridx = None

    @property
    def has_year(self):
        return self.ystridx is not None

    @property
    def has_month(self):
        return self.mstridx is not None

    @property
    def has_day(self):
        return self.dstridx is not None

    def could_be_day(self, value):
        if self.has_day:
            return False
        elif not self.has_month:
            return 1 <= value <= 31
        elif not self.has_year:
            # Be permissive, assume leap year
            month = self[self.mstridx]
            return 1 <= value <= monthrange(2000, month)[1]
        else:
            month = self[self.mstridx]
            year = self[self.ystridx]
            return 1 <= value <= monthrange(year, month)[1]

    def append(self, val, label=None):
        if hasattr(val, '__len__'):
            if val.isdigit() and len(val) > 2:
                self.century_specified = True
                if label not in [None, 'Y']:  # pragma: no cover
                    raise ValueError(label)
                label = 'Y'
        elif val > 100:
            self.century_specified = True
            if label not in [None, 'Y']:  # pragma: no cover
                raise ValueError(label)
            label = 'Y'

        super(self.__class__, self).append(int(val))

        if label == 'M':
            if self.has_month:
                raise ValueError('Month is already set')
            self.mstridx = len(self) - 1
        elif label == 'D':
            if self.has_day:
                raise ValueError('Day is already set')
            self.dstridx = len(self) - 1
        elif label == 'Y':
            if self.has_year:
                raise ValueError('Year is already set')
            self.ystridx = len(self) - 1

    def _resolve_from_stridxs(self, strids):
        """
        Try to resolve the identities of year/month/day elements using
        ystridx, mstridx, and dstridx, if enough of these are specified.
        """
        if len(self) == 3 and len(strids) == 2:
            # we can back out the remaining stridx value
            missing = [x for x in range(3) if x not in strids.values()]
            key = [x for x in ['y', 'm', 'd'] if x not in strids]
            assert len(missing) == len(key) == 1
            key = key[0]
            val = missing[0]
            strids[key] = val

        assert len(self) == len(strids)  # otherwise this should not be called
        out = {key: self[strids[key]] for key in strids}
        return (out.get('y'), out.get('m'), out.get('d'))

    def resolve_ymd(self, yearfirst, dayfirst):
        len_ymd = len(self)
        year, month, day = (None, None, None)

        strids = (('y', self.ystridx),
                  ('m', self.mstridx),
                  ('d', self.dstridx))

        strids = {key: val for key, val in strids if val is not None}
        if (len(self) == len(strids) > 0 or
                (len(self) == 3 and len(strids) == 2)):
            return self._resolve_from_stridxs(strids)

        mstridx = self.mstridx

        if len_ymd > 3:
            raise ValueError("More than three YMD values")
        elif len_ymd == 1 or (mstridx is not None and len_ymd == 2):
            # One member, or two members with a month string
            if mstridx is not None:
                month = self[mstridx]
                # since mstridx is 0 or 1, self[mstridx-1] always
                # looks up the other element
                other = self[mstridx - 1]
            else:
                other = self[0]

            if len_ymd > 1 or mstridx is None:
                if other > 31:
                    year = other
                else:
                    day = other

        elif len_ymd == 2:
            # Two members with numbers
            if self[0] > 31:
                # 99-01
                year, month = self
            elif self[1] > 31:
                # 01-99
                month, year = self
            elif dayfirst and self[1] <= 12:
                # 13-01
                day, month = self
            else:
                # 01-13
                month, day = self

        elif len_ymd == 3:
            # Three members
            if mstridx == 0:
                if self[1] > 31:
                    # Apr-2003-25
                    month, year, day = self
                else:
                    month, day, year = self
            elif mstridx == 1:
                if self[0] > 31 or (yearfirst and self[2] <= 31):
                    # 99-Jan-01
                    year, month, day = self
                else:
                    # 01-Jan-01
                    # Give precedence to day-first, since
                    # two-digit years is usually hand-written.
                    day, month, year = self

            elif mstridx == 2:
                # WTF!?
                if self[1] > 31:
                    # 01-99-Jan
                    day, year, month = self
                else:
                    # 99-01-Jan
                    year, day, month = self

            else:
                if (self[0] > 31 or
                    self.ystridx == 0 or
                        (yearfirst and self[1] <= 12 and self[2] <= 31)):
                    # 99-01-01
                    if dayfirst and self[2] <= 12:
                        year, day, month = self
                    else:
                        year, month, day = self
                elif self[0] > 12 or (dayfirst and self[1] <= 12):
                    # 13-01-01
                    day, month, year = self
                else:
                    # 01-13-01
                    month, day, year = self

        return year, month, day


class parser(object):
    def __init__(self, info=None):
        self.info = info or parserinfo()

    def parse(self, timestr, default=None,
              ignoretz=False, tzinfos=None, **kwargs):
        """
        Parse the date/time string into a :class:`datetime.datetime` object.

        :param timestr:
            Any date/time string using the supported formats.

        :param default:
            The default datetime object, if this is a datetime object and not
            ``None``, elements specified in ``timestr`` replace elements in the
            default object.

        :param ignoretz:
            If set ``True``, time zones in parsed strings are ignored and a
            naive :class:`datetime.datetime` object is returned.

        :param tzinfos:
            Additional time zone names / aliases which may be present in the
            string. This argument maps time zone names (and optionally offsets
            from those time zones) to time zones. This parameter can be a
            dictionary with timezone aliases mapping time zone names to time
            zones or a function taking two parameters (``tzname`` and
            ``tzoffset``) and returning a time zone.

            The timezones to which the names are mapped can be an integer
            offset from UTC in seconds or a :class:`tzinfo` object.

            .. doctest::
               :options: +NORMALIZE_WHITESPACE

                >>> from dateutil.parser import parse
                >>> from dateutil.tz import gettz
                >>> tzinfos = {"BRST": -7200, "CST": gettz("America/Chicago")}
                >>> parse("2012-01-19 17:21:00 BRST", tzinfos=tzinfos)
                datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))
                >>> parse("2012-01-19 17:21:00 CST", tzinfos=tzinfos)
                datetime.datetime(2012, 1, 19, 17, 21,
                                  tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))

            This parameter is ignored if ``ignoretz`` is set.

        :param \\*\\*kwargs:
            Keyword arguments as passed to ``_parse()``.

        :return:
            Returns a :class:`datetime.datetime` object or, if the
            ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
            first element being a :class:`datetime.datetime` object, the second
            a tuple containing the fuzzy tokens.

        :raises ParserError:
            Raised for invalid or unknown string format, if the provided
            :class:`tzinfo` is not in a valid format, or if an invalid date
            would be created.

        :raises TypeError:
            Raised for non-string or character stream input.

        :raises OverflowError:
            Raised if the parsed date exceeds the largest valid C integer on
            your system.
        """

        if default is None:
            default = datetime.datetime.now().replace(hour=0, minute=0,
                                                      second=0, microsecond=0)

        res, skipped_tokens = self._parse(timestr, **kwargs)

        if res is None:
            raise ParserError("Unknown string format: %s", timestr)

        if len(res) == 0:
            raise ParserError("String does not contain a date: %s", timestr)

        try:
            ret = self._build_naive(res, default)
        except ValueError as e:
            six.raise_from(ParserError(e.args[0] + ": %s", timestr), e)

        if not ignoretz:
            ret = self._build_tzaware(ret, res, tzinfos)

        if kwargs.get('fuzzy_with_tokens', False):
            return ret, skipped_tokens
        else:
            return ret

    class _result(_resultbase):
        __slots__ = ["year", "month", "day", "weekday",
                     "hour", "minute", "second", "microsecond",
                     "tzname", "tzoffset", "ampm","any_unused_tokens"]

    def _parse(self, timestr, dayfirst=None, yearfirst=None, fuzzy=False,
               fuzzy_with_tokens=False):
        """
        Private method which performs the heavy lifting of parsing, called from
        ``parse()``, which passes on its ``kwargs`` to this function.

        :param timestr:
            The string to parse.

        :param dayfirst:
            Whether to interpret the first value in an ambiguous 3-integer date
            (e.g. 01/05/09) as the day (``True``) or month (``False``). If
            ``yearfirst`` is set to ``True``, this distinguishes between YDM
            and YMD. If set to ``None``, this value is retrieved from the
            current :class:`parserinfo` object (which itself defaults to
            ``False``).

        :param yearfirst:
            Whether to interpret the first value in an ambiguous 3-integer date
            (e.g. 01/05/09) as the year. If ``True``, the first number is taken
            to be the year, otherwise the last number is taken to be the year.
            If this is set to ``None``, the value is retrieved from the current
            :class:`parserinfo` object (which itself defaults to ``False``).

        :param fuzzy:
            Whether to allow fuzzy parsing, allowing for string like "Today is
            January 1, 2047 at 8:21:00AM".

        :param fuzzy_with_tokens:
            If ``True``, ``fuzzy`` is automatically set to True, and the parser
            will return a tuple where the first element is the parsed
            :class:`datetime.datetime` datetimestamp and the second element is
            a tuple containing the portions of the string which were ignored:

            .. doctest::

                >>> from dateutil.parser import parse
                >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
                (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))

        """
        if fuzzy_with_tokens:
            fuzzy = True

        info = self.info

        if dayfirst is None:
            dayfirst = info.dayfirst

        if yearfirst is None:
            yearfirst = info.yearfirst

        res = self._result()
        l = _timelex.split(timestr)         # Splits the timestr into tokens

        skipped_idxs = []

        # year/month/day list
        ymd = _ymd()

        len_l = len(l)
        i = 0
        try:
            while i < len_l:

                # Check if it's a number
                value_repr = l[i]
                try:
                    value = float(value_repr)
                except ValueError:
                    value = None

                if value is not None:
                    # Numeric token
                    i = self._parse_numeric_token(l, i, info, ymd, res, fuzzy)

                # Check weekday
                elif info.weekday(l[i]) is not None:
                    value = info.weekday(l[i])
                    res.weekday = value

                # Check month name
                elif info.month(l[i]) is not None:
                    value = info.month(l[i])
                    ymd.append(value, 'M')

                    if i + 1 < len_l:
                        if l[i + 1] in ('-', '/'):
                            # Jan-01[-99]
                            sep = l[i + 1]
                            ymd.append(l[i + 2])

                            if i + 3 < len_l and l[i + 3] == sep:
                                # Jan-01-99
                                ymd.append(l[i + 4])
                                i += 2

                            i += 2

                        elif (i + 4 < len_l and l[i + 1] == l[i + 3] == ' ' and
                              info.pertain(l[i + 2])):
                            # Jan of 01
                            # In this case, 01 is clearly year
                            if l[i + 4].isdigit():
                                # Convert it here to become unambiguous
                                value = int(l[i + 4])
                                year = str(info.convertyear(value))
                                ymd.append(year, 'Y')
                            else:
                                # Wrong guess
                                pass
                                # TODO: not hit in tests
                            i += 4

                # Check am/pm
                elif info.ampm(l[i]) is not None:
                    value = info.ampm(l[i])
                    val_is_ampm = self._ampm_valid(res.hour, res.ampm, fuzzy)

                    if val_is_ampm:
                        res.hour = self._adjust_ampm(res.hour, value)
                        res.ampm = value

                    elif fuzzy:
                        skipped_idxs.append(i)

                # Check for a timezone name
                elif self._could_be_tzname(res.hour, res.tzname, res.tzoffset, l[i]):
                    res.tzname = l[i]
                    res.tzoffset = info.tzoffset(res.tzname)

                    # Check for something like GMT+3, or BRST+3. Notice
                    # that it doesn't mean "I am 3 hours after GMT", but
                    # "my time +3 is GMT". If found, we reverse the
                    # logic so that timezone parsing code will get it
                    # right.
                    if i + 1 < len_l and l[i + 1] in ('+', '-'):
                        l[i + 1] = ('+', '-')[l[i + 1] == '+']
                        res.tzoffset = None
                        if info.utczone(res.tzname):
                            # With something like GMT+3, the timezone
                            # is *not* GMT.
                            res.tzname = None

                # Check for a numbered timezone
                elif res.hour is not None and l[i] in ('+', '-'):
                    signal = (-1, 1)[l[i] == '+']
                    len_li = len(l[i + 1])

                    # TODO: check that l[i + 1] is integer?
                    if len_li == 4:
                        # -0300
                        hour_offset = int(l[i + 1][:2])
                        min_offset = int(l[i + 1][2:])
                    elif i + 2 < len_l and l[i + 2] == ':':
                        # -03:00
                        hour_offset = int(l[i + 1])
                        min_offset = int(l[i + 3])  # TODO: Check that l[i+3] is minute-like?
                        i += 2
                    elif len_li <= 2:
                        # -[0]3
                        hour_offset = int(l[i + 1][:2])
                        min_offset = 0
                    else:
                        raise ValueError(timestr)

                    res.tzoffset = signal * (hour_offset * 3600 + min_offset * 60)

                    # Look for a timezone name between parenthesis
                    if (i + 5 < len_l and
                            info.jump(l[i + 2]) and l[i + 3] == '(' and
                            l[i + 5] == ')' and
                            3 <= len(l[i + 4]) and
                            self._could_be_tzname(res.hour, res.tzname,
                                                  None, l[i + 4])):
                        # -0300 (BRST)
                        res.tzname = l[i + 4]
                        i += 4

                    i += 1

                # Check jumps
                elif not (info.jump(l[i]) or fuzzy):
                    raise ValueError(timestr)

                else:
                    skipped_idxs.append(i)
                i += 1

            # Process year/month/day
            year, month, day = ymd.resolve_ymd(yearfirst, dayfirst)

            res.century_specified = ymd.century_specified
            res.year = year
            res.month = month
            res.day = day

        except (IndexError, ValueError):
            return None, None

        if not info.validate(res):
            return None, None

        if fuzzy_with_tokens:
            skipped_tokens = self._recombine_skipped(l, skipped_idxs)
            return res, tuple(skipped_tokens)
        else:
            return res, None

    def _parse_numeric_token(self, tokens, idx, info, ymd, res, fuzzy):
        # Token is a number
        value_repr = tokens[idx]
        try:
            value = self._to_decimal(value_repr)
        except Exception as e:
            six.raise_from(ValueError('Unknown numeric token'), e)

        len_li = len(value_repr)

        len_l = len(tokens)

        if (len(ymd) == 3 and len_li in (2, 4) and
            res.hour is None and
            (idx + 1 >= len_l or
             (tokens[idx + 1] != ':' and
              info.hms(tokens[idx + 1]) is None))):
            # 19990101T23[59]
            s = tokens[idx]
            res.hour = int(s[:2])

            if len_li == 4:
                res.minute = int(s[2:])

        elif len_li == 6 or (len_li > 6 and tokens[idx].find('.') == 6):
            # YYMMDD or HHMMSS[.ss]
            s = tokens[idx]

            if not ymd and '.' not in tokens[idx]:
                ymd.append(s[:2])
                ymd.append(s[2:4])
                ymd.append(s[4:])
            else:
                # 19990101T235959[.59]

                # TODO: Check if res attributes already set.
                res.hour = int(s[:2])
                res.minute = int(s[2:4])
                res.second, res.microsecond = self._parsems(s[4:])

        elif len_li in (8, 12, 14):
            # YYYYMMDD
            s = tokens[idx]
            ymd.append(s[:4], 'Y')
            ymd.append(s[4:6])
            ymd.append(s[6:8])

            if len_li > 8:
                res.hour = int(s[8:10])
                res.minute = int(s[10:12])

                if len_li > 12:
                    res.second = int(s[12:])

        elif self._find_hms_idx(idx, tokens, info, allow_jump=True) is not None:
            # HH[ ]h or MM[ ]m or SS[.ss][ ]s
            hms_idx = self._find_hms_idx(idx, tokens, info, allow_jump=True)
            (idx, hms) = self._parse_hms(idx, tokens, info, hms_idx)
            if hms is not None:
                # TODO: checking that hour/minute/second are not
                # already set?
                self._assign_hms(res, value_repr, hms)

        elif idx + 2 < len_l and tokens[idx + 1] == ':':
            # HH:MM[:SS[.ss]]
            res.hour = int(value)
            value = self._to_decimal(tokens[idx + 2])  # TODO: try/except for this?
            (res.minute, res.second) = self._parse_min_sec(value)

            if idx + 4 < len_l and tokens[idx + 3] == ':':
                res.second, res.microsecond = self._parsems(tokens[idx + 4])

                idx += 2

            idx += 2

        elif idx + 1 < len_l and tokens[idx + 1] in ('-', '/', '.'):
            sep = tokens[idx + 1]
            ymd.append(value_repr)

            if idx + 2 < len_l and not info.jump(tokens[idx + 2]):
                if tokens[idx + 2].isdigit():
                    # 01-01[-01]
                    ymd.append(tokens[idx + 2])
                else:
                    # 01-Jan[-01]
                    value = info.month(tokens[idx + 2])

                    if value is not None:
                        ymd.append(value, 'M')
                    else:
                        raise ValueError()

                if idx + 3 < len_l and tokens[idx + 3] == sep:
                    # We have three members
                    value = info.month(tokens[idx + 4])

                    if value is not None:
                        ymd.append(value, 'M')
                    else:
                        ymd.append(tokens[idx + 4])
                    idx += 2

                idx += 1
            idx += 1

        elif idx + 1 >= len_l or info.jump(tokens[idx + 1]):
            if idx + 2 < len_l and info.ampm(tokens[idx + 2]) is not None:
                # 12 am
                hour = int(value)
                res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 2]))
                idx += 1
            else:
                # Year, month or day
                ymd.append(value)
            idx += 1

        elif info.ampm(tokens[idx + 1]) is not None and (0 <= value < 24):
            # 12am
            hour = int(value)
            res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 1]))
            idx += 1

        elif ymd.could_be_day(value):
            ymd.append(value)

        elif not fuzzy:
            raise ValueError()

        return idx

    def _find_hms_idx(self, idx, tokens, info, allow_jump):
        len_l = len(tokens)

        if idx+1 < len_l and info.hms(tokens[idx+1]) is not None:
            # There is an "h", "m", or "s" label following this token.  We take
            # assign the upcoming label to the current token.
            # e.g. the "12" in 12h"
            hms_idx = idx + 1

        elif (allow_jump and idx+2 < len_l and tokens[idx+1] == ' ' and
              info.hms(tokens[idx+2]) is not None):
            # There is a space and then an "h", "m", or "s" label.
            # e.g. the "12" in "12 h"
            hms_idx = idx + 2

        elif idx > 0 and info.hms(tokens[idx-1]) is not None:
            # There is a "h", "m", or "s" preceding this token.  Since neither
            # of the previous cases was hit, there is no label following this
            # token, so we use the previous label.
            # e.g. the "04" in "12h04"
            hms_idx = idx-1

        elif (1 < idx == len_l-1 and tokens[idx-1] == ' ' and
              info.hms(tokens[idx-2]) is not None):
            # If we are looking at the final token, we allow for a
            # backward-looking check to skip over a space.
            # TODO: Are we sure this is the right condition here?
            hms_idx = idx - 2

        else:
            hms_idx = None

        return hms_idx

    def _assign_hms(self, res, value_repr, hms):
        # See GH issue #427, fixing float rounding
        value = self._to_decimal(value_repr)

        if hms == 0:
            # Hour
            res.hour = int(value)
            if value % 1:
                res.minute = int(60*(value % 1))

        elif hms == 1:
            (res.minute, res.second) = self._parse_min_sec(value)

        elif hms == 2:
            (res.second, res.microsecond) = self._parsems(value_repr)

    def _could_be_tzname(self, hour, tzname, tzoffset, token):
        return (hour is not None and
                tzname is None and
                tzoffset is None and
                len(token) <= 5 and
                (all(x in string.ascii_uppercase for x in token)
                 or token in self.info.UTCZONE))

    def _ampm_valid(self, hour, ampm, fuzzy):
        """
        For fuzzy parsing, 'a' or 'am' (both valid English words)
        may erroneously trigger the AM/PM flag. Deal with that
        here.
        """
        val_is_ampm = True

        # If there's already an AM/PM flag, this one isn't one.
        if fuzzy and ampm is not None:
            val_is_ampm = False

        # If AM/PM is found and hour is not, raise a ValueError
        if hour is None:
            if fuzzy:
                val_is_ampm = False
            else:
                raise ValueError('No hour specified with AM or PM flag.')
        elif not 0 <= hour <= 12:
            # If AM/PM is found, it's a 12 hour clock, so raise
            # an error for invalid range
            if fuzzy:
                val_is_ampm = False
            else:
                raise ValueError('Invalid hour specified for 12-hour clock.')

        return val_is_ampm

    def _adjust_ampm(self, hour, ampm):
        if hour < 12 and ampm == 1:
            hour += 12
        elif hour == 12 and ampm == 0:
            hour = 0
        return hour

    def _parse_min_sec(self, value):
        # TODO: Every usage of this function sets res.second to the return
        # value. Are there any cases where second will be returned as None and
        # we *don't* want to set res.second = None?
        minute = int(value)
        second = None

        sec_remainder = value % 1
        if sec_remainder:
            second = int(60 * sec_remainder)
        return (minute, second)

    def _parse_hms(self, idx, tokens, info, hms_idx):
        # TODO: Is this going to admit a lot of false-positives for when we
        # just happen to have digits and "h", "m" or "s" characters in non-date
        # text?  I guess hex hashes won't have that problem, but there's plenty
        # of random junk out there.
        if hms_idx is None:
            hms = None
            new_idx = idx
        elif hms_idx > idx:
            hms = info.hms(tokens[hms_idx])
            new_idx = hms_idx
        else:
            # Looking backwards, increment one.
            hms = info.hms(tokens[hms_idx]) + 1
            new_idx = idx

        return (new_idx, hms)

    # ------------------------------------------------------------------
    # Handling for individual tokens.  These are kept as methods instead
    #  of functions for the sake of customizability via subclassing.

    def _parsems(self, value):
        """Parse a I[.F] seconds value into (seconds, microseconds)."""
        if "." not in value:
            return int(value), 0
        else:
            i, f = value.split(".")
            return int(i), int(f.ljust(6, "0")[:6])

    def _to_decimal(self, val):
        try:
            decimal_value = Decimal(val)
            # See GH 662, edge case, infinite value should not be converted
            #  via `_to_decimal`
            if not decimal_value.is_finite():
                raise ValueError("Converted decimal value is infinite or NaN")
        except Exception as e:
            msg = "Could not convert %s to decimal" % val
            six.raise_from(ValueError(msg), e)
        else:
            return decimal_value

    # ------------------------------------------------------------------
    # Post-Parsing construction of datetime output.  These are kept as
    #  methods instead of functions for the sake of customizability via
    #  subclassing.

    def _build_tzinfo(self, tzinfos, tzname, tzoffset):
        if callable(tzinfos):
            tzdata = tzinfos(tzname, tzoffset)
        else:
            tzdata = tzinfos.get(tzname)
        # handle case where tzinfo is paased an options that returns None
        # eg tzinfos = {'BRST' : None}
        if isinstance(tzdata, datetime.tzinfo) or tzdata is None:
            tzinfo = tzdata
        elif isinstance(tzdata, text_type):
            tzinfo = tz.tzstr(tzdata)
        elif isinstance(tzdata, integer_types):
            tzinfo = tz.tzoffset(tzname, tzdata)
        else:
            raise TypeError("Offset must be tzinfo subclass, tz string, "
                            "or int offset.")
        return tzinfo

    def _build_tzaware(self, naive, res, tzinfos):
        if (callable(tzinfos) or (tzinfos and res.tzname in tzinfos)):
            tzinfo = self._build_tzinfo(tzinfos, res.tzname, res.tzoffset)
            aware = naive.replace(tzinfo=tzinfo)
            aware = self._assign_tzname(aware, res.tzname)

        elif res.tzname and res.tzname in time.tzname:
            aware = naive.replace(tzinfo=tz.tzlocal())

            # Handle ambiguous local datetime
            aware = self._assign_tzname(aware, res.tzname)

            # This is mostly relevant for winter GMT zones parsed in the UK
            if (aware.tzname() != res.tzname and
                    res.tzname in self.info.UTCZONE):
                aware = aware.replace(tzinfo=tz.UTC)

        elif res.tzoffset == 0:
            aware = naive.replace(tzinfo=tz.UTC)

        elif res.tzoffset:
            aware = naive.replace(tzinfo=tz.tzoffset(res.tzname, res.tzoffset))

        elif not res.tzname and not res.tzoffset:
            # i.e. no timezone information was found.
            aware = naive

        elif res.tzname:
            # tz-like string was parsed but we don't know what to do
            # with it
            warnings.warn("tzname {tzname} identified but not understood.  "
                          "Pass `tzinfos` argument in order to correctly "
                          "return a timezone-aware datetime.  In a future "
                          "version, this will raise an "
                          "exception.".format(tzname=res.tzname),
                          category=UnknownTimezoneWarning)
            aware = naive

        return aware

    def _build_naive(self, res, default):
        repl = {}
        for attr in ("year", "month", "day", "hour",
                     "minute", "second", "microsecond"):
            value = getattr(res, attr)
            if value is not None:
                repl[attr] = value

        if 'day' not in repl:
            # If the default day exceeds the last day of the month, fall back
            # to the end of the month.
            cyear = default.year if res.year is None else res.year
            cmonth = default.month if res.month is None else res.month
            cday = default.day if res.day is None else res.day

            if cday > monthrange(cyear, cmonth)[1]:
                repl['day'] = monthrange(cyear, cmonth)[1]

        naive = default.replace(**repl)

        if res.weekday is not None and not res.day:
            naive = naive + relativedelta.relativedelta(weekday=res.weekday)

        return naive

    def _assign_tzname(self, dt, tzname):
        if dt.tzname() != tzname:
            new_dt = tz.enfold(dt, fold=1)
            if new_dt.tzname() == tzname:
                return new_dt

        return dt

    def _recombine_skipped(self, tokens, skipped_idxs):
        """
        >>> tokens = ["foo", " ", "bar", " ", "19June2000", "baz"]
        >>> skipped_idxs = [0, 1, 2, 5]
        >>> _recombine_skipped(tokens, skipped_idxs)
        ["foo bar", "baz"]
        """
        skipped_tokens = []
        for i, idx in enumerate(sorted(skipped_idxs)):
            if i > 0 and idx - 1 == skipped_idxs[i - 1]:
                skipped_tokens[-1] = skipped_tokens[-1] + tokens[idx]
            else:
                skipped_tokens.append(tokens[idx])

        return skipped_tokens


DEFAULTPARSER = parser()


def parse(timestr, parserinfo=None, **kwargs):
    """

    Parse a string in one of the supported formats, using the
    ``parserinfo`` parameters.

    :param timestr:
        A string containing a date/time stamp.

    :param parserinfo:
        A :class:`parserinfo` object containing parameters for the parser.
        If ``None``, the default arguments to the :class:`parserinfo`
        constructor are used.

    The ``**kwargs`` parameter takes the following keyword arguments:

    :param default:
        The default datetime object, if this is a datetime object and not
        ``None``, elements specified in ``timestr`` replace elements in the
        default object.

    :param ignoretz:
        If set ``True``, time zones in parsed strings are ignored and a naive
        :class:`datetime` object is returned.

    :param tzinfos:
        Additional time zone names / aliases which may be present in the
        string. This argument maps time zone names (and optionally offsets
        from those time zones) to time zones. This parameter can be a
        dictionary with timezone aliases mapping time zone names to time
        zones or a function taking two parameters (``tzname`` and
        ``tzoffset``) and returning a time zone.

        The timezones to which the names are mapped can be an integer
        offset from UTC in seconds or a :class:`tzinfo` object.

        .. doctest::
           :options: +NORMALIZE_WHITESPACE

            >>> from dateutil.parser import parse
            >>> from dateutil.tz import gettz
            >>> tzinfos = {"BRST": -7200, "CST": gettz("America/Chicago")}
            >>> parse("2012-01-19 17:21:00 BRST", tzinfos=tzinfos)
            datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))
            >>> parse("2012-01-19 17:21:00 CST", tzinfos=tzinfos)
            datetime.datetime(2012, 1, 19, 17, 21,
                              tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))

        This parameter is ignored if ``ignoretz`` is set.

    :param dayfirst:
        Whether to interpret the first value in an ambiguous 3-integer date
        (e.g. 01/05/09) as the day (``True``) or month (``False``). If
        ``yearfirst`` is set to ``True``, this distinguishes between YDM and
        YMD. If set to ``None``, this value is retrieved from the current
        :class:`parserinfo` object (which itself defaults to ``False``).

    :param yearfirst:
        Whether to interpret the first value in an ambiguous 3-integer date
        (e.g. 01/05/09) as the year. If ``True``, the first number is taken to
        be the year, otherwise the last number is taken to be the year. If
        this is set to ``None``, the value is retrieved from the current
        :class:`parserinfo` object (which itself defaults to ``False``).

    :param fuzzy:
        Whether to allow fuzzy parsing, allowing for string like "Today is
        January 1, 2047 at 8:21:00AM".

    :param fuzzy_with_tokens:
        If ``True``, ``fuzzy`` is automatically set to True, and the parser
        will return a tuple where the first element is the parsed
        :class:`datetime.datetime` datetimestamp and the second element is
        a tuple containing the portions of the string which were ignored:

        .. doctest::

            >>> from dateutil.parser import parse
            >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
            (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))

    :return:
        Returns a :class:`datetime.datetime` object or, if the
        ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
        first element being a :class:`datetime.datetime` object, the second
        a tuple containing the fuzzy tokens.

    :raises ValueError:
        Raised for invalid or unknown string format, if the provided
        :class:`tzinfo` is not in a valid format, or if an invalid date
        would be created.

    :raises OverflowError:
        Raised if the parsed date exceeds the largest valid C integer on
        your system.
    """
    if parserinfo:
        return parser(parserinfo).parse(timestr, **kwargs)
    else:
        return DEFAULTPARSER.parse(timestr, **kwargs)


class _tzparser(object):

    class _result(_resultbase):

        __slots__ = ["stdabbr", "stdoffset", "dstabbr", "dstoffset",
                     "start", "end"]

        class _attr(_resultbase):
            __slots__ = ["month", "week", "weekday",
                         "yday", "jyday", "day", "time"]

        def __repr__(self):
            return self._repr("")

        def __init__(self):
            _resultbase.__init__(self)
            self.start = self._attr()
            self.end = self._attr()

    def parse(self, tzstr):
        res = self._result()
        l = [x for x in re.split(r'([,:.]|[a-zA-Z]+|[0-9]+)',tzstr) if x]
        used_idxs = list()
        try:

            len_l = len(l)

            i = 0
            while i < len_l:
                # BRST+3[BRDT[+2]]
                j = i
                while j < len_l and not [x for x in l[j]
                                         if x in "0123456789:,-+"]:
                    j += 1
                if j != i:
                    if not res.stdabbr:
                        offattr = "stdoffset"
                        res.stdabbr = "".join(l[i:j])
                    else:
                        offattr = "dstoffset"
                        res.dstabbr = "".join(l[i:j])

                    for ii in range(j):
                        used_idxs.append(ii)
                    i = j
                    if (i < len_l and (l[i] in ('+', '-') or l[i][0] in
                                       "0123456789")):
                        if l[i] in ('+', '-'):
                            # Yes, that's right.  See the TZ variable
                            # documentation.
                            signal = (1, -1)[l[i] == '+']
                            used_idxs.append(i)
                            i += 1
                        else:
                            signal = -1
                        len_li = len(l[i])
                        if len_li == 4:
                            # -0300
                            setattr(res, offattr, (int(l[i][:2]) * 3600 +
                                                   int(l[i][2:]) * 60) * signal)
                        elif i + 1 < len_l and l[i + 1] == ':':
                            # -03:00
                            setattr(res, offattr,
                                    (int(l[i]) * 3600 +
                                     int(l[i + 2]) * 60) * signal)
                            used_idxs.append(i)
                            i += 2
                        elif len_li <= 2:
                            # -[0]3
                            setattr(res, offattr,
                                    int(l[i][:2]) * 3600 * signal)
                        else:
                            return None
                        used_idxs.append(i)
                        i += 1
                    if res.dstabbr:
                        break
                else:
                    break


            if i < len_l:
                for j in range(i, len_l):
                    if l[j] == ';':
                        l[j] = ','

                assert l[i] == ','

                i += 1

            if i >= len_l:
                pass
            elif (8 <= l.count(',') <= 9 and
                  not [y for x in l[i:] if x != ','
                       for y in x if y not in "0123456789+-"]):
                # GMT0BST,3,0,30,3600,10,0,26,7200[,3600]
                for x in (res.start, res.end):
                    x.month = int(l[i])
                    used_idxs.append(i)
                    i += 2
                    if l[i] == '-':
                        value = int(l[i + 1]) * -1
                        used_idxs.append(i)
                        i += 1
                    else:
                        value = int(l[i])
                    used_idxs.append(i)
                    i += 2
                    if value:
                        x.week = value
                        x.weekday = (int(l[i]) - 1) % 7
                    else:
                        x.day = int(l[i])
                    used_idxs.append(i)
                    i += 2
                    x.time = int(l[i])
                    used_idxs.append(i)
                    i += 2
                if i < len_l:
                    if l[i] in ('-', '+'):
                        signal = (-1, 1)[l[i] == "+"]
                        used_idxs.append(i)
                        i += 1
                    else:
                        signal = 1
                    used_idxs.append(i)
                    res.dstoffset = (res.stdoffset + int(l[i]) * signal)

                # This was a made-up format that is not in normal use
                warn(('Parsed time zone "%s"' % tzstr) +
                     'is in a non-standard dateutil-specific format, which ' +
                     'is now deprecated; support for parsing this format ' +
                     'will be removed in future versions. It is recommended ' +
                     'that you switch to a standard format like the GNU ' +
                     'TZ variable format.', tz.DeprecatedTzFormatWarning)
            elif (l.count(',') == 2 and l[i:].count('/') <= 2 and
                  not [y for x in l[i:] if x not in (',', '/', 'J', 'M',
                                                     '.', '-', ':')
                       for y in x if y not in "0123456789"]):
                for x in (res.start, res.end):
                    if l[i] == 'J':
                        # non-leap year day (1 based)
                        used_idxs.append(i)
                        i += 1
                        x.jyday = int(l[i])
                    elif l[i] == 'M':
                        # month[-.]week[-.]weekday
                        used_idxs.append(i)
                        i += 1
                        x.month = int(l[i])
                        used_idxs.append(i)
                        i += 1
                        assert l[i] in ('-', '.')
                        used_idxs.append(i)
                        i += 1
                        x.week = int(l[i])
                        if x.week == 5:
                            x.week = -1
                        used_idxs.append(i)
                        i += 1
                        assert l[i] in ('-', '.')
                        used_idxs.append(i)
                        i += 1
                        x.weekday = (int(l[i]) - 1) % 7
                    else:
                        # year day (zero based)
                        x.yday = int(l[i]) + 1

                    used_idxs.append(i)
                    i += 1

                    if i < len_l and l[i] == '/':
                        used_idxs.append(i)
                        i += 1
                        # start time
                        len_li = len(l[i])
                        if len_li == 4:
                            # -0300
                            x.time = (int(l[i][:2]) * 3600 +
                                      int(l[i][2:]) * 60)
                        elif i + 1 < len_l and l[i + 1] == ':':
                            # -03:00
                            x.time = int(l[i]) * 3600 + int(l[i + 2]) * 60
                            used_idxs.append(i)
                            i += 2
                            if i + 1 < len_l and l[i + 1] == ':':
                                used_idxs.append(i)
                                i += 2
                                x.time += int(l[i])
                        elif len_li <= 2:
                            # -[0]3
                            x.time = (int(l[i][:2]) * 3600)
                        else:
                            return None
                        used_idxs.append(i)
                        i += 1

                    assert i == len_l or l[i] == ','

                    i += 1

                assert i >= len_l

        except (IndexError, ValueError, AssertionError):
            return None

        unused_idxs = set(range(len_l)).difference(used_idxs)
        res.any_unused_tokens = not {l[n] for n in unused_idxs}.issubset({",",":"})
        return res


DEFAULTTZPARSER = _tzparser()


def _parsetz(tzstr):
    return DEFAULTTZPARSER.parse(tzstr)


class ParserError(ValueError):
    """Error class for representing failure to parse a datetime string."""
    def __str__(self):
        try:
            return self.args[0] % self.args[1:]
        except (TypeError, IndexError):
            return super(ParserError, self).__str__()

        def __repr__(self):
            return "%s(%s)" % (self.__class__.__name__, str(self))


class UnknownTimezoneWarning(RuntimeWarning):
    """Raised when the parser finds a timezone it cannot parse into a tzinfo"""
# vim:ts=4:sw=4:et
# -*- coding: utf-8 -*-
from ._parser import parse, parser, parserinfo, ParserError
from ._parser import DEFAULTPARSER, DEFAULTTZPARSER
from ._parser import UnknownTimezoneWarning

from ._parser import __doc__

from .isoparser import isoparser, isoparse

__all__ = ['parse', 'parser', 'parserinfo',
           'isoparse', 'isoparser',
           'ParserError',
           'UnknownTimezoneWarning']


###
# Deprecate portions of the private interface so that downstream code that
# is improperly relying on it is given *some* notice.


def __deprecated_private_func(f):
    from functools import wraps
    import warnings

    msg = ('{name} is a private function and may break without warning, '
           'it will be moved and or renamed in future versions.')
    msg = msg.format(name=f.__name__)

    @wraps(f)
    def deprecated_func(*args, **kwargs):
        warnings.warn(msg, DeprecationWarning)
        return f(*args, **kwargs)

    return deprecated_func

def __deprecate_private_class(c):
    import warnings

    msg = ('{name} is a private class and may break without warning, '
           'it will be moved and or renamed in future versions.')
    msg = msg.format(name=c.__name__)

    class private_class(c):
        __doc__ = c.__doc__

        def __init__(self, *args, **kwargs):
            warnings.warn(msg, DeprecationWarning)
            super(private_class, self).__init__(*args, **kwargs)

    private_class.__name__ = c.__name__

    return private_class


from ._parser import _timelex, _resultbase
from ._parser import _tzparser, _parsetz

_timelex = __deprecate_private_class(_timelex)
_tzparser = __deprecate_private_class(_tzparser)
_resultbase = __deprecate_private_class(_resultbase)
_parsetz = __deprecated_private_func(_parsetz)
U
    ^*3                     @   s|   d Z ddlmZmZmZmZ ddlZddlmZ ddlm	Z	 ddl
Z
ddlZddgZdd	 ZG d
d deZe ZejZdS )z
This module offers a parser for ISO-8601 strings

It is intended to support all valid date, time and datetime formats per the
ISO-8601 specification.

..versionadded:: 2.7.0
    )datetime	timedeltatimedateN)tzwrapsisoparse	isoparserc                    s   t   fdd}|S )Nc              
      sz   t  d fdd  t tjrhz d W n6 tk
rf } zd}tt|| W 5 d }~X Y nX |  f||S )Nreadc                      s    S N r   str_inr   ZC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\parser\isoparser.py<lambda>       z,_takes_ascii.<locals>.func.<locals>.<lambda>asciiz5ISO-8601 strings should contain only ASCII characters)getattr
isinstancesix	text_typeencodeUnicodeEncodeError
raise_from
ValueError)selfr   argskwargsemsgfr   r   func   s    "z_takes_ascii.<locals>.funcr   )r"   r#   r   r!   r   _takes_ascii   s    r$   c                   @   s   e Zd ZdddZedd Zedd Zedd	 ZedddZdZ	dZ
edZdd Zdd Zdd Zdd Zdd ZdddZdS )r
   Nc                 C   sD   |dk	r:t |dks(t|dks(|dkr0td|d}|| _dS )z
        :param sep:
            A single character that separates date and time portions. If
            ``None``, the parser will accept any single character.
            For strict ISO-8601 adherence, pass ``'T'``.
        N      
0123456789z7Separator must be a single, non-numeric ASCII characterr   )lenordr   r   _sep)r   sepr   r   r   __init__+   s
     
zisoparser.__init__c                 C   s   |  |\}}t||kr^| jdks:|||d  | jkrV|| ||d d 7 }ntdt|dkr|d dkrd|d< t| tdd S t| S )u+
  
        Parse an ISO-8601 datetime string into a :class:`datetime.datetime`.

        An ISO-8601 datetime string consists of a date portion, followed
        optionally by a time portion - the date and time portions are separated
        by a single character separator, which is ``T`` in the official
        standard. Incomplete date formats (such as ``YYYY-MM``) may *not* be
        combined with a time portion.

        Supported date formats are:

        Common:

        - ``YYYY``
        - ``YYYY-MM`` or ``YYYYMM``
        - ``YYYY-MM-DD`` or ``YYYYMMDD``

        Uncommon:

        - ``YYYY-Www`` or ``YYYYWww`` - ISO week (day defaults to 0)
        - ``YYYY-Www-D`` or ``YYYYWwwD`` - ISO week and day

        The ISO week and day numbering follows the same logic as
        :func:`datetime.date.isocalendar`.

        Supported time formats are:

        - ``hh``
        - ``hh:mm`` or ``hhmm``
        - ``hh:mm:ss`` or ``hhmmss``
        - ``hh:mm:ss.ssssss`` (Up to 6 sub-second digits)

        Midnight is a special case for `hh`, as the standard supports both
        00:00 and 24:00 as a representation. The decimal separator can be
        either a dot or a comma.


        .. caution::

            Support for fractional components other than seconds is part of the
            ISO-8601 standard, but is not currently implemented in this parser.

        Supported time zone offset formats are:

        - `Z` (UTC)
        - `HH:MM`
        - `HHMM`
        - `HH`

        Offsets will be represented as :class:`dateutil.tz.tzoffset` objects,
        with the exception of UTC, which will be represented as
        :class:`dateutil.tz.tzutc`. Time zone offsets equivalent to UTC (such
        as `+00:00`) will also be represented as :class:`dateutil.tz.tzutc`.

        :param dt_str:
            A string or stream containing only an ISO-8601 datetime string

        :return:
            Returns a :class:`datetime.datetime` representing the string.
            Unspecified components default to their lowest value.

        .. warning::

            As of version 2.7.0, the strictness of the parser should not be
            considered a stable part of the contract. Any valid ISO-8601 string
            that parses correctly with the default settings will continue to
            parse correctly in future versions, but invalid strings that
            currently fail (e.g. ``2017-01-01T00:00+00:00:00``) are not
            guaranteed to continue failing in future versions if they encode
            a valid date.

        .. versionadded:: 2.7.0
        Nr%   z&String contains unknown ISO components      r   days)_parse_isodater(   r*   _parse_isotimer   r   r   )r   dt_str
componentsposr   r   r   r	   ;   s    K zisoparser.isoparsec                 C   s4   |  |\}}|t|k r,tdd| t| S )z
        Parse the date portion of an ISO string.

        :param datestr:
            The string portion of an ISO string, without a separator

        :return:
            Returns a :class:`datetime.date` object
        zString contains unknown ISO zcomponents: {})r1   r(   r   formatr   )r   Zdatestrr4   r5   r   r   r   parse_isodate   s    zisoparser.parse_isodatec                 C   s&   |  |}|d dkrd|d< t| S )z
        Parse the time portion of an ISO string.

        :param timestr:
            The time portion of an ISO string, without a separator

        :return:
            Returns a :class:`datetime.time` object
        r   r.   )r2   r   )r   timestrr4   r   r   r   parse_isotime   s    
zisoparser.parse_isotimeTc                 C   s   | j ||dS )a  
        Parse a valid ISO time zone string.

        See :func:`isoparser.isoparse` for details on supported formats.

        :param tzstr:
            A string representing an ISO time zone offset

        :param zero_as_utc:
            Whether to return :class:`dateutil.tz.tzutc` for zero-offset zones

        :return:
            Returns :class:`dateutil.tz.tzoffset` for offsets and
            :class:`dateutil.tz.tzutc` for ``Z`` and (if ``zero_as_utc`` is
            specified) offsets equivalent to UTC.
        )zero_as_utc)_parse_tzstr)r   tzstrr:   r   r   r   parse_tzstr   s    zisoparser.parse_tzstr   -   :s   [\.,]([0-9]+)c                 C   s0   z|  |W S  tk
r*   | | Y S X d S r   )_parse_isodate_commonr   _parse_isodate_uncommon)r   r3   r   r   r   r1      s    zisoparser._parse_isodatec                 C   s  t |}dddg}|dk r"tdt|dd |d< d}||krJ||fS |||d  | jk}|rl|d7 }|| dk rtdt|||d  |d< |d7 }||kr|r||fS td|r|||d  | jkrtd|d7 }|| dk rtd	t|||d  |d< ||d fS )
Nr%      ISO string too shortr      zInvalid common monthzInvalid ISO formatzInvalid separator in ISO stringzInvalid common day)r(   r   int	_DATE_SEP)r   r3   len_strr4   r5   has_sepr   r   r   r@      s6    
zisoparser._parse_isodate_commonc           
      C   st  t |dk rtdt|dd }|dd | jk}d| }|||d  dkr|d7 }t|||d  }|d7 }d}t ||kr|||d  | jk|krtd||7 }t|||d  }|d7 }| |||}nt || d	k rtd
t|||d	  }|d	7 }|dk s.|dt| krBtd
d|| t|ddt	|d d }|j
|j|jg}	|	|fS )NrB   rC   r      r%      WrD   z"Inconsistent use of dash separatorr-   zInvalid ordinal dayim  z {} for year {}r/   )r(   r   rE   rF   _calculate_weekdatecalendarisleapr6   r   r   yearmonthday)
r   r3   rN   rH   r5   ZweeknoZdaynoZ	base_dateZordinal_dayr4   r   r   r   rA      s8    
z!isoparser._parse_isodate_uncommonc                 C   s   d|  k rdk s$n t d|d|  k r8dk sHn t d|t|dd}|t| d d d	 }|d d
 |d  }|t|d	 S )a  
        Calculate the day of corresponding to the ISO year-week-day calendar.

        This function is effectively the inverse of
        :func:`datetime.date.isocalendar`.

        :param year:
            The year in the ISO calendar

        :param week:
            The week in the ISO calendar - range is [1, 53]

        :param day:
            The day in the ISO calendar - range is [1 (MON), 7 (SUN)]

        :return:
            Returns a :class:`datetime.date`
        r   6   zInvalid week: {}   zInvalid weekday: {}r%   rB   rD   r/      )r   r6   r   r   isocalendar)r   rN   weekrP   Zjan_4Zweek_1Zweek_offsetr   r   r   rK   )  s    zisoparser._calculate_weekdatec           	      C   s  t |}ddddd g}d}d}t |dk r2td|dkoJ|dd | jk}||k rP|dk rP|d7 }|||d  dkr| ||d  |d< |}qP|dk rt|||d  ||< |d7 }|r||k r|||d  | jkr|d7 }|dkrL| j||d  }|sqL|dd d	 }t|d
d	t |   ||< |t | 7 }qL||k rbtd|d dkrtdd |dd D rtd|S )Nr   rD   zISO time too shortr-   rI   r%   s   -+Zz   
   zUnused components in ISO stringr.   c                 s   s   | ]}|d kV  qdS )r   Nr   ).0	componentr   r   r   	<genexpr>u  s     z+isoparser._parse_isotime.<locals>.<genexpr>rB   z#Hour may only be 24 at 24:00:00.000)	r(   r   	_TIME_SEPr;   rE   _FRACTION_REGEXmatchgroupany)	r   r8   rG   r4   r5   comprH   fracZus_strr   r   r   r2   J  sB    
zisoparser._parse_isotimec                 C   s   |dks|dkrt jS t|dkr*td|dd dkr@d}n|dd d	krVd}ntd
t|dd }t|dkrd}n&t||dd | jkrdndd  }|r|dkr|dkrt jS |dkrtd|dkrtdt d ||d |  d S d S )N   Z   z>   r-   rI   rW   z0Time zone offset must be 1, 3, 5 or 6 charactersr   r%   r>   rV      +zTime zone offset requires signr-   rB   ;   z#Invalid minutes in time zone offset   z!Invalid hours in time zone offset<   )r   UTCr(   r   rE   r\   tzoffset)r   r<   r:   Zmulthoursminutesr   r   r   r;   z  s(    &zisoparser._parse_tzstr)N)T)T)__name__
__module____qualname__r,   r$   r	   r7   r9   r=   rF   r\   recompiler]   r1   r@   rA   rK   r2   r;   r   r   r   r   r
   *   s$   

X


),!0)__doc__r   r   r   r   rL   Zdateutilr   	functoolsr   rp   r   __all__r$   objectr
   ZDEFAULT_ISOPARSERr	   r   r   r   r   <module>   s     rU
    ^                     @   sD  d Z ddlmZ ddlZddlZddlZddlZddlZddlm	Z	 ddl
mZ ddlZddlmZmZ ddlmZ ddlmZ d	d
lmZ d	dlmZ dddgZG dd deZG dd deZG dd deZG dd deZG dd deZe Zd ddZG dd deZe Z dd Z!G dd de"Z#G dd de$Z%dS )!a  
This module offers a generic date/time string parser which is able to parse
most known formats to represent a date and/or time.

This module attempts to be forgiving with regards to unlikely input formats,
returning a datetime object even for dates which are ambiguous. If an element
of a date/time stamp is omitted, the following rules are applied:

- If AM or PM is left unspecified, a 24-hour clock is assumed, however, an hour
  on a 12-hour clock (``0 <= hour <= 12``) *must* be specified if AM or PM is
  specified.
- If a time zone is omitted, a timezone-naive datetime is returned.

If any other elements are missing, they are taken from the
:class:`datetime.datetime` object passed to the parameter ``default``. If this
results in a day number exceeding the valid number of days per month, the
value falls back to the end of the month.

Additional resources about date/time string formats can be found below:

- `A summary of the international standard date and time notation
  <http://www.cl.cam.ac.uk/~mgk25/iso-time.html>`_
- `W3C Date and Time Formats <http://www.w3.org/TR/NOTE-datetime>`_
- `Time Formats (Planetary Rings Node) <https://pds-rings.seti.org:443/tools/time_formats.html>`_
- `CPAN ParseDate module
  <http://search.cpan.org/~muir/Time-modules-2013.0912/lib/Time/ParseDate.pm>`_
- `Java SimpleDateFormat Class
  <https://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html>`_
    )unicode_literalsN)
monthrange)StringIO)integer_types	text_type)Decimal)warn   )relativedelta)tzparse
parserinfoParserErrorc                   @   sn   e Zd ZedZdd Zdd Zdd Zdd	 Z	d
d Z
edd Zedd Zedd Zedd ZdS )_timelexz([.,])c                 C   s   t jrt|ttfr6| }nt|dd d k	r6| }t|trJt|}n$t|dd d krnt	dj
|jjd|| _g | _g | _d| _d S )Ndecodereadz8Parser must be a string or character stream, not {itype})itypeF)sixPY2
isinstancebytes	bytearrayr   getattrr   r   	TypeErrorformat	__class____name__instream	charstack
tokenstackeof)selfr    r"   XC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\parser\_parser.py__init__>   s    


z_timelex.__init__c                 C   s  | j r| j dS d}d}d}| js"| jr:| jd}n"| jd}|dkr\| jd}qF|sld| _q"q|s|}| |rd}n(| |rd}n| |rd	}q"nq"q|dkrd}| |r||7 }n&|d
kr||7 }d}n| j	| q"q|dkrX| |r||7 }n@|d
ks8|dkrFt
|dkrF||7 }d}n| j	| q"q|dkrd}|d
ks|| |r||7 }n8| |r|d d
kr||7 }d}n| j	| q"q|dkr|d
ks| |r||7 }q| |r|d d
kr||7 }d}q| j	| q"q|dkr|sP|d
dksP|d dkr| j|}|d }|dd D ]}|rp| j 	| qp|dkr|d
dkr|dd
}|S )a  
        This function breaks the time string into lexical units (tokens), which
        can be parsed by the parser. Lexical units are demarcated by changes in
        the character set, so any continuous string of letters is considered
        one unit, any continuous string of numbers is considered one unit.

        The main complication arises from the fact that dots ('.') can be used
        both as separators (e.g. "Sep.20.2009") or decimal points (e.g.
        "4:30:21.447"). As such, it is necessary to read the full context of
        any dot-separated strings before breaking it into tokens; as such, this
        function maintains a "token stack", for when the ambiguous context
        demands that multiple tokens be parsed at once.
        r   FN    Ta0 .a.,r	   0.)r+   r-   z.,)r   popr    r   r   r   iswordisnumisspaceappendlencount_split_decimalsplitreplace)r!   Zseenletterstokenstatenextcharltokr"   r"   r#   	get_tokenS   s    






"


 
z_timelex.get_tokenc                 C   s   | S Nr"   r!   r"   r"   r#   __iter__   s    z_timelex.__iter__c                 C   s   |   }|d krt|S r?   )r>   StopIteration)r!   r9   r"   r"   r#   __next__   s    z_timelex.__next__c                 C   s   |   S r?   )rC   r@   r"   r"   r#   next   s    z_timelex.nextc                 C   s   t | |S r?   )list)clssr"   r"   r#   r7      s    z_timelex.splitc                 C   s   |  S )z5 Whether or not the next character is part of a word )isalpharF   r;   r"   r"   r#   r0      s    z_timelex.iswordc                 C   s   |  S )z0 Whether the next character is part of a number )isdigitrI   r"   r"   r#   r1      s    z_timelex.isnumc                 C   s   |  S )z* Whether the next character is whitespace )r2   rI   r"   r"   r#   r2      s    z_timelex.isspaceN)r   
__module____qualname__recompiler6   r$   r>   rA   rC   rD   classmethodr7   r0   r1   r2   r"   r"   r"   r#   r   :   s   
m


r   c                   @   s,   e Zd Zdd Zdd Zdd Zdd Zd	S )
_resultbasec                 C   s   | j D ]}t| |d  qd S r?   )	__slots__setattr)r!   attrr"   r"   r#   r$      s    
z_resultbase.__init__c                 C   sJ   g }| j D ],}t| |}|d k	r
|d|t|f  q
d|d|f S )Nz%s=%s%s(%s)z, )rQ   r   r3   reprjoin)r!   	classnamer<   rS   valuer"   r"   r#   _repr   s    

z_resultbase._reprc                    s   t  fdd jD S )Nc                 3   s   | ]}t  |d k	V  qd S r?   )r   ).0rS   r@   r"   r#   	<genexpr>   s   z&_resultbase.__len__.<locals>.<genexpr>)sumrQ   r@   r"   r@   r#   __len__   s    z_resultbase.__len__c                 C   s   |  | jjS r?   )rY   r   r   r@   r"   r"   r#   __repr__   s    z_resultbase.__repr__N)r   rK   rL   r$   rY   r]   r^   r"   r"   r"   r#   rP      s   rP   c                   @   s   e Zd ZdZdddddddd	d
dddddddddgZdddddddgZdddddd d!d"d#d$d%d&gZd'd(d)gZd*d+gZd,d-d.d/gZ	dgZ
i ZdJd1d2Zd3d4 Zd5d6 Zd7d8 Zd9d: Zd;d< Zd=d> Zd?d@ ZdAdB ZdCdD ZdKdEdFZdGdH ZdIS )Lr   a  
    Class which handles what inputs are accepted. Subclass this to customize
    the language and acceptable values for each parameter.

    :param dayfirst:
        Whether to interpret the first value in an ambiguous 3-integer date
        (e.g. 01/05/09) as the day (``True``) or month (``False``). If
        ``yearfirst`` is set to ``True``, this distinguishes between YDM
        and YMD. Default is ``False``.

    :param yearfirst:
        Whether to interpret the first value in an ambiguous 3-integer date
        (e.g. 01/05/09) as the year. If ``True``, the first number is taken
        to be the year, otherwise the last number is taken to be the year.
        Default is ``False``.
    r)   r*   r,   ;-/'atonandadmtZofstZndrdth)MonZMonday)TueZTuesday)WedZ	Wednesday)ThuZThursday)FriZFriday)SatZSaturday)SunZSunday)JanJanuary)FebFebruary)MarZMarch)AprZApril)Mayry   )JunZJune)JulZJuly)AugZAugust)SepZSeptZ	September)OctZOctober)NovZNovember)DecZDecember)hhourhours)rg   minuteminutes)rG   secondseconds)amr'   )ZpmpUTCGMTZzFc                 C   s   |  | j| _|  | j| _|  | j| _|  | j| _|  | j	| _
|  | j| _|  | j| _|| _|| _t j| _| jd d | _d S )Nd   )_convertJUMP_jumpWEEKDAYS	_weekdaysMONTHS_monthsHMS_hmsAMPM_ampmUTCZONE_utczonePERTAIN_pertaindayfirst	yearfirsttime	localtimetm_year_year_century)r!   r   r   r"   r"   r#   r$   ,  s    zparserinfo.__init__c                 C   sH   i }t |D ]6\}}t|tr6|D ]}||| < q"q||| < q|S r?   )	enumerater   tuplelower)r!   lstdctivr"   r"   r#   r   ;  s    
zparserinfo._convertc                 C   s   |  | jkS r?   )r   r   r!   namer"   r"   r#   jumpE  s    zparserinfo.jumpc                 C   s*   z| j |  W S  tk
r$   Y nX d S r?   )r   r   KeyErrorr   r"   r"   r#   weekdayH  s
    zparserinfo.weekdayc                 C   s.   z| j |  d W S  tk
r(   Y nX d S Nr%   )r   r   r   r   r"   r"   r#   monthO  s
    zparserinfo.monthc                 C   s,   z| j |  W S  tk
r&   Y d S X d S r?   )r   r   r   r   r"   r"   r#   hmsV  s    zparserinfo.hmsc                 C   s,   z| j |  W S  tk
r&   Y d S X d S r?   )r   r   r   r   r"   r"   r#   ampm\  s    zparserinfo.ampmc                 C   s   |  | jkS r?   )r   r   r   r"   r"   r#   pertainb  s    zparserinfo.pertainc                 C   s   |  | jkS r?   )r   r   r   r"   r"   r#   utczonee  s    zparserinfo.utczonec                 C   s   || j krdS | j|S )Nr   )r   TZOFFSETgetr   r"   r"   r#   tzoffseth  s    
zparserinfo.tzoffsetc                 C   sT   |dkst |dk rP|sP|| j7 }|| jd kr:|d8 }n|| jd k rP|d7 }|S )zt
        Converts two-digit years to year within [-50, 49]
        range of self._year (current local time)
        r   r   2   )AssertionErrorr   r   )r!   yearcentury_specifiedr"   r"   r#   convertyearn  s    

zparserinfo.convertyearc                 C   st   |j d k	r| |j |j|_ |jdkr,|jr@|jdks@|jdkrNd|_d|_n"|jdkrp|jrp| |jrpd|_dS )Nr   r   r   r   T)r   r   r   r   tznamer   )r!   resr"   r"   r#   validate  s    
zparserinfo.validateN)FF)F)r   rK   rL   __doc__r   r   r   r   r   r   r   r   r$   r   r   r   r   r   r   r   r   r   r   r   r"   r"   r"   r#   r      sr            


c                       sf   e Zd Z fddZedd Zedd Zedd Zd	d
 Zd fdd	Z	dd Z
dd Z  ZS )_ymdc                    s0   t | j| j|| d| _d | _d | _d | _d S )NF)superr   r$   r   dstridxmstridxystridx)r!   argskwargsr   r"   r#   r$     s
    z_ymd.__init__c                 C   s
   | j d k	S r?   )r   r@   r"   r"   r#   has_year  s    z_ymd.has_yearc                 C   s
   | j d k	S r?   )r   r@   r"   r"   r#   	has_month  s    z_ymd.has_monthc                 C   s
   | j d k	S r?   )r   r@   r"   r"   r#   has_day  s    z_ymd.has_dayc                 C   s   | j r
dS | js(d|  ko"dkS   S | jsZ| | j }d|  koTtd|d kS   S | | j }| | j }d|  kot||d kS   S d S )NFr%      i  )r   r   r   r   r   r   )r!   rX   r   r   r"   r"   r#   could_be_day  s    
"

z_ymd.could_be_dayNc                    s   t |dr:| r\t|dkr\d| _|dkr4t|d}n"|dkr\d| _|dkrXt|d}t| j| t| |dkr| j	rtdt| d	 | _
nJ|d
kr| jrtdt| d	 | _n$|dkr| jrtdt| d	 | _d S )Nr]   r	   T)NYr   r   MzMonth is already setr%   DzDay is already setzYear is already set)hasattrrJ   r4   r   
ValueErrorr   r   r3   intr   r   r   r   r   r   )r!   vallabelr   r"   r#   r3     s0    
z_ymd.appendc                    s   t  dkrzt dkrzfddtdD }fdddD }t |t |  kr\dksbn t|d }|d }||< t  t kst fd	d
D }|d|d|dfS )z
        Try to resolve the identities of year/month/day elements using
        ystridx, mstridx, and dstridx, if enough of these are specified.
           r	   c                    s   g | ]}|   kr|qS r"   )valuesrZ   xstridsr"   r#   
<listcomp>  s      z._ymd._resolve_from_stridxs.<locals>.<listcomp>c                    s   g | ]}| kr|qS r"   r"   r   r   r"   r#   r     s      )yrg   dr%   r   c                    s   i | ]}| |  qS r"   r"   )rZ   keyr!   r   r"   r#   
<dictcomp>  s      z._ymd._resolve_from_stridxs.<locals>.<dictcomp>r   rg   r   )r4   ranger   r   )r!   r   missingr   r   outr"   r   r#   _resolve_from_stridxs  s    "z_ymd._resolve_from_stridxsc           
      C   s  t | }d\}}}d| jfd| jfd| jff}dd |D }t | t |  krXdksrn t | dkr|t |d	kr|| |S | j}|dkrtd
n|dks|d k	r|d	kr|d k	r| | }| |d  }	n| d }	|dks|d kr|	dkr|	}n|	}n|d	kr^| d dkr| \}}n>| d dkr4| \}}n&|rR| d dkrR| \}}n| \}}nP|dkr|dkr| d dkr| \}}}n
| \}}}n|dkr| d dks|r| d	 dkr| \}}}n
| \}}}n|d	kr| d dkr| \}}}n
| \}}}n| d dksJ| jdksJ|rv| d dkrv| d	 dkrv|rj| d	 dkrj| \}}}n
| \}}}n8| d dks|r| d dkr| \}}}n
| \}}}|||fS )N)NNNr   rg   r   c                 S   s   i | ]\}}|d k	r||qS r?   r"   )rZ   r   r   r"   r"   r#   r     s       z$_ymd.resolve_ymd.<locals>.<dictcomp>r   r   r	   zMore than three YMD valuesr%   r      )r4   r   r   r   r   r   )
r!   r   r   Zlen_ymdr   r   dayr   r   otherr"   r"   r#   resolve_ymd  s|    










"


"
z_ymd.resolve_ymd)N)r   rK   rL   r$   propertyr   r   r   r   r3   r   r   __classcell__r"   r"   r   r#   r     s   


r   c                   @   s   e Zd Zd)ddZd*ddZG dd deZd+d	d
Zdd Zdd Z	dd Z
dd Zdd Zdd Zdd Zdd Zdd Zdd Zdd  Zd!d" Zd#d$ Zd%d& Zd'd( ZdS ),parserNc                 C   s   |pt  | _d S r?   )r   info)r!   r   r"   r"   r#   r$   ?  s    zparser.__init__Fc           
   
   K   s   |dkr t j  jddddd}| j|f|\}}|dkrDtd|t|dkrZtd|z| ||}W n> tk
r }	 z t	t|	j
d d ||	 W 5 d}	~	X Y nX |s| |||}|ddr||fS |S dS )	aW
  
        Parse the date/time string into a :class:`datetime.datetime` object.

        :param timestr:
            Any date/time string using the supported formats.

        :param default:
            The default datetime object, if this is a datetime object and not
            ``None``, elements specified in ``timestr`` replace elements in the
            default object.

        :param ignoretz:
            If set ``True``, time zones in parsed strings are ignored and a
            naive :class:`datetime.datetime` object is returned.

        :param tzinfos:
            Additional time zone names / aliases which may be present in the
            string. This argument maps time zone names (and optionally offsets
            from those time zones) to time zones. This parameter can be a
            dictionary with timezone aliases mapping time zone names to time
            zones or a function taking two parameters (``tzname`` and
            ``tzoffset``) and returning a time zone.

            The timezones to which the names are mapped can be an integer
            offset from UTC in seconds or a :class:`tzinfo` object.

            .. doctest::
               :options: +NORMALIZE_WHITESPACE

                >>> from dateutil.parser import parse
                >>> from dateutil.tz import gettz
                >>> tzinfos = {"BRST": -7200, "CST": gettz("America/Chicago")}
                >>> parse("2012-01-19 17:21:00 BRST", tzinfos=tzinfos)
                datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))
                >>> parse("2012-01-19 17:21:00 CST", tzinfos=tzinfos)
                datetime.datetime(2012, 1, 19, 17, 21,
                                  tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))

            This parameter is ignored if ``ignoretz`` is set.

        :param \*\*kwargs:
            Keyword arguments as passed to ``_parse()``.

        :return:
            Returns a :class:`datetime.datetime` object or, if the
            ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
            first element being a :class:`datetime.datetime` object, the second
            a tuple containing the fuzzy tokens.

        :raises ParserError:
            Raised for invalid or unknown string format, if the provided
            :class:`tzinfo` is not in a valid format, or if an invalid date
            would be created.

        :raises TypeError:
            Raised for non-string or character stream input.

        :raises OverflowError:
            Raised if the parsed date exceeds the largest valid C integer on
            your system.
        Nr   )r   r   r   microsecondzUnknown string format: %sz"String does not contain a date: %sz: %sfuzzy_with_tokensF)datetimenowr8   _parser   r4   _build_naiver   r   
raise_fromr   _build_tzawarer   )
r!   timestrdefaultZignoretztzinfosr   r   skipped_tokensreter"   r"   r#   r   B  s&    @ 

.zparser.parsec                   @   s(   e Zd Zddddddddd	d
ddgZdS )zparser._resultr   r   r   r   r   r   r   r   r   r   r   any_unused_tokensNr   rK   rL   rQ   r"   r"   r"   r#   _result  s         r   c              	   C   sn  |rd}| j }|dkr|j}|dkr*|j}|  }t|}g }	t }
t|}d}z||k r|| }zt|}W n t	k
r   d}Y nX |dk	r| 
||||
||}n0||| dk	r||| }||_n||| dk	r ||| }|
|d |d |k r||d  dkr||d  }|
||d   |d |k r~||d  |kr~|
||d	   |d7 }|d7 }n|d	 |k r||d  ||d    krd
krn nZ|||d  r||d	   rt||d	  }t||}|
|d n |d	7 }n||| dk	r||| }| |j|j|}|rr| |j||_||_n|r|	| nX| |j|j|j|| r|| |_||j|_|d |k r||d  dkrd||d  dk ||d < d|_||jrd|_n|jdk	r|| dkrd|| dk }t||d  }|d	krt||d  dd }t||d  dd }nz|d |k r||d  dkrt||d  }t||d  }|d7 }n0|dkrt||d  dd }d}nt	|||d |d   |_|d |k r|||d  r||d  dkr||d  dkrdt||d	  kr| |j|jd||d	  r||d	  |_|d	7 }|d7 }n*||| s|st	|n
|	| |d7 }qV|
||\}}}|
j|_||_||_||_W n t t	fk
r2   Y dS X |!|sDdS |rb| "||	}|t#|fS |dfS dS )a  
        Private method which performs the heavy lifting of parsing, called from
        ``parse()``, which passes on its ``kwargs`` to this function.

        :param timestr:
            The string to parse.

        :param dayfirst:
            Whether to interpret the first value in an ambiguous 3-integer date
            (e.g. 01/05/09) as the day (``True``) or month (``False``). If
            ``yearfirst`` is set to ``True``, this distinguishes between YDM
            and YMD. If set to ``None``, this value is retrieved from the
            current :class:`parserinfo` object (which itself defaults to
            ``False``).

        :param yearfirst:
            Whether to interpret the first value in an ambiguous 3-integer date
            (e.g. 01/05/09) as the year. If ``True``, the first number is taken
            to be the year, otherwise the last number is taken to be the year.
            If this is set to ``None``, the value is retrieved from the current
            :class:`parserinfo` object (which itself defaults to ``False``).

        :param fuzzy:
            Whether to allow fuzzy parsing, allowing for string like "Today is
            January 1, 2047 at 8:21:00AM".

        :param fuzzy_with_tokens:
            If ``True``, ``fuzzy`` is automatically set to True, and the parser
            will return a tuple where the first element is the parsed
            :class:`datetime.datetime` datetimestamp and the second element is
            a tuple containing the portions of the string which were ignored:

            .. doctest::

                >>> from dateutil.parser import parse
                >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
                (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))

        TNr   r   r%   )r`   ra   r	   r      r)   r   +r`   r  r.   r%   :  <      ())NN)$r   r   r   r   r   r7   r   r4   floatr   _parse_numeric_tokenr   r   r3   r   rJ   r   strr   r   _ampm_validr   _adjust_ampm_could_be_tznamer   r   r   r   r   r   r   r   
IndexErrorr   _recombine_skippedr   )r!   r   r   r   fuzzyr   r   r   r<   skipped_idxsymdlen_lr   
value_reprrX   sepr   val_is_ampmsignallen_liZhour_offsetZ
min_offsetr   r   r   r"   r"   r#   r     s    )



 
:
 

 

 





zparser._parsec              
   C   sh  || }z|  |}W n2 tk
rH }	 zttd|	 W 5 d }	~	X Y nX t|}
t|}t|dkr|
dkr|jd kr|d |ks||d  dkr|||d  d kr|| }t|d d |_|
dkrt|dd  |_	n|
dks
|
dkr|| 
d	dkr|| }|s^d	|| kr^||d d  ||dd  ||dd   n>t|d d |_t|dd |_	| |dd  \|_|_n|
d
kr8|| }||d d d ||dd  ||dd  |
dkrdt|dd |_t|dd |_	|
dkrdt|dd  |_n,| j|||ddd k	r| j|||dd}| ||||\}}|d k	rd| ||| n|d |k r.||d  dkr.t||_|  ||d  }| |\|_	|_|d |k r"||d  dkr"| ||d  \|_|_|d7 }|d7 }n6|d |k rT||d  dkrT||d  }|| |d |k rH|||d  sH||d   r|||d   n0|||d  }|d k	r||d nt |d |k r@||d  |kr@|||d  }|d k	r&||d n|||d   |d7 }|d7 }|d7 }n|d |ksv|||d  r|d |k r|||d  d k	rt|}| ||||d  |_|d7 }n
|| |d7 }n|||d  d k	r@d|  krdk r@n n.t|}| ||||d  |_|d7 }n$||rX|| n|sdt |S )NzUnknown numeric tokenr   )r	   r  r%   r  r	   r     r*   )   r      r   r  
   r   T)
allow_jump)r`   ra   r*   r   r      )_to_decimal	Exceptionr   r   r   r4   r   r   r   r   findr3   _parsemsr   r   _find_hms_idx
_parse_hms_assign_hms_parse_min_secr   rJ   r   r   r  r   )r!   tokensidxr   r  r   r  r  rX   r   r  r  rG   hms_idxr   r  r   r"   r"   r#   r  q  s    "
(



 
  
"
 
"&


4
zparser._parse_numeric_tokenc                 C   s   t |}|d |k r4|||d  d k	r4|d }n|rt|d |k rt||d  dkrt|||d  d k	rt|d }nx|dkr|||d  d k	r|d }nPd|  k r|d krn n0||d  dkr|||d  d k	r|d }nd }|S )Nr%   r	   r)   r   )r4   r   )r!   r+  r*  r   r   r  r,  r"   r"   r#   r&    s    "
 

,
zparser._find_hms_idxc                 C   sr   |  |}|dkr8t||_|d rntd|d  |_n6|dkrT| |\|_|_n|dkrn| |\|_|_d S )Nr   r%   r  r	   )r"  r   r   r   r)  r   r%  r   )r!   r   r  r   rX   r"   r"   r#   r(    s    

zparser._assign_hmsc                 C   sB   |d k	o@|d ko@|d ko@t |dko@tdd |D p@|| jjkS )Nr  c                 s   s   | ]}|t jkV  qd S r?   )stringascii_uppercaser   r"   r"   r#   r[   +  s     z*parser._could_be_tzname.<locals>.<genexpr>)r4   allr   r   )r!   r   r   r   r9   r"   r"   r#   r  &  s    

zparser._could_be_tznamec                 C   s\   d}|r|dk	rd}|dkr0|r&d}qXt dn(d|  krDdksXn |rPd}nt d|S )z
        For fuzzy parsing, 'a' or 'am' (both valid English words)
        may erroneously trigger the AM/PM flag. Deal with that
        here.
        TNFz%No hour specified with AM or PM flag.r   r   z)Invalid hour specified for 12-hour clock.)r   )r!   r   r   r  r  r"   r"   r#   r  .  s    
zparser._ampm_validc                 C   s2   |dk r|dkr|d7 }n|dkr.|dkr.d}|S )Nr   r%   r   r"   )r!   r   r   r"   r"   r#   r  J  s
    
zparser._adjust_ampmc                 C   s,   t |}d }|d }|r$t d| }||fS )Nr%   r  )r   )r!   rX   r   r   Zsec_remainderr"   r"   r#   r)  Q  s    zparser._parse_min_secc                 C   sL   |d krd }|}n2||kr.| || }|}n| || d }|}||fS r   )r   )r!   r+  r*  r   r,  r   Znew_idxr"   r"   r#   r'  ]  s    zparser._parse_hmsc                 C   sF   d|krt |dfS |d\}}t |t |dddd fS dS )z9Parse a I[.F] seconds value into (seconds, microseconds).r*   r   r  r(   N)r   r7   ljust)r!   rX   r   fr"   r"   r#   r%  s  s    zparser._parsemsc              
   C   s`   zt |}| stdW n: tk
rV } zd| }tt|| W 5 d }~X Y nX |S d S )Nz*Converted decimal value is infinite or NaNzCould not convert %s to decimal)r   	is_finiter   r#  r   r   )r!   r   Zdecimal_valuer   msgr"   r"   r#   r"  {  s    "zparser._to_decimalc                 C   sr   t |r|||}n
||}t|tjs2|d kr8|}n6t|trNt|}n t|trft	||}nt
d|S )Nz9Offset must be tzinfo subclass, tz string, or int offset.)callabler   r   r   tzinfor   r   tzstrr   r   r   )r!   r   r   r   Ztzdatar5  r"   r"   r#   _build_tzinfo  s    


zparser._build_tzinfoc                 C   s  t |s|rD|j|krD| ||j|j}|j|d}| ||j}n|jr|jtjkr|jt d}| ||j}| |jkr|j| j	j
kr|jtjd}np|jdkr|jtjd}nV|jr|jt|j|jd}n6|js|js|}n$|jrtjdj|jdtd |}|S )N)r5  r   ztzname {tzname} identified but not understood.  Pass `tzinfos` argument in order to correctly return a timezone-aware datetime.  In a future version, this will raise an exception.)r   )category)r4  r   r7  r   r8   _assign_tznamer   r   Ztzlocalr   r   r   warningsr   r   UnknownTimezoneWarning)r!   naiver   r   r5  Zawarer"   r"   r#   r     s2    
zparser._build_tzawarec           
      C   s   i }dD ]}t ||}|d k	r|||< qd|kr|jd kr@|jn|j}|jd krV|jn|j}|jd krl|jn|j}|t||d krt||d |d< |jf |}	|jd k	r|js|	tj|jd }	|	S )N)r   r   r   r   r   r   r   r   r%   )r   )r   r   r   r   r   r8   r   r
   )
r!   r   r   replrS   rX   ZcyearZcmonthZcdayr<  r"   r"   r#   r     s    

zparser._build_naivec                 C   s.   |  |kr*tj|dd}|  |kr*|S |S )Nr%   )fold)r   r   Zenfold)r!   dtr   Znew_dtr"   r"   r#   r9    s
    zparser._assign_tznamec                 C   s^   g }t t|D ]H\}}|dkrJ|d ||d  krJ|d ||  |d< q|||  q|S )z
        >>> tokens = ["foo", " ", "bar", " ", "19June2000", "baz"]
        >>> skipped_idxs = [0, 1, 2, 5]
        >>> _recombine_skipped(tokens, skipped_idxs)
        ["foo bar", "baz"]
        r   r%   r.   )r   sortedr3   )r!   r*  r  r   r   r+  r"   r"   r#   r    s    zparser._recombine_skipped)N)NFN)NNFF)r   rK   rL   r$   r   rP   r   r   r  r&  r(  r  r  r  r)  r'  r%  r"  r7  r   r   r9  r  r"   r"   r"   r#   r   >  s4   
    
Y  
 R "(r   c                 K   s(   |rt |j| f|S tj| f|S dS )a  

    Parse a string in one of the supported formats, using the
    ``parserinfo`` parameters.

    :param timestr:
        A string containing a date/time stamp.

    :param parserinfo:
        A :class:`parserinfo` object containing parameters for the parser.
        If ``None``, the default arguments to the :class:`parserinfo`
        constructor are used.

    The ``**kwargs`` parameter takes the following keyword arguments:

    :param default:
        The default datetime object, if this is a datetime object and not
        ``None``, elements specified in ``timestr`` replace elements in the
        default object.

    :param ignoretz:
        If set ``True``, time zones in parsed strings are ignored and a naive
        :class:`datetime` object is returned.

    :param tzinfos:
        Additional time zone names / aliases which may be present in the
        string. This argument maps time zone names (and optionally offsets
        from those time zones) to time zones. This parameter can be a
        dictionary with timezone aliases mapping time zone names to time
        zones or a function taking two parameters (``tzname`` and
        ``tzoffset``) and returning a time zone.

        The timezones to which the names are mapped can be an integer
        offset from UTC in seconds or a :class:`tzinfo` object.

        .. doctest::
           :options: +NORMALIZE_WHITESPACE

            >>> from dateutil.parser import parse
            >>> from dateutil.tz import gettz
            >>> tzinfos = {"BRST": -7200, "CST": gettz("America/Chicago")}
            >>> parse("2012-01-19 17:21:00 BRST", tzinfos=tzinfos)
            datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))
            >>> parse("2012-01-19 17:21:00 CST", tzinfos=tzinfos)
            datetime.datetime(2012, 1, 19, 17, 21,
                              tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))

        This parameter is ignored if ``ignoretz`` is set.

    :param dayfirst:
        Whether to interpret the first value in an ambiguous 3-integer date
        (e.g. 01/05/09) as the day (``True``) or month (``False``). If
        ``yearfirst`` is set to ``True``, this distinguishes between YDM and
        YMD. If set to ``None``, this value is retrieved from the current
        :class:`parserinfo` object (which itself defaults to ``False``).

    :param yearfirst:
        Whether to interpret the first value in an ambiguous 3-integer date
        (e.g. 01/05/09) as the year. If ``True``, the first number is taken to
        be the year, otherwise the last number is taken to be the year. If
        this is set to ``None``, the value is retrieved from the current
        :class:`parserinfo` object (which itself defaults to ``False``).

    :param fuzzy:
        Whether to allow fuzzy parsing, allowing for string like "Today is
        January 1, 2047 at 8:21:00AM".

    :param fuzzy_with_tokens:
        If ``True``, ``fuzzy`` is automatically set to True, and the parser
        will return a tuple where the first element is the parsed
        :class:`datetime.datetime` datetimestamp and the second element is
        a tuple containing the portions of the string which were ignored:

        .. doctest::

            >>> from dateutil.parser import parse
            >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
            (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))

    :return:
        Returns a :class:`datetime.datetime` object or, if the
        ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
        first element being a :class:`datetime.datetime` object, the second
        a tuple containing the fuzzy tokens.

    :raises ValueError:
        Raised for invalid or unknown string format, if the provided
        :class:`tzinfo` is not in a valid format, or if an invalid date
        would be created.

    :raises OverflowError:
        Raised if the parsed date exceeds the largest valid C integer on
        your system.
    N)r   r   DEFAULTPARSER)r   r   r   r"   r"   r#   r     s    _c                   @   s$   e Zd ZG dd deZdd ZdS )	_tzparserc                   @   s<   e Zd ZddddddgZG dd deZd	d
 Zdd ZdS )z_tzparser._resultstdabbr	stdoffsetdstabbr	dstoffsetstartendc                   @   s   e Zd ZdddddddgZdS )	z_tzparser._result._attrr   weekr   ydayjydayr   r   Nr   r"   r"   r"   r#   _attrh  s      rL  c                 C   s
   |  dS )N )rY   r@   r"   r"   r#   r^   l  s    z_tzparser._result.__repr__c                 C   s"   t |  |  | _|  | _d S r?   )rP   r$   rL  rG  rH  r@   r"   r"   r#   r$   o  s    

z_tzparser._result.__init__N)r   rK   rL   rQ   rP   rL  r^   r$   r"   r"   r"   r#   r   c  s    r   c              
      s  |   }dd td|D  t }z"t }d}||k r6|}||k rfdd  | D sf|d7 }qB||kr6|jsd}d || |_nd	}d || |_t|D ]}|	| q|}||k r" | d
ks | d dkr" | d
krd | dk }	|	| |d7 }nd}	t | }
|
dkrvt
||t | d d d t | dd  d  |	  n|d |k r |d  dkrt
||t | d t |d  d  |	  |	| |d7 }n6|
dkr
t
||t | d d d |	  nW d S |	| |d7 }|jr4q6q4q6q4||k rt||D ]} | dkrJd |< qJ | dkszt|d7 }||krnd d  krdkrBn ndd  |d  D sB|j|jfD ]}t | |_|	| |d7 } | dkr2t |d  d }|	| |d7 }nt | }|	| |d7 }|rt||_t | d d |_nt | |_|	| |d7 }t | |_|	| |d7 }q||k r | dkrd | dk }	|	| |d7 }nd}	|	| |jt | |	  |_td| d d d  d! d" tj n ddkrF |d  d#dkrFd$d  |d  D sF|j|jfD ]} | d%kr|	| |d7 }t | |_n | d&kr|	| |d7 }t | |_|	| |d7 } | d'kst|	| |d7 }t | |_|jd(krHd|_|	| |d7 } | d'kslt|	| |d7 }t | d d |_nt | d |_|	| |d7 }||k r | d#kr|	| |d7 }t | }
|
dkr.t | d d d t | dd  d  |_n|d |k r |d  dkrt | d t |d  d  |_|	| |d7 }|d |k r |d  dkr|	| |d7 }| jt | 7  _n.|
dkrt | d d d |_n W d S |	| |d7 }||ks, | dks,t|d7 }q||ksFtW n tttfk
rf   Y d S X tt||} fd)d*|D  ddh |_!|S )+Nc                 S   s   g | ]}|r|qS r"   r"   r   r"   r"   r#   r   v  s      z#_tzparser.parse.<locals>.<listcomp>z([,:.]|[a-zA-Z]+|[0-9]+)r   c                 S   s   g | ]}|d kr|qS )z0123456789:,-+r"   r   r"   r"   r#   r     s    r%   rD  rM  rF  r  
0123456789)r%   r.   r  r.   r  r	   r  r  r  r_   r,   r  	   c                 S   s*   g | ]"}|d kr|D ]}|dkr|qqS )r,   z0123456789+-r"   rZ   r   r   r"   r"   r#   r     s       r`      )r`   r  r  zParsed time zone "%s"z5is in a non-standard dateutil-specific format, which z3is now deprecated; support for parsing this format z6will be removed in future versions. It is recommended z2that you switch to a standard format like the GNU zTZ variable format.ra   c                 S   s*   g | ]"}|d kr|D ]}|dkr|qqS ))r,   ra   Jr   r*   r`   r  rN  r"   rP  r"   r"   r#   r     s       rR  r   )r`   r*   r  c                    s   h | ]} | qS r"   r"   )rZ   nr<   r"   r#   	<setcomp>0  s     z"_tzparser.parse.<locals>.<setcomp>)"r   rM   r7   rE   r4   rC  rV   rE  r   r3   rR   r   r   r5   rG  rH  r   rI  r   r   r   rD  rF  r   r   ZDeprecatedTzFormatWarningrK  rJ  r  r   set
differenceissubsetr   )r!   r6  r   Z	used_idxsr  r   jZoffattriir  r  r   rX   Zunused_idxsr"   rT  r#   r   t  sH   


 


 





$









(








 &
 


 z_tzparser.parseN)r   rK   rL   rP   r   r   r"   r"   r"   r#   rB  a  s   rB  c                 C   s
   t | S r?   )DEFAULTTZPARSERr   )r6  r"   r"   r#   _parsetz7  s    r\  c                       s    e Zd ZdZ fddZ  ZS )r   z@Error class for representing failure to parse a datetime string.c              	      sN   z| j d | j dd   W S  ttfk
r@   tt|   Y S X dd }d S )Nr   r%   c                 S   s   d| j jt| f S )NrT   )r   r   r  r@   r"   r"   r#   r^   C  s    z%ParserError.__str__.<locals>.__repr__)r   r   r  r   r   __str__)r!   r^   r   r"   r#   r]  =  s
    zParserError.__str__)r   rK   rL   r   r]  r   r"   r"   r   r#   r   ;  s   c                   @   s   e Zd ZdZdS )r;  zERaised when the parser finds a timezone it cannot parse into a tzinfoN)r   rK   rL   r   r"   r"   r"   r#   r;  G  s   r;  )N)&r   
__future__r   r   rM   r-  r   r:  calendarr   ior   r   r   r   decimalr   r   rM  r
   r   __all__objectr   rP   r   rE   r   r   rA  r   rB  r[  r\  r   r   RuntimeWarningr;  r"   r"   r"   r#   <module>   sH   
 (  /     @
e TU
    ^                     @   s   d dl mZmZmZmZ d dl mZmZ d dl mZ d dl mZ d dl	m	Z	m
Z
 dddd	d
ddgZdd Zdd Zd dl mZmZ d dl mZmZ eeZeeZeeZeeZdS )   )parseparser
parserinfoParserError)DEFAULTPARSERDEFAULTTZPARSER)UnknownTimezoneWarning)__doc__)	isoparserisoparser   r   r   r   r
   r   r   c                    sB   ddl m} dd ldj jd|  fdd}|S )N    )wrapszo{name} is a private function and may break without warning, it will be moved and or renamed in future versions.namec                     s    t  | |S N)warnDeprecationWarning)argskwargsfmsgwarnings YC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\parser\__init__.pydeprecated_func   s    z2__deprecated_private_func.<locals>.deprecated_func)	functoolsr   r   format__name__)r   r   r   r   r   r   __deprecated_private_func   s    r   c                    s@   dd l dj jdG  fddd  j_S )Nr   zl{name} is a private class and may break without warning, it will be moved and or renamed in future versions.r   c                       s(   e Zd ZjZ fddZ  ZS )z0__deprecate_private_class.<locals>.private_classc                    s"    t t| j|| d S r   )r   r   super__init__)selfr   r   )	__class__r   private_classr   r   r   r!   .   s    z9__deprecate_private_class.<locals>.private_class.__init__)r   
__module____qualname__r	   r!   __classcell__r   cr   r$   r   )r#   r   r$   +   s   r$   )r   r   r   )r)   r   r(   r   __deprecate_private_class$   s    r*   )_timelex_resultbase)	_tzparser_parsetzN)_parserr   r   r   r   r   r   r   r	   r
   r   __all__r   r*   r+   r,   r-   r.   r   r   r   r   <module>   s$    # -*- coding: utf-8 -*-
"""
This module offers timezone implementations subclassing the abstract
:py:class:`datetime.tzinfo` type. There are classes to handle tzfile format
files (usually are in :file:`/etc/localtime`, :file:`/usr/share/zoneinfo`,
etc), TZ environment string (in all known formats), given ranges (with help
from relative deltas), local machine timezone, fixed offset timezone, and UTC
timezone.
"""
import datetime
import struct
import time
import sys
import os
import bisect
import weakref
from collections import OrderedDict

import six
from six import string_types
from six.moves import _thread
from ._common import tzname_in_python2, _tzinfo
from ._common import tzrangebase, enfold
from ._common import _validate_fromutc_inputs

from ._factories import _TzSingleton, _TzOffsetFactory
from ._factories import _TzStrFactory
try:
    from .win import tzwin, tzwinlocal
except ImportError:
    tzwin = tzwinlocal = None

# For warning about rounding tzinfo
from warnings import warn

ZERO = datetime.timedelta(0)
EPOCH = datetime.datetime.utcfromtimestamp(0)
EPOCHORDINAL = EPOCH.toordinal()


@six.add_metaclass(_TzSingleton)
class tzutc(datetime.tzinfo):
    """
    This is a tzinfo object that represents the UTC time zone.

    **Examples:**

    .. doctest::

        >>> from datetime import *
        >>> from dateutil.tz import *

        >>> datetime.now()
        datetime.datetime(2003, 9, 27, 9, 40, 1, 521290)

        >>> datetime.now(tzutc())
        datetime.datetime(2003, 9, 27, 12, 40, 12, 156379, tzinfo=tzutc())

        >>> datetime.now(tzutc()).tzname()
        'UTC'

    .. versionchanged:: 2.7.0
        ``tzutc()`` is now a singleton, so the result of ``tzutc()`` will
        always return the same object.

        .. doctest::

            >>> from dateutil.tz import tzutc, UTC
            >>> tzutc() is tzutc()
            True
            >>> tzutc() is UTC
            True
    """
    def utcoffset(self, dt):
        return ZERO

    def dst(self, dt):
        return ZERO

    @tzname_in_python2
    def tzname(self, dt):
        return "UTC"

    def is_ambiguous(self, dt):
        """
        Whether or not the "wall time" of a given datetime is ambiguous in this
        zone.

        :param dt:
            A :py:class:`datetime.datetime`, naive or time zone aware.


        :return:
            Returns ``True`` if ambiguous, ``False`` otherwise.

        .. versionadded:: 2.6.0
        """
        return False

    @_validate_fromutc_inputs
    def fromutc(self, dt):
        """
        Fast track version of fromutc() returns the original ``dt`` object for
        any valid :py:class:`datetime.datetime` object.
        """
        return dt

    def __eq__(self, other):
        if not isinstance(other, (tzutc, tzoffset)):
            return NotImplemented

        return (isinstance(other, tzutc) or
                (isinstance(other, tzoffset) and other._offset == ZERO))

    __hash__ = None

    def __ne__(self, other):
        return not (self == other)

    def __repr__(self):
        return "%s()" % self.__class__.__name__

    __reduce__ = object.__reduce__


#: Convenience constant providing a :class:`tzutc()` instance
#:
#: .. versionadded:: 2.7.0
UTC = tzutc()


@six.add_metaclass(_TzOffsetFactory)
class tzoffset(datetime.tzinfo):
    """
    A simple class for representing a fixed offset from UTC.

    :param name:
        The timezone name, to be returned when ``tzname()`` is called.
    :param offset:
        The time zone offset in seconds, or (since version 2.6.0, represented
        as a :py:class:`datetime.timedelta` object).
    """
    def __init__(self, name, offset):
        self._name = name

        try:
            # Allow a timedelta
            offset = offset.total_seconds()
        except (TypeError, AttributeError):
            pass

        self._offset = datetime.timedelta(seconds=_get_supported_offset(offset))

    def utcoffset(self, dt):
        return self._offset

    def dst(self, dt):
        return ZERO

    @tzname_in_python2
    def tzname(self, dt):
        return self._name

    @_validate_fromutc_inputs
    def fromutc(self, dt):
        return dt + self._offset

    def is_ambiguous(self, dt):
        """
        Whether or not the "wall time" of a given datetime is ambiguous in this
        zone.

        :param dt:
            A :py:class:`datetime.datetime`, naive or time zone aware.
        :return:
            Returns ``True`` if ambiguous, ``False`` otherwise.

        .. versionadded:: 2.6.0
        """
        return False

    def __eq__(self, other):
        if not isinstance(other, tzoffset):
            return NotImplemented

        return self._offset == other._offset

    __hash__ = None

    def __ne__(self, other):
        return not (self == other)

    def __repr__(self):
        return "%s(%s, %s)" % (self.__class__.__name__,
                               repr(self._name),
                               int(self._offset.total_seconds()))

    __reduce__ = object.__reduce__


class tzlocal(_tzinfo):
    """
    A :class:`tzinfo` subclass built around the ``time`` timezone functions.
    """
    def __init__(self):
        super(tzlocal, self).__init__()

        self._std_offset = datetime.timedelta(seconds=-time.timezone)
        if time.daylight:
            self._dst_offset = datetime.timedelta(seconds=-time.altzone)
        else:
            self._dst_offset = self._std_offset

        self._dst_saved = self._dst_offset - self._std_offset
        self._hasdst = bool(self._dst_saved)
        self._tznames = tuple(time.tzname)

    def utcoffset(self, dt):
        if dt is None and self._hasdst:
            return None

        if self._isdst(dt):
            return self._dst_offset
        else:
            return self._std_offset

    def dst(self, dt):
        if dt is None and self._hasdst:
            return None

        if self._isdst(dt):
            return self._dst_offset - self._std_offset
        else:
            return ZERO

    @tzname_in_python2
    def tzname(self, dt):
        return self._tznames[self._isdst(dt)]

    def is_ambiguous(self, dt):
        """
        Whether or not the "wall time" of a given datetime is ambiguous in this
        zone.

        :param dt:
            A :py:class:`datetime.datetime`, naive or time zone aware.


        :return:
            Returns ``True`` if ambiguous, ``False`` otherwise.

        .. versionadded:: 2.6.0
        """
        naive_dst = self._naive_is_dst(dt)
        return (not naive_dst and
                (naive_dst != self._naive_is_dst(dt - self._dst_saved)))

    def _naive_is_dst(self, dt):
        timestamp = _datetime_to_timestamp(dt)
        return time.localtime(timestamp + time.timezone).tm_isdst

    def _isdst(self, dt, fold_naive=True):
        # We can't use mktime here. It is unstable when deciding if
        # the hour near to a change is DST or not.
        #
        # timestamp = time.mktime((dt.year, dt.month, dt.day, dt.hour,
        #                         dt.minute, dt.second, dt.weekday(), 0, -1))
        # return time.localtime(timestamp).tm_isdst
        #
        # The code above yields the following result:
        #
        # >>> import tz, datetime
        # >>> t = tz.tzlocal()
        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
        # 'BRDT'
        # >>> datetime.datetime(2003,2,16,0,tzinfo=t).tzname()
        # 'BRST'
        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
        # 'BRST'
        # >>> datetime.datetime(2003,2,15,22,tzinfo=t).tzname()
        # 'BRDT'
        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
        # 'BRDT'
        #
        # Here is a more stable implementation:
        #
        if not self._hasdst:
            return False

        # Check for ambiguous times:
        dstval = self._naive_is_dst(dt)
        fold = getattr(dt, 'fold', None)

        if self.is_ambiguous(dt):
            if fold is not None:
                return not self._fold(dt)
            else:
                return True

        return dstval

    def __eq__(self, other):
        if isinstance(other, tzlocal):
            return (self._std_offset == other._std_offset and
                    self._dst_offset == other._dst_offset)
        elif isinstance(other, tzutc):
            return (not self._hasdst and
                    self._tznames[0] in {'UTC', 'GMT'} and
                    self._std_offset == ZERO)
        elif isinstance(other, tzoffset):
            return (not self._hasdst and
                    self._tznames[0] == other._name and
                    self._std_offset == other._offset)
        else:
            return NotImplemented

    __hash__ = None

    def __ne__(self, other):
        return not (self == other)

    def __repr__(self):
        return "%s()" % self.__class__.__name__

    __reduce__ = object.__reduce__


class _ttinfo(object):
    __slots__ = ["offset", "delta", "isdst", "abbr",
                 "isstd", "isgmt", "dstoffset"]

    def __init__(self):
        for attr in self.__slots__:
            setattr(self, attr, None)

    def __repr__(self):
        l = []
        for attr in self.__slots__:
            value = getattr(self, attr)
            if value is not None:
                l.append("%s=%s" % (attr, repr(value)))
        return "%s(%s)" % (self.__class__.__name__, ", ".join(l))

    def __eq__(self, other):
        if not isinstance(other, _ttinfo):
            return NotImplemented

        return (self.offset == other.offset and
                self.delta == other.delta and
                self.isdst == other.isdst and
                self.abbr == other.abbr and
                self.isstd == other.isstd and
                self.isgmt == other.isgmt and
                self.dstoffset == other.dstoffset)

    __hash__ = None

    def __ne__(self, other):
        return not (self == other)

    def __getstate__(self):
        state = {}
        for name in self.__slots__:
            state[name] = getattr(self, name, None)
        return state

    def __setstate__(self, state):
        for name in self.__slots__:
            if name in state:
                setattr(self, name, state[name])


class _tzfile(object):
    """
    Lightweight class for holding the relevant transition and time zone
    information read from binary tzfiles.
    """
    attrs = ['trans_list', 'trans_list_utc', 'trans_idx', 'ttinfo_list',
             'ttinfo_std', 'ttinfo_dst', 'ttinfo_before', 'ttinfo_first']

    def __init__(self, **kwargs):
        for attr in self.attrs:
            setattr(self, attr, kwargs.get(attr, None))


class tzfile(_tzinfo):
    """
    This is a ``tzinfo`` subclass that allows one to use the ``tzfile(5)``
    format timezone files to extract current and historical zone information.

    :param fileobj:
        This can be an opened file stream or a file name that the time zone
        information can be read from.

    :param filename:
        This is an optional parameter specifying the source of the time zone
        information in the event that ``fileobj`` is a file object. If omitted
        and ``fileobj`` is a file stream, this parameter will be set either to
        ``fileobj``'s ``name`` attribute or to ``repr(fileobj)``.

    See `Sources for Time Zone and Daylight Saving Time Data
    <https://data.iana.org/time-zones/tz-link.html>`_ for more information.
    Time zone files can be compiled from the `IANA Time Zone database files
    <https://www.iana.org/time-zones>`_ with the `zic time zone compiler
    <https://www.freebsd.org/cgi/man.cgi?query=zic&sektion=8>`_

    .. note::

        Only construct a ``tzfile`` directly if you have a specific timezone
        file on disk that you want to read into a Python ``tzinfo`` object.
        If you want to get a ``tzfile`` representing a specific IANA zone,
        (e.g. ``'America/New_York'``), you should call
        :func:`dateutil.tz.gettz` with the zone identifier.


    **Examples:**

    Using the US Eastern time zone as an example, we can see that a ``tzfile``
    provides time zone information for the standard Daylight Saving offsets:

    .. testsetup:: tzfile

        from dateutil.tz import gettz
        from datetime import datetime

    .. doctest:: tzfile

        >>> NYC = gettz('America/New_York')
        >>> NYC
        tzfile('/usr/share/zoneinfo/America/New_York')

        >>> print(datetime(2016, 1, 3, tzinfo=NYC))     # EST
        2016-01-03 00:00:00-05:00

        >>> print(datetime(2016, 7, 7, tzinfo=NYC))     # EDT
        2016-07-07 00:00:00-04:00


    The ``tzfile`` structure contains a fully history of the time zone,
    so historical dates will also have the right offsets. For example, before
    the adoption of the UTC standards, New York used local solar  mean time:

    .. doctest:: tzfile

       >>> print(datetime(1901, 4, 12, tzinfo=NYC))    # LMT
       1901-04-12 00:00:00-04:56

    And during World War II, New York was on "Eastern War Time", which was a
    state of permanent daylight saving time:

    .. doctest:: tzfile

        >>> print(datetime(1944, 2, 7, tzinfo=NYC))    # EWT
        1944-02-07 00:00:00-04:00

    """

    def __init__(self, fileobj, filename=None):
        super(tzfile, self).__init__()

        file_opened_here = False
        if isinstance(fileobj, string_types):
            self._filename = fileobj
            fileobj = open(fileobj, 'rb')
            file_opened_here = True
        elif filename is not None:
            self._filename = filename
        elif hasattr(fileobj, "name"):
            self._filename = fileobj.name
        else:
            self._filename = repr(fileobj)

        if fileobj is not None:
            if not file_opened_here:
                fileobj = _nullcontext(fileobj)

            with fileobj as file_stream:
                tzobj = self._read_tzfile(file_stream)

            self._set_tzdata(tzobj)

    def _set_tzdata(self, tzobj):
        """ Set the time zone data of this object from a _tzfile object """
        # Copy the relevant attributes over as private attributes
        for attr in _tzfile.attrs:
            setattr(self, '_' + attr, getattr(tzobj, attr))

    def _read_tzfile(self, fileobj):
        out = _tzfile()

        # From tzfile(5):
        #
        # The time zone information files used by tzset(3)
        # begin with the magic characters "TZif" to identify
        # them as time zone information files, followed by
        # sixteen bytes reserved for future use, followed by
        # six four-byte values of type long, written in a
        # ``standard'' byte order (the high-order  byte
        # of the value is written first).
        if fileobj.read(4).decode() != "TZif":
            raise ValueError("magic not found")

        fileobj.read(16)

        (
            # The number of UTC/local indicators stored in the file.
            ttisgmtcnt,

            # The number of standard/wall indicators stored in the file.
            ttisstdcnt,

            # The number of leap seconds for which data is
            # stored in the file.
            leapcnt,

            # The number of "transition times" for which data
            # is stored in the file.
            timecnt,

            # The number of "local time types" for which data
            # is stored in the file (must not be zero).
            typecnt,

            # The  number  of  characters  of "time zone
            # abbreviation strings" stored in the file.
            charcnt,

        ) = struct.unpack(">6l", fileobj.read(24))

        # The above header is followed by tzh_timecnt four-byte
        # values  of  type long,  sorted  in ascending order.
        # These values are written in ``standard'' byte order.
        # Each is used as a transition time (as  returned  by
        # time(2)) at which the rules for computing local time
        # change.

        if timecnt:
            out.trans_list_utc = list(struct.unpack(">%dl" % timecnt,
                                                    fileobj.read(timecnt*4)))
        else:
            out.trans_list_utc = []

        # Next come tzh_timecnt one-byte values of type unsigned
        # char; each one tells which of the different types of
        # ``local time'' types described in the file is associated
        # with the same-indexed transition time. These values
        # serve as indices into an array of ttinfo structures that
        # appears next in the file.

        if timecnt:
            out.trans_idx = struct.unpack(">%dB" % timecnt,
                                          fileobj.read(timecnt))
        else:
            out.trans_idx = []

        # Each ttinfo structure is written as a four-byte value
        # for tt_gmtoff  of  type long,  in  a  standard  byte
        # order, followed  by a one-byte value for tt_isdst
        # and a one-byte  value  for  tt_abbrind.   In  each
        # structure, tt_gmtoff  gives  the  number  of
        # seconds to be added to UTC, tt_isdst tells whether
        # tm_isdst should be set by  localtime(3),  and
        # tt_abbrind serves  as an index into the array of
        # time zone abbreviation characters that follow the
        # ttinfo structure(s) in the file.

        ttinfo = []

        for i in range(typecnt):
            ttinfo.append(struct.unpack(">lbb", fileobj.read(6)))

        abbr = fileobj.read(charcnt).decode()

        # Then there are tzh_leapcnt pairs of four-byte
        # values, written in  standard byte  order;  the
        # first  value  of  each pair gives the time (as
        # returned by time(2)) at which a leap second
        # occurs;  the  second  gives the  total  number of
        # leap seconds to be applied after the given time.
        # The pairs of values are sorted in ascending order
        # by time.

        # Not used, for now (but seek for correct file position)
        if leapcnt:
            fileobj.seek(leapcnt * 8, os.SEEK_CUR)

        # Then there are tzh_ttisstdcnt standard/wall
        # indicators, each stored as a one-byte value;
        # they tell whether the transition times associated
        # with local time types were specified as standard
        # time or wall clock time, and are used when
        # a time zone file is used in handling POSIX-style
        # time zone environment variables.

        if ttisstdcnt:
            isstd = struct.unpack(">%db" % ttisstdcnt,
                                  fileobj.read(ttisstdcnt))

        # Finally, there are tzh_ttisgmtcnt UTC/local
        # indicators, each stored as a one-byte value;
        # they tell whether the transition times associated
        # with local time types were specified as UTC or
        # local time, and are used when a time zone file
        # is used in handling POSIX-style time zone envi-
        # ronment variables.

        if ttisgmtcnt:
            isgmt = struct.unpack(">%db" % ttisgmtcnt,
                                  fileobj.read(ttisgmtcnt))

        # Build ttinfo list
        out.ttinfo_list = []
        for i in range(typecnt):
            gmtoff, isdst, abbrind = ttinfo[i]
            gmtoff = _get_supported_offset(gmtoff)
            tti = _ttinfo()
            tti.offset = gmtoff
            tti.dstoffset = datetime.timedelta(0)
            tti.delta = datetime.timedelta(seconds=gmtoff)
            tti.isdst = isdst
            tti.abbr = abbr[abbrind:abbr.find('\x00', abbrind)]
            tti.isstd = (ttisstdcnt > i and isstd[i] != 0)
            tti.isgmt = (ttisgmtcnt > i and isgmt[i] != 0)
            out.ttinfo_list.append(tti)

        # Replace ttinfo indexes for ttinfo objects.
        out.trans_idx = [out.ttinfo_list[idx] for idx in out.trans_idx]

        # Set standard, dst, and before ttinfos. before will be
        # used when a given time is before any transitions,
        # and will be set to the first non-dst ttinfo, or to
        # the first dst, if all of them are dst.
        out.ttinfo_std = None
        out.ttinfo_dst = None
        out.ttinfo_before = None
        if out.ttinfo_list:
            if not out.trans_list_utc:
                out.ttinfo_std = out.ttinfo_first = out.ttinfo_list[0]
            else:
                for i in range(timecnt-1, -1, -1):
                    tti = out.trans_idx[i]
                    if not out.ttinfo_std and not tti.isdst:
                        out.ttinfo_std = tti
                    elif not out.ttinfo_dst and tti.isdst:
                        out.ttinfo_dst = tti

                    if out.ttinfo_std and out.ttinfo_dst:
                        break
                else:
                    if out.ttinfo_dst and not out.ttinfo_std:
                        out.ttinfo_std = out.ttinfo_dst

                for tti in out.ttinfo_list:
                    if not tti.isdst:
                        out.ttinfo_before = tti
                        break
                else:
                    out.ttinfo_before = out.ttinfo_list[0]

        # Now fix transition times to become relative to wall time.
        #
        # I'm not sure about this. In my tests, the tz source file
        # is setup to wall time, and in the binary file isstd and
        # isgmt are off, so it should be in wall time. OTOH, it's
        # always in gmt time. Let me know if you have comments
        # about this.
        lastdst = None
        lastoffset = None
        lastdstoffset = None
        lastbaseoffset = None
        out.trans_list = []

        for i, tti in enumerate(out.trans_idx):
            offset = tti.offset
            dstoffset = 0

            if lastdst is not None:
                if tti.isdst:
                    if not lastdst:
                        dstoffset = offset - lastoffset

                    if not dstoffset and lastdstoffset:
                        dstoffset = lastdstoffset

                    tti.dstoffset = datetime.timedelta(seconds=dstoffset)
                    lastdstoffset = dstoffset

            # If a time zone changes its base offset during a DST transition,
            # then you need to adjust by the previous base offset to get the
            # transition time in local time. Otherwise you use the current
            # base offset. Ideally, I would have some mathematical proof of
            # why this is true, but I haven't really thought about it enough.
            baseoffset = offset - dstoffset
            adjustment = baseoffset
            if (lastbaseoffset is not None and baseoffset != lastbaseoffset
                    and tti.isdst != lastdst):
                # The base DST has changed
                adjustment = lastbaseoffset

            lastdst = tti.isdst
            lastoffset = offset
            lastbaseoffset = baseoffset

            out.trans_list.append(out.trans_list_utc[i] + adjustment)

        out.trans_idx = tuple(out.trans_idx)
        out.trans_list = tuple(out.trans_list)
        out.trans_list_utc = tuple(out.trans_list_utc)

        return out

    def _find_last_transition(self, dt, in_utc=False):
        # If there's no list, there are no transitions to find
        if not self._trans_list:
            return None

        timestamp = _datetime_to_timestamp(dt)

        # Find where the timestamp fits in the transition list - if the
        # timestamp is a transition time, it's part of the "after" period.
        trans_list = self._trans_list_utc if in_utc else self._trans_list
        idx = bisect.bisect_right(trans_list, timestamp)

        # We want to know when the previous transition was, so subtract off 1
        return idx - 1

    def _get_ttinfo(self, idx):
        # For no list or after the last transition, default to _ttinfo_std
        if idx is None or (idx + 1) >= len(self._trans_list):
            return self._ttinfo_std

        # If there is a list and the time is before it, return _ttinfo_before
        if idx < 0:
            return self._ttinfo_before

        return self._trans_idx[idx]

    def _find_ttinfo(self, dt):
        idx = self._resolve_ambiguous_time(dt)

        return self._get_ttinfo(idx)

    def fromutc(self, dt):
        """
        The ``tzfile`` implementation of :py:func:`datetime.tzinfo.fromutc`.

        :param dt:
            A :py:class:`datetime.datetime` object.

        :raises TypeError:
            Raised if ``dt`` is not a :py:class:`datetime.datetime` object.

        :raises ValueError:
            Raised if this is called with a ``dt`` which does not have this
            ``tzinfo`` attached.

        :return:
            Returns a :py:class:`datetime.datetime` object representing the
            wall time in ``self``'s time zone.
        """
        # These isinstance checks are in datetime.tzinfo, so we'll preserve
        # them, even if we don't care about duck typing.
        if not isinstance(dt, datetime.datetime):
            raise TypeError("fromutc() requires a datetime argument")

        if dt.tzinfo is not self:
            raise ValueError("dt.tzinfo is not self")

        # First treat UTC as wall time and get the transition we're in.
        idx = self._find_last_transition(dt, in_utc=True)
        tti = self._get_ttinfo(idx)

        dt_out = dt + datetime.timedelta(seconds=tti.offset)

        fold = self.is_ambiguous(dt_out, idx=idx)

        return enfold(dt_out, fold=int(fold))

    def is_ambiguous(self, dt, idx=None):
        """
        Whether or not the "wall time" of a given datetime is ambiguous in this
        zone.

        :param dt:
            A :py:class:`datetime.datetime`, naive or time zone aware.


        :return:
            Returns ``True`` if ambiguous, ``False`` otherwise.

        .. versionadded:: 2.6.0
        """
        if idx is None:
            idx = self._find_last_transition(dt)

        # Calculate the difference in offsets from current to previous
        timestamp = _datetime_to_timestamp(dt)
        tti = self._get_ttinfo(idx)

        if idx is None or idx <= 0:
            return False

        od = self._get_ttinfo(idx - 1).offset - tti.offset
        tt = self._trans_list[idx]          # Transition time

        return timestamp < tt + od

    def _resolve_ambiguous_time(self, dt):
        idx = self._find_last_transition(dt)

        # If we have no transitions, return the index
        _fold = self._fold(dt)
        if idx is None or idx == 0:
            return idx

        # If it's ambiguous and we're in a fold, shift to a different index.
        idx_offset = int(not _fold and self.is_ambiguous(dt, idx))

        return idx - idx_offset

    def utcoffset(self, dt):
        if dt is None:
            return None

        if not self._ttinfo_std:
            return ZERO

        return self._find_ttinfo(dt).delta

    def dst(self, dt):
        if dt is None:
            return None

        if not self._ttinfo_dst:
            return ZERO

        tti = self._find_ttinfo(dt)

        if not tti.isdst:
            return ZERO

        # The documentation says that utcoffset()-dst() must
        # be constant for every dt.
        return tti.dstoffset

    @tzname_in_python2
    def tzname(self, dt):
        if not self._ttinfo_std or dt is None:
            return None
        return self._find_ttinfo(dt).abbr

    def __eq__(self, other):
        if not isinstance(other, tzfile):
            return NotImplemented
        return (self._trans_list == other._trans_list and
                self._trans_idx == other._trans_idx and
                self._ttinfo_list == other._ttinfo_list)

    __hash__ = None

    def __ne__(self, other):
        return not (self == other)

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, repr(self._filename))

    def __reduce__(self):
        return self.__reduce_ex__(None)

    def __reduce_ex__(self, protocol):
        return (self.__class__, (None, self._filename), self.__dict__)


class tzrange(tzrangebase):
    """
    The ``tzrange`` object is a time zone specified by a set of offsets and
    abbreviations, equivalent to the way the ``TZ`` variable can be specified
    in POSIX-like systems, but using Python delta objects to specify DST
    start, end and offsets.

    :param stdabbr:
        The abbreviation for standard time (e.g. ``'EST'``).

    :param stdoffset:
        An integer or :class:`datetime.timedelta` object or equivalent
        specifying the base offset from UTC.

        If unspecified, +00:00 is used.

    :param dstabbr:
        The abbreviation for DST / "Summer" time (e.g. ``'EDT'``).

        If specified, with no other DST information, DST is assumed to occur
        and the default behavior or ``dstoffset``, ``start`` and ``end`` is
        used. If unspecified and no other DST information is specified, it
        is assumed that this zone has no DST.

        If this is unspecified and other DST information is *is* specified,
        DST occurs in the zone but the time zone abbreviation is left
        unchanged.

    :param dstoffset:
        A an integer or :class:`datetime.timedelta` object or equivalent
        specifying the UTC offset during DST. If unspecified and any other DST
        information is specified, it is assumed to be the STD offset +1 hour.

    :param start:
        A :class:`relativedelta.relativedelta` object or equivalent specifying
        the time and time of year that daylight savings time starts. To
        specify, for example, that DST starts at 2AM on the 2nd Sunday in
        March, pass:

            ``relativedelta(hours=2, month=3, day=1, weekday=SU(+2))``

        If unspecified and any other DST information is specified, the default
        value is 2 AM on the first Sunday in April.

    :param end:
        A :class:`relativedelta.relativedelta` object or equivalent
        representing the time and time of year that daylight savings time
        ends, with the same specification method as in ``start``. One note is
        that this should point to the first time in the *standard* zone, so if
        a transition occurs at 2AM in the DST zone and the clocks are set back
        1 hour to 1AM, set the ``hours`` parameter to +1.


    **Examples:**

    .. testsetup:: tzrange

        from dateutil.tz import tzrange, tzstr

    .. doctest:: tzrange

        >>> tzstr('EST5EDT') == tzrange("EST", -18000, "EDT")
        True

        >>> from dateutil.relativedelta import *
        >>> range1 = tzrange("EST", -18000, "EDT")
        >>> range2 = tzrange("EST", -18000, "EDT", -14400,
        ...                  relativedelta(hours=+2, month=4, day=1,
        ...                                weekday=SU(+1)),
        ...                  relativedelta(hours=+1, month=10, day=31,
        ...                                weekday=SU(-1)))
        >>> tzstr('EST5EDT') == range1 == range2
        True

    """
    def __init__(self, stdabbr, stdoffset=None,
                 dstabbr=None, dstoffset=None,
                 start=None, end=None):

        global relativedelta
        from dateutil import relativedelta

        self._std_abbr = stdabbr
        self._dst_abbr = dstabbr

        try:
            stdoffset = stdoffset.total_seconds()
        except (TypeError, AttributeError):
            pass

        try:
            dstoffset = dstoffset.total_seconds()
        except (TypeError, AttributeError):
            pass

        if stdoffset is not None:
            self._std_offset = datetime.timedelta(seconds=stdoffset)
        else:
            self._std_offset = ZERO

        if dstoffset is not None:
            self._dst_offset = datetime.timedelta(seconds=dstoffset)
        elif dstabbr and stdoffset is not None:
            self._dst_offset = self._std_offset + datetime.timedelta(hours=+1)
        else:
            self._dst_offset = ZERO

        if dstabbr and start is None:
            self._start_delta = relativedelta.relativedelta(
                hours=+2, month=4, day=1, weekday=relativedelta.SU(+1))
        else:
            self._start_delta = start

        if dstabbr and end is None:
            self._end_delta = relativedelta.relativedelta(
                hours=+1, month=10, day=31, weekday=relativedelta.SU(-1))
        else:
            self._end_delta = end

        self._dst_base_offset_ = self._dst_offset - self._std_offset
        self.hasdst = bool(self._start_delta)

    def transitions(self, year):
        """
        For a given year, get the DST on and off transition times, expressed
        always on the standard time side. For zones with no transitions, this
        function returns ``None``.

        :param year:
            The year whose transitions you would like to query.

        :return:
            Returns a :class:`tuple` of :class:`datetime.datetime` objects,
            ``(dston, dstoff)`` for zones with an annual DST transition, or
            ``None`` for fixed offset zones.
        """
        if not self.hasdst:
            return None

        base_year = datetime.datetime(year, 1, 1)

        start = base_year + self._start_delta
        end = base_year + self._end_delta

        return (start, end)

    def __eq__(self, other):
        if not isinstance(other, tzrange):
            return NotImplemented

        return (self._std_abbr == other._std_abbr and
                self._dst_abbr == other._dst_abbr and
                self._std_offset == other._std_offset and
                self._dst_offset == other._dst_offset and
                self._start_delta == other._start_delta and
                self._end_delta == other._end_delta)

    @property
    def _dst_base_offset(self):
        return self._dst_base_offset_


@six.add_metaclass(_TzStrFactory)
class tzstr(tzrange):
    """
    ``tzstr`` objects are time zone objects specified by a time-zone string as
    it would be passed to a ``TZ`` variable on POSIX-style systems (see
    the `GNU C Library: TZ Variable`_ for more details).

    There is one notable exception, which is that POSIX-style time zones use an
    inverted offset format, so normally ``GMT+3`` would be parsed as an offset
    3 hours *behind* GMT. The ``tzstr`` time zone object will parse this as an
    offset 3 hours *ahead* of GMT. If you would like to maintain the POSIX
    behavior, pass a ``True`` value to ``posix_offset``.

    The :class:`tzrange` object provides the same functionality, but is
    specified using :class:`relativedelta.relativedelta` objects. rather than
    strings.

    :param s:
        A time zone string in ``TZ`` variable format. This can be a
        :class:`bytes` (2.x: :class:`str`), :class:`str` (2.x:
        :class:`unicode`) or a stream emitting unicode characters
        (e.g. :class:`StringIO`).

    :param posix_offset:
        Optional. If set to ``True``, interpret strings such as ``GMT+3`` or
        ``UTC+3`` as being 3 hours *behind* UTC rather than ahead, per the
        POSIX standard.

    .. caution::

        Prior to version 2.7.0, this function also supported time zones
        in the format:

            * ``EST5EDT,4,0,6,7200,10,0,26,7200,3600``
            * ``EST5EDT,4,1,0,7200,10,-1,0,7200,3600``

        This format is non-standard and has been deprecated; this function
        will raise a :class:`DeprecatedTZFormatWarning` until
        support is removed in a future version.

    .. _`GNU C Library: TZ Variable`:
        https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html
    """
    def __init__(self, s, posix_offset=False):
        global parser
        from dateutil.parser import _parser as parser

        self._s = s

        res = parser._parsetz(s)
        if res is None or res.any_unused_tokens:
            raise ValueError("unknown string format")

        # Here we break the compatibility with the TZ variable handling.
        # GMT-3 actually *means* the timezone -3.
        if res.stdabbr in ("GMT", "UTC") and not posix_offset:
            res.stdoffset *= -1

        # We must initialize it first, since _delta() needs
        # _std_offset and _dst_offset set. Use False in start/end
        # to avoid building it two times.
        tzrange.__init__(self, res.stdabbr, res.stdoffset,
                         res.dstabbr, res.dstoffset,
                         start=False, end=False)

        if not res.dstabbr:
            self._start_delta = None
            self._end_delta = None
        else:
            self._start_delta = self._delta(res.start)
            if self._start_delta:
                self._end_delta = self._delta(res.end, isend=1)

        self.hasdst = bool(self._start_delta)

    def _delta(self, x, isend=0):
        from dateutil import relativedelta
        kwargs = {}
        if x.month is not None:
            kwargs["month"] = x.month
            if x.weekday is not None:
                kwargs["weekday"] = relativedelta.weekday(x.weekday, x.week)
                if x.week > 0:
                    kwargs["day"] = 1
                else:
                    kwargs["day"] = 31
            elif x.day:
                kwargs["day"] = x.day
        elif x.yday is not None:
            kwargs["yearday"] = x.yday
        elif x.jyday is not None:
            kwargs["nlyearday"] = x.jyday
        if not kwargs:
            # Default is to start on first sunday of april, and end
            # on last sunday of october.
            if not isend:
                kwargs["month"] = 4
                kwargs["day"] = 1
                kwargs["weekday"] = relativedelta.SU(+1)
            else:
                kwargs["month"] = 10
                kwargs["day"] = 31
                kwargs["weekday"] = relativedelta.SU(-1)
        if x.time is not None:
            kwargs["seconds"] = x.time
        else:
            # Default is 2AM.
            kwargs["seconds"] = 7200
        if isend:
            # Convert to standard time, to follow the documented way
            # of working with the extra hour. See the documentation
            # of the tzinfo class.
            delta = self._dst_offset - self._std_offset
            kwargs["seconds"] -= delta.seconds + delta.days * 86400
        return relativedelta.relativedelta(**kwargs)

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, repr(self._s))


class _tzicalvtzcomp(object):
    def __init__(self, tzoffsetfrom, tzoffsetto, isdst,
                 tzname=None, rrule=None):
        self.tzoffsetfrom = datetime.timedelta(seconds=tzoffsetfrom)
        self.tzoffsetto = datetime.timedelta(seconds=tzoffsetto)
        self.tzoffsetdiff = self.tzoffsetto - self.tzoffsetfrom
        self.isdst = isdst
        self.tzname = tzname
        self.rrule = rrule


class _tzicalvtz(_tzinfo):
    def __init__(self, tzid, comps=[]):
        super(_tzicalvtz, self).__init__()

        self._tzid = tzid
        self._comps = comps
        self._cachedate = []
        self._cachecomp = []
        self._cache_lock = _thread.allocate_lock()

    def _find_comp(self, dt):
        if len(self._comps) == 1:
            return self._comps[0]

        dt = dt.replace(tzinfo=None)

        try:
            with self._cache_lock:
                return self._cachecomp[self._cachedate.index(
                    (dt, self._fold(dt)))]
        except ValueError:
            pass

        lastcompdt = None
        lastcomp = None

        for comp in self._comps:
            compdt = self._find_compdt(comp, dt)

            if compdt and (not lastcompdt or lastcompdt < compdt):
                lastcompdt = compdt
                lastcomp = comp

        if not lastcomp:
            # RFC says nothing about what to do when a given
            # time is before the first onset date. We'll look for the
            # first standard component, or the first component, if
            # none is found.
            for comp in self._comps:
                if not comp.isdst:
                    lastcomp = comp
                    break
            else:
                lastcomp = comp[0]

        with self._cache_lock:
            self._cachedate.insert(0, (dt, self._fold(dt)))
            self._cachecomp.insert(0, lastcomp)

            if len(self._cachedate) > 10:
                self._cachedate.pop()
                self._cachecomp.pop()

        return lastcomp

    def _find_compdt(self, comp, dt):
        if comp.tzoffsetdiff < ZERO and self._fold(dt):
            dt -= comp.tzoffsetdiff

        compdt = comp.rrule.before(dt, inc=True)

        return compdt

    def utcoffset(self, dt):
        if dt is None:
            return None

        return self._find_comp(dt).tzoffsetto

    def dst(self, dt):
        comp = self._find_comp(dt)
        if comp.isdst:
            return comp.tzoffsetdiff
        else:
            return ZERO

    @tzname_in_python2
    def tzname(self, dt):
        return self._find_comp(dt).tzname

    def __repr__(self):
        return "<tzicalvtz %s>" % repr(self._tzid)

    __reduce__ = object.__reduce__


class tzical(object):
    """
    This object is designed to parse an iCalendar-style ``VTIMEZONE`` structure
    as set out in `RFC 5545`_ Section 4.6.5 into one or more `tzinfo` objects.

    :param `fileobj`:
        A file or stream in iCalendar format, which should be UTF-8 encoded
        with CRLF endings.

    .. _`RFC 5545`: https://tools.ietf.org/html/rfc5545
    """
    def __init__(self, fileobj):
        global rrule
        from dateutil import rrule

        if isinstance(fileobj, string_types):
            self._s = fileobj
            # ical should be encoded in UTF-8 with CRLF
            fileobj = open(fileobj, 'r')
        else:
            self._s = getattr(fileobj, 'name', repr(fileobj))
            fileobj = _nullcontext(fileobj)

        self._vtz = {}

        with fileobj as fobj:
            self._parse_rfc(fobj.read())

    def keys(self):
        """
        Retrieves the available time zones as a list.
        """
        return list(self._vtz.keys())

    def get(self, tzid=None):
        """
        Retrieve a :py:class:`datetime.tzinfo` object by its ``tzid``.

        :param tzid:
            If there is exactly one time zone available, omitting ``tzid``
            or passing :py:const:`None` value returns it. Otherwise a valid
            key (which can be retrieved from :func:`keys`) is required.

        :raises ValueError:
            Raised if ``tzid`` is not specified but there are either more
            or fewer than 1 zone defined.

        :returns:
            Returns either a :py:class:`datetime.tzinfo` object representing
            the relevant time zone or :py:const:`None` if the ``tzid`` was
            not found.
        """
        if tzid is None:
            if len(self._vtz) == 0:
                raise ValueError("no timezones defined")
            elif len(self._vtz) > 1:
                raise ValueError("more than one timezone available")
            tzid = next(iter(self._vtz))

        return self._vtz.get(tzid)

    def _parse_offset(self, s):
        s = s.strip()
        if not s:
            raise ValueError("empty offset")
        if s[0] in ('+', '-'):
            signal = (-1, +1)[s[0] == '+']
            s = s[1:]
        else:
            signal = +1
        if len(s) == 4:
            return (int(s[:2]) * 3600 + int(s[2:]) * 60) * signal
        elif len(s) == 6:
            return (int(s[:2]) * 3600 + int(s[2:4]) * 60 + int(s[4:])) * signal
        else:
            raise ValueError("invalid offset: " + s)

    def _parse_rfc(self, s):
        lines = s.splitlines()
        if not lines:
            raise ValueError("empty string")

        # Unfold
        i = 0
        while i < len(lines):
            line = lines[i].rstrip()
            if not line:
                del lines[i]
            elif i > 0 and line[0] == " ":
                lines[i-1] += line[1:]
                del lines[i]
            else:
                i += 1

        tzid = None
        comps = []
        invtz = False
        comptype = None
        for line in lines:
            if not line:
                continue
            name, value = line.split(':', 1)
            parms = name.split(';')
            if not parms:
                raise ValueError("empty property name")
            name = parms[0].upper()
            parms = parms[1:]
            if invtz:
                if name == "BEGIN":
                    if value in ("STANDARD", "DAYLIGHT"):
                        # Process component
                        pass
                    else:
                        raise ValueError("unknown component: "+value)
                    comptype = value
                    founddtstart = False
                    tzoffsetfrom = None
                    tzoffsetto = None
                    rrulelines = []
                    tzname = None
                elif name == "END":
                    if value == "VTIMEZONE":
                        if comptype:
                            raise ValueError("component not closed: "+comptype)
                        if not tzid:
                            raise ValueError("mandatory TZID not found")
                        if not comps:
                            raise ValueError(
                                "at least one component is needed")
                        # Process vtimezone
                        self._vtz[tzid] = _tzicalvtz(tzid, comps)
                        invtz = False
                    elif value == comptype:
                        if not founddtstart:
                            raise ValueError("mandatory DTSTART not found")
                        if tzoffsetfrom is None:
                            raise ValueError(
                                "mandatory TZOFFSETFROM not found")
                        if tzoffsetto is None:
                            raise ValueError(
                                "mandatory TZOFFSETFROM not found")
                        # Process component
                        rr = None
                        if rrulelines:
                            rr = rrule.rrulestr("\n".join(rrulelines),
                                                compatible=True,
                                                ignoretz=True,
                                                cache=True)
                        comp = _tzicalvtzcomp(tzoffsetfrom, tzoffsetto,
                                              (comptype == "DAYLIGHT"),
                                              tzname, rr)
                        comps.append(comp)
                        comptype = None
                    else:
                        raise ValueError("invalid component end: "+value)
                elif comptype:
                    if name == "DTSTART":
                        # DTSTART in VTIMEZONE takes a subset of valid RRULE
                        # values under RFC 5545.
                        for parm in parms:
                            if parm != 'VALUE=DATE-TIME':
                                msg = ('Unsupported DTSTART param in ' +
                                       'VTIMEZONE: ' + parm)
                                raise ValueError(msg)
                        rrulelines.append(line)
                        founddtstart = True
                    elif name in ("RRULE", "RDATE", "EXRULE", "EXDATE"):
                        rrulelines.append(line)
                    elif name == "TZOFFSETFROM":
                        if parms:
                            raise ValueError(
                                "unsupported %s parm: %s " % (name, parms[0]))
                        tzoffsetfrom = self._parse_offset(value)
                    elif name == "TZOFFSETTO":
                        if parms:
                            raise ValueError(
                                "unsupported TZOFFSETTO parm: "+parms[0])
                        tzoffsetto = self._parse_offset(value)
                    elif name == "TZNAME":
                        if parms:
                            raise ValueError(
                                "unsupported TZNAME parm: "+parms[0])
                        tzname = value
                    elif name == "COMMENT":
                        pass
                    else:
                        raise ValueError("unsupported property: "+name)
                else:
                    if name == "TZID":
                        if parms:
                            raise ValueError(
                                "unsupported TZID parm: "+parms[0])
                        tzid = value
                    elif name in ("TZURL", "LAST-MODIFIED", "COMMENT"):
                        pass
                    else:
                        raise ValueError("unsupported property: "+name)
            elif name == "BEGIN" and value == "VTIMEZONE":
                tzid = None
                comps = []
                invtz = True

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, repr(self._s))


if sys.platform != "win32":
    TZFILES = ["/etc/localtime", "localtime"]
    TZPATHS = ["/usr/share/zoneinfo",
               "/usr/lib/zoneinfo",
               "/usr/share/lib/zoneinfo",
               "/etc/zoneinfo"]
else:
    TZFILES = []
    TZPATHS = []


def __get_gettz():
    tzlocal_classes = (tzlocal,)
    if tzwinlocal is not None:
        tzlocal_classes += (tzwinlocal,)

    class GettzFunc(object):
        """
        Retrieve a time zone object from a string representation

        This function is intended to retrieve the :py:class:`tzinfo` subclass
        that best represents the time zone that would be used if a POSIX
        `TZ variable`_ were set to the same value.

        If no argument or an empty string is passed to ``gettz``, local time
        is returned:

        .. code-block:: python3

            >>> gettz()
            tzfile('/etc/localtime')

        This function is also the preferred way to map IANA tz database keys
        to :class:`tzfile` objects:

        .. code-block:: python3

            >>> gettz('Pacific/Kiritimati')
            tzfile('/usr/share/zoneinfo/Pacific/Kiritimati')

        On Windows, the standard is extended to include the Windows-specific
        zone names provided by the operating system:

        .. code-block:: python3

            >>> gettz('Egypt Standard Time')
            tzwin('Egypt Standard Time')

        Passing a GNU ``TZ`` style string time zone specification returns a
        :class:`tzstr` object:

        .. code-block:: python3

            >>> gettz('AEST-10AEDT-11,M10.1.0/2,M4.1.0/3')
            tzstr('AEST-10AEDT-11,M10.1.0/2,M4.1.0/3')

        :param name:
            A time zone name (IANA, or, on Windows, Windows keys), location of
            a ``tzfile(5)`` zoneinfo file or ``TZ`` variable style time zone
            specifier. An empty string, no argument or ``None`` is interpreted
            as local time.

        :return:
            Returns an instance of one of ``dateutil``'s :py:class:`tzinfo`
            subclasses.

        .. versionchanged:: 2.7.0

            After version 2.7.0, any two calls to ``gettz`` using the same
            input strings will return the same object:

            .. code-block:: python3

                >>> tz.gettz('America/Chicago') is tz.gettz('America/Chicago')
                True

            In addition to improving performance, this ensures that
            `"same zone" semantics`_ are used for datetimes in the same zone.


        .. _`TZ variable`:
            https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html

        .. _`"same zone" semantics`:
            https://blog.ganssle.io/articles/2018/02/aware-datetime-arithmetic.html
        """
        def __init__(self):

            self.__instances = weakref.WeakValueDictionary()
            self.__strong_cache_size = 8
            self.__strong_cache = OrderedDict()
            self._cache_lock = _thread.allocate_lock()

        def __call__(self, name=None):
            with self._cache_lock:
                rv = self.__instances.get(name, None)

                if rv is None:
                    rv = self.nocache(name=name)
                    if not (name is None
                            or isinstance(rv, tzlocal_classes)
                            or rv is None):
                        # tzlocal is slightly more complicated than the other
                        # time zone providers because it depends on environment
                        # at construction time, so don't cache that.
                        #
                        # We also cannot store weak references to None, so we
                        # will also not store that.
                        self.__instances[name] = rv
                    else:
                        # No need for strong caching, return immediately
                        return rv

                self.__strong_cache[name] = self.__strong_cache.pop(name, rv)

                if len(self.__strong_cache) > self.__strong_cache_size:
                    self.__strong_cache.popitem(last=False)

            return rv

        def set_cache_size(self, size):
            with self._cache_lock:
                self.__strong_cache_size = size
                while len(self.__strong_cache) > size:
                    self.__strong_cache.popitem(last=False)

        def cache_clear(self):
            with self._cache_lock:
                self.__instances = weakref.WeakValueDictionary()
                self.__strong_cache.clear()

        @staticmethod
        def nocache(name=None):
            """A non-cached version of gettz"""
            tz = None
            if not name:
                try:
                    name = os.environ["TZ"]
                except KeyError:
                    pass
            if name is None or name == ":":
                for filepath in TZFILES:
                    if not os.path.isabs(filepath):
                        filename = filepath
                        for path in TZPATHS:
                            filepath = os.path.join(path, filename)
                            if os.path.isfile(filepath):
                                break
                        else:
                            continue
                    if os.path.isfile(filepath):
                        try:
                            tz = tzfile(filepath)
                            break
                        except (IOError, OSError, ValueError):
                            pass
                else:
                    tz = tzlocal()
            else:
                try:
                    if name.startswith(":"):
                        name = name[1:]
                except TypeError as e:
                    if isinstance(name, bytes):
                        new_msg = "gettz argument should be str, not bytes"
                        six.raise_from(TypeError(new_msg), e)
                    else:
                        raise
                if os.path.isabs(name):
                    if os.path.isfile(name):
                        tz = tzfile(name)
                    else:
                        tz = None
                else:
                    for path in TZPATHS:
                        filepath = os.path.join(path, name)
                        if not os.path.isfile(filepath):
                            filepath = filepath.replace(' ', '_')
                            if not os.path.isfile(filepath):
                                continue
                        try:
                            tz = tzfile(filepath)
                            break
                        except (IOError, OSError, ValueError):
                            pass
                    else:
                        tz = None
                        if tzwin is not None:
                            try:
                                tz = tzwin(name)
                            except (WindowsError, UnicodeEncodeError):
                                # UnicodeEncodeError is for Python 2.7 compat
                                tz = None

                        if not tz:
                            from dateutil.zoneinfo import get_zonefile_instance
                            tz = get_zonefile_instance().get(name)

                        if not tz:
                            for c in name:
                                # name is not a tzstr unless it has at least
                                # one offset. For short values of "name", an
                                # explicit for loop seems to be the fastest way
                                # To determine if a string contains a digit
                                if c in "0123456789":
                                    try:
                                        tz = tzstr(name)
                                    except ValueError:
                                        pass
                                    break
                            else:
                                if name in ("GMT", "UTC"):
                                    tz = UTC
                                elif name in time.tzname:
                                    tz = tzlocal()
            return tz

    return GettzFunc()


gettz = __get_gettz()
del __get_gettz


def datetime_exists(dt, tz=None):
    """
    Given a datetime and a time zone, determine whether or not a given datetime
    would fall in a gap.

    :param dt:
        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz``
        is provided.)

    :param tz:
        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If
        ``None`` or not provided, the datetime's own time zone will be used.

    :return:
        Returns a boolean value whether or not the "wall time" exists in
        ``tz``.

    .. versionadded:: 2.7.0
    """
    if tz is None:
        if dt.tzinfo is None:
            raise ValueError('Datetime is naive and no time zone provided.')
        tz = dt.tzinfo

    dt = dt.replace(tzinfo=None)

    # This is essentially a test of whether or not the datetime can survive
    # a round trip to UTC.
    dt_rt = dt.replace(tzinfo=tz).astimezone(UTC).astimezone(tz)
    dt_rt = dt_rt.replace(tzinfo=None)

    return dt == dt_rt


def datetime_ambiguous(dt, tz=None):
    """
    Given a datetime and a time zone, determine whether or not a given datetime
    is ambiguous (i.e if there are two times differentiated only by their DST
    status).

    :param dt:
        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz``
        is provided.)

    :param tz:
        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If
        ``None`` or not provided, the datetime's own time zone will be used.

    :return:
        Returns a boolean value whether or not the "wall time" is ambiguous in
        ``tz``.

    .. versionadded:: 2.6.0
    """
    if tz is None:
        if dt.tzinfo is None:
            raise ValueError('Datetime is naive and no time zone provided.')

        tz = dt.tzinfo

    # If a time zone defines its own "is_ambiguous" function, we'll use that.
    is_ambiguous_fn = getattr(tz, 'is_ambiguous', None)
    if is_ambiguous_fn is not None:
        try:
            return tz.is_ambiguous(dt)
        except Exception:
            pass

    # If it doesn't come out and tell us it's ambiguous, we'll just check if
    # the fold attribute has any effect on this particular date and time.
    dt = dt.replace(tzinfo=tz)
    wall_0 = enfold(dt, fold=0)
    wall_1 = enfold(dt, fold=1)

    same_offset = wall_0.utcoffset() == wall_1.utcoffset()
    same_dst = wall_0.dst() == wall_1.dst()

    return not (same_offset and same_dst)


def resolve_imaginary(dt):
    """
    Given a datetime that may be imaginary, return an existing datetime.

    This function assumes that an imaginary datetime represents what the
    wall time would be in a zone had the offset transition not occurred, so
    it will always fall forward by the transition's change in offset.

    .. doctest::

        >>> from dateutil import tz
        >>> from datetime import datetime
        >>> NYC = tz.gettz('America/New_York')
        >>> print(tz.resolve_imaginary(datetime(2017, 3, 12, 2, 30, tzinfo=NYC)))
        2017-03-12 03:30:00-04:00

        >>> KIR = tz.gettz('Pacific/Kiritimati')
        >>> print(tz.resolve_imaginary(datetime(1995, 1, 1, 12, 30, tzinfo=KIR)))
        1995-01-02 12:30:00+14:00

    As a note, :func:`datetime.astimezone` is guaranteed to produce a valid,
    existing datetime, so a round-trip to and from UTC is sufficient to get
    an extant datetime, however, this generally "falls back" to an earlier time
    rather than falling forward to the STD side (though no guarantees are made
    about this behavior).

    :param dt:
        A :class:`datetime.datetime` which may or may not exist.

    :return:
        Returns an existing :class:`datetime.datetime`. If ``dt`` was not
        imaginary, the datetime returned is guaranteed to be the same object
        passed to the function.

    .. versionadded:: 2.7.0
    """
    if dt.tzinfo is not None and not datetime_exists(dt):

        curr_offset = (dt + datetime.timedelta(hours=24)).utcoffset()
        old_offset = (dt - datetime.timedelta(hours=24)).utcoffset()

        dt += curr_offset - old_offset

    return dt


def _datetime_to_timestamp(dt):
    """
    Convert a :class:`datetime.datetime` object to an epoch timestamp in
    seconds since January 1, 1970, ignoring the time zone.
    """
    return (dt.replace(tzinfo=None) - EPOCH).total_seconds()


if sys.version_info >= (3, 6):
    def _get_supported_offset(second_offset):
        return second_offset
else:
    def _get_supported_offset(second_offset):
        # For python pre-3.6, round to full-minutes if that's not the case.
        # Python's datetime doesn't accept sub-minute timezones. Check
        # http://python.org/sf/1447945 or https://bugs.python.org/issue5288
        # for some information.
        old_offset = second_offset
        calculated_offset = 60 * ((second_offset + 30) // 60)
        return calculated_offset


try:
    # Python 3.7 feature
    from contextlib import nullcontext as _nullcontext
except ImportError:
    class _nullcontext(object):
        """
        Class for wrapping contexts so that they are passed through in a
        with statement.
        """
        def __init__(self, context):
            self.context = context

        def __enter__(self):
            return self.context

        def __exit__(*args, **kwargs):
            pass

# vim:ts=4:sw=4:et
# -*- coding: utf-8 -*-
"""
This module provides an interface to the native time zone data on Windows,
including :py:class:`datetime.tzinfo` implementations.

Attempting to import this module on a non-Windows platform will raise an
:py:obj:`ImportError`.
"""
# This code was originally contributed by Jeffrey Harris.
import datetime
import struct

from six.moves import winreg
from six import text_type

try:
    import ctypes
    from ctypes import wintypes
except ValueError:
    # ValueError is raised on non-Windows systems for some horrible reason.
    raise ImportError("Running tzwin on non-Windows system")

from ._common import tzrangebase

__all__ = ["tzwin", "tzwinlocal", "tzres"]

ONEWEEK = datetime.timedelta(7)

TZKEYNAMENT = r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones"
TZKEYNAME9X = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Time Zones"
TZLOCALKEYNAME = r"SYSTEM\CurrentControlSet\Control\TimeZoneInformation"


def _settzkeyname():
    handle = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)
    try:
        winreg.OpenKey(handle, TZKEYNAMENT).Close()
        TZKEYNAME = TZKEYNAMENT
    except WindowsError:
        TZKEYNAME = TZKEYNAME9X
    handle.Close()
    return TZKEYNAME


TZKEYNAME = _settzkeyname()


class tzres(object):
    """
    Class for accessing ``tzres.dll``, which contains timezone name related
    resources.

    .. versionadded:: 2.5.0
    """
    p_wchar = ctypes.POINTER(wintypes.WCHAR)        # Pointer to a wide char

    def __init__(self, tzres_loc='tzres.dll'):
        # Load the user32 DLL so we can load strings from tzres
        user32 = ctypes.WinDLL('user32')

        # Specify the LoadStringW function
        user32.LoadStringW.argtypes = (wintypes.HINSTANCE,
                                       wintypes.UINT,
                                       wintypes.LPWSTR,
                                       ctypes.c_int)

        self.LoadStringW = user32.LoadStringW
        self._tzres = ctypes.WinDLL(tzres_loc)
        self.tzres_loc = tzres_loc

    def load_name(self, offset):
        """
        Load a timezone name from a DLL offset (integer).

        >>> from dateutil.tzwin import tzres
        >>> tzr = tzres()
        >>> print(tzr.load_name(112))
        'Eastern Standard Time'

        :param offset:
            A positive integer value referring to a string from the tzres dll.

        .. note::

            Offsets found in the registry are generally of the form
            ``@tzres.dll,-114``. The offset in this case is 114, not -114.

        """
        resource = self.p_wchar()
        lpBuffer = ctypes.cast(ctypes.byref(resource), wintypes.LPWSTR)
        nchar = self.LoadStringW(self._tzres._handle, offset, lpBuffer, 0)
        return resource[:nchar]

    def name_from_string(self, tzname_str):
        """
        Parse strings as returned from the Windows registry into the time zone
        name as defined in the registry.

        >>> from dateutil.tzwin import tzres
        >>> tzr = tzres()
        >>> print(tzr.name_from_string('@tzres.dll,-251'))
        'Dateline Daylight Time'
        >>> print(tzr.name_from_string('Eastern Standard Time'))
        'Eastern Standard Time'

        :param tzname_str:
            A timezone name string as returned from a Windows registry key.

        :return:
            Returns the localized timezone string from tzres.dll if the string
            is of the form `@tzres.dll,-offset`, else returns the input string.
        """
        if not tzname_str.startswith('@'):
            return tzname_str

        name_splt = tzname_str.split(',-')
        try:
            offset = int(name_splt[1])
        except:
            raise ValueError("Malformed timezone string.")

        return self.load_name(offset)


class tzwinbase(tzrangebase):
    """tzinfo class based on win32's timezones available in the registry."""
    def __init__(self):
        raise NotImplementedError('tzwinbase is an abstract base class')

    def __eq__(self, other):
        # Compare on all relevant dimensions, including name.
        if not isinstance(other, tzwinbase):
            return NotImplemented

        return  (self._std_offset == other._std_offset and
                 self._dst_offset == other._dst_offset and
                 self._stddayofweek == other._stddayofweek and
                 self._dstdayofweek == other._dstdayofweek and
                 self._stdweeknumber == other._stdweeknumber and
                 self._dstweeknumber == other._dstweeknumber and
                 self._stdhour == other._stdhour and
                 self._dsthour == other._dsthour and
                 self._stdminute == other._stdminute and
                 self._dstminute == other._dstminute and
                 self._std_abbr == other._std_abbr and
                 self._dst_abbr == other._dst_abbr)

    @staticmethod
    def list():
        """Return a list of all time zones known to the system."""
        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:
            with winreg.OpenKey(handle, TZKEYNAME) as tzkey:
                result = [winreg.EnumKey(tzkey, i)
                          for i in range(winreg.QueryInfoKey(tzkey)[0])]
        return result

    def display(self):
        """
        Return the display name of the time zone.
        """
        return self._display

    def transitions(self, year):
        """
        For a given year, get the DST on and off transition times, expressed
        always on the standard time side. For zones with no transitions, this
        function returns ``None``.

        :param year:
            The year whose transitions you would like to query.

        :return:
            Returns a :class:`tuple` of :class:`datetime.datetime` objects,
            ``(dston, dstoff)`` for zones with an annual DST transition, or
            ``None`` for fixed offset zones.
        """

        if not self.hasdst:
            return None

        dston = picknthweekday(year, self._dstmonth, self._dstdayofweek,
                               self._dsthour, self._dstminute,
                               self._dstweeknumber)

        dstoff = picknthweekday(year, self._stdmonth, self._stddayofweek,
                                self._stdhour, self._stdminute,
                                self._stdweeknumber)

        # Ambiguous dates default to the STD side
        dstoff -= self._dst_base_offset

        return dston, dstoff

    def _get_hasdst(self):
        return self._dstmonth != 0

    @property
    def _dst_base_offset(self):
        return self._dst_base_offset_


class tzwin(tzwinbase):
    """
    Time zone object created from the zone info in the Windows registry

    These are similar to :py:class:`dateutil.tz.tzrange` objects in that
    the time zone data is provided in the format of a single offset rule
    for either 0 or 2 time zone transitions per year.

    :param: name
        The name of a Windows time zone key, e.g. "Eastern Standard Time".
        The full list of keys can be retrieved with :func:`tzwin.list`.
    """

    def __init__(self, name):
        self._name = name

        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:
            tzkeyname = text_type("{kn}\\{name}").format(kn=TZKEYNAME, name=name)
            with winreg.OpenKey(handle, tzkeyname) as tzkey:
                keydict = valuestodict(tzkey)

        self._std_abbr = keydict["Std"]
        self._dst_abbr = keydict["Dlt"]

        self._display = keydict["Display"]

        # See http://ww_winreg.jsiinc.com/SUBA/tip0300/rh0398.htm
        tup = struct.unpack("=3l16h", keydict["TZI"])
        stdoffset = -tup[0]-tup[1]          # Bias + StandardBias * -1
        dstoffset = stdoffset-tup[2]        # + DaylightBias * -1
        self._std_offset = datetime.timedelta(minutes=stdoffset)
        self._dst_offset = datetime.timedelta(minutes=dstoffset)

        # for the meaning see the win32 TIME_ZONE_INFORMATION structure docs
        # http://msdn.microsoft.com/en-us/library/windows/desktop/ms725481(v=vs.85).aspx
        (self._stdmonth,
         self._stddayofweek,   # Sunday = 0
         self._stdweeknumber,  # Last = 5
         self._stdhour,
         self._stdminute) = tup[4:9]

        (self._dstmonth,
         self._dstdayofweek,   # Sunday = 0
         self._dstweeknumber,  # Last = 5
         self._dsthour,
         self._dstminute) = tup[12:17]

        self._dst_base_offset_ = self._dst_offset - self._std_offset
        self.hasdst = self._get_hasdst()

    def __repr__(self):
        return "tzwin(%s)" % repr(self._name)

    def __reduce__(self):
        return (self.__class__, (self._name,))


class tzwinlocal(tzwinbase):
    """
    Class representing the local time zone information in the Windows registry

    While :class:`dateutil.tz.tzlocal` makes system calls (via the :mod:`time`
    module) to retrieve time zone information, ``tzwinlocal`` retrieves the
    rules directly from the Windows registry and creates an object like
    :class:`dateutil.tz.tzwin`.

    Because Windows does not have an equivalent of :func:`time.tzset`, on
    Windows, :class:`dateutil.tz.tzlocal` instances will always reflect the
    time zone settings *at the time that the process was started*, meaning
    changes to the machine's time zone settings during the run of a program
    on Windows will **not** be reflected by :class:`dateutil.tz.tzlocal`.
    Because ``tzwinlocal`` reads the registry directly, it is unaffected by
    this issue.
    """
    def __init__(self):
        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:
            with winreg.OpenKey(handle, TZLOCALKEYNAME) as tzlocalkey:
                keydict = valuestodict(tzlocalkey)

            self._std_abbr = keydict["StandardName"]
            self._dst_abbr = keydict["DaylightName"]

            try:
                tzkeyname = text_type('{kn}\\{sn}').format(kn=TZKEYNAME,
                                                          sn=self._std_abbr)
                with winreg.OpenKey(handle, tzkeyname) as tzkey:
                    _keydict = valuestodict(tzkey)
                    self._display = _keydict["Display"]
            except OSError:
                self._display = None

        stdoffset = -keydict["Bias"]-keydict["StandardBias"]
        dstoffset = stdoffset-keydict["DaylightBias"]

        self._std_offset = datetime.timedelta(minutes=stdoffset)
        self._dst_offset = datetime.timedelta(minutes=dstoffset)

        # For reasons unclear, in this particular key, the day of week has been
        # moved to the END of the SYSTEMTIME structure.
        tup = struct.unpack("=8h", keydict["StandardStart"])

        (self._stdmonth,
         self._stdweeknumber,  # Last = 5
         self._stdhour,
         self._stdminute) = tup[1:5]

        self._stddayofweek = tup[7]

        tup = struct.unpack("=8h", keydict["DaylightStart"])

        (self._dstmonth,
         self._dstweeknumber,  # Last = 5
         self._dsthour,
         self._dstminute) = tup[1:5]

        self._dstdayofweek = tup[7]

        self._dst_base_offset_ = self._dst_offset - self._std_offset
        self.hasdst = self._get_hasdst()

    def __repr__(self):
        return "tzwinlocal()"

    def __str__(self):
        # str will return the standard name, not the daylight name.
        return "tzwinlocal(%s)" % repr(self._std_abbr)

    def __reduce__(self):
        return (self.__class__, ())


def picknthweekday(year, month, dayofweek, hour, minute, whichweek):
    """ dayofweek == 0 means Sunday, whichweek 5 means last instance """
    first = datetime.datetime(year, month, 1, hour, minute)

    # This will work if dayofweek is ISO weekday (1-7) or Microsoft-style (0-6),
    # Because 7 % 7 = 0
    weekdayone = first.replace(day=((dayofweek - first.isoweekday()) % 7) + 1)
    wd = weekdayone + ((whichweek - 1) * ONEWEEK)
    if (wd.month != month):
        wd -= ONEWEEK

    return wd


def valuestodict(key):
    """Convert a registry key's values to a dictionary."""
    dout = {}
    size = winreg.QueryInfoKey(key)[1]
    tz_res = None

    for i in range(size):
        key_name, value, dtype = winreg.EnumValue(key, i)
        if dtype == winreg.REG_DWORD or dtype == winreg.REG_DWORD_LITTLE_ENDIAN:
            # If it's a DWORD (32-bit integer), it's stored as unsigned - convert
            # that to a proper signed integer
            if value & (1 << 31):
                value = value - (1 << 32)
        elif dtype == winreg.REG_SZ:
            # If it's a reference to the tzres DLL, load the actual string
            if value.startswith('@tzres'):
                tz_res = tz_res or tzres()
                value = tz_res.name_from_string(value)

            value = value.rstrip('\x00')    # Remove trailing nulls

        dout[key_name] = value

    return dout
from six import PY2

from functools import wraps

from datetime import datetime, timedelta, tzinfo


ZERO = timedelta(0)

__all__ = ['tzname_in_python2', 'enfold']


def tzname_in_python2(namefunc):
    """Change unicode output into bytestrings in Python 2

    tzname() API changed in Python 3. It used to return bytes, but was changed
    to unicode strings
    """
    if PY2:
        @wraps(namefunc)
        def adjust_encoding(*args, **kwargs):
            name = namefunc(*args, **kwargs)
            if name is not None:
                name = name.encode()

            return name

        return adjust_encoding
    else:
        return namefunc


# The following is adapted from Alexander Belopolsky's tz library
# https://github.com/abalkin/tz
if hasattr(datetime, 'fold'):
    # This is the pre-python 3.6 fold situation
    def enfold(dt, fold=1):
        """
        Provides a unified interface for assigning the ``fold`` attribute to
        datetimes both before and after the implementation of PEP-495.

        :param fold:
            The value for the ``fold`` attribute in the returned datetime. This
            should be either 0 or 1.

        :return:
            Returns an object for which ``getattr(dt, 'fold', 0)`` returns
            ``fold`` for all versions of Python. In versions prior to
            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a
            subclass of :py:class:`datetime.datetime` with the ``fold``
            attribute added, if ``fold`` is 1.

        .. versionadded:: 2.6.0
        """
        return dt.replace(fold=fold)

else:
    class _DatetimeWithFold(datetime):
        """
        This is a class designed to provide a PEP 495-compliant interface for
        Python versions before 3.6. It is used only for dates in a fold, so
        the ``fold`` attribute is fixed at ``1``.

        .. versionadded:: 2.6.0
        """
        __slots__ = ()

        def replace(self, *args, **kwargs):
            """
            Return a datetime with the same attributes, except for those
            attributes given new values by whichever keyword arguments are
            specified. Note that tzinfo=None can be specified to create a naive
            datetime from an aware datetime with no conversion of date and time
            data.

            This is reimplemented in ``_DatetimeWithFold`` because pypy3 will
            return a ``datetime.datetime`` even if ``fold`` is unchanged.
            """
            argnames = (
                'year', 'month', 'day', 'hour', 'minute', 'second',
                'microsecond', 'tzinfo'
            )

            for arg, argname in zip(args, argnames):
                if argname in kwargs:
                    raise TypeError('Duplicate argument: {}'.format(argname))

                kwargs[argname] = arg

            for argname in argnames:
                if argname not in kwargs:
                    kwargs[argname] = getattr(self, argname)

            dt_class = self.__class__ if kwargs.get('fold', 1) else datetime

            return dt_class(**kwargs)

        @property
        def fold(self):
            return 1

    def enfold(dt, fold=1):
        """
        Provides a unified interface for assigning the ``fold`` attribute to
        datetimes both before and after the implementation of PEP-495.

        :param fold:
            The value for the ``fold`` attribute in the returned datetime. This
            should be either 0 or 1.

        :return:
            Returns an object for which ``getattr(dt, 'fold', 0)`` returns
            ``fold`` for all versions of Python. In versions prior to
            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a
            subclass of :py:class:`datetime.datetime` with the ``fold``
            attribute added, if ``fold`` is 1.

        .. versionadded:: 2.6.0
        """
        if getattr(dt, 'fold', 0) == fold:
            return dt

        args = dt.timetuple()[:6]
        args += (dt.microsecond, dt.tzinfo)

        if fold:
            return _DatetimeWithFold(*args)
        else:
            return datetime(*args)


def _validate_fromutc_inputs(f):
    """
    The CPython version of ``fromutc`` checks that the input is a ``datetime``
    object and that ``self`` is attached as its ``tzinfo``.
    """
    @wraps(f)
    def fromutc(self, dt):
        if not isinstance(dt, datetime):
            raise TypeError("fromutc() requires a datetime argument")
        if dt.tzinfo is not self:
            raise ValueError("dt.tzinfo is not self")

        return f(self, dt)

    return fromutc


class _tzinfo(tzinfo):
    """
    Base class for all ``dateutil`` ``tzinfo`` objects.
    """

    def is_ambiguous(self, dt):
        """
        Whether or not the "wall time" of a given datetime is ambiguous in this
        zone.

        :param dt:
            A :py:class:`datetime.datetime`, naive or time zone aware.


        :return:
            Returns ``True`` if ambiguous, ``False`` otherwise.

        .. versionadded:: 2.6.0
        """

        dt = dt.replace(tzinfo=self)

        wall_0 = enfold(dt, fold=0)
        wall_1 = enfold(dt, fold=1)

        same_offset = wall_0.utcoffset() == wall_1.utcoffset()
        same_dt = wall_0.replace(tzinfo=None) == wall_1.replace(tzinfo=None)

        return same_dt and not same_offset

    def _fold_status(self, dt_utc, dt_wall):
        """
        Determine the fold status of a "wall" datetime, given a representation
        of the same datetime as a (naive) UTC datetime. This is calculated based
        on the assumption that ``dt.utcoffset() - dt.dst()`` is constant for all
        datetimes, and that this offset is the actual number of hours separating
        ``dt_utc`` and ``dt_wall``.

        :param dt_utc:
            Representation of the datetime as UTC

        :param dt_wall:
            Representation of the datetime as "wall time". This parameter must
            either have a `fold` attribute or have a fold-naive
            :class:`datetime.tzinfo` attached, otherwise the calculation may
            fail.
        """
        if self.is_ambiguous(dt_wall):
            delta_wall = dt_wall - dt_utc
            _fold = int(delta_wall == (dt_utc.utcoffset() - dt_utc.dst()))
        else:
            _fold = 0

        return _fold

    def _fold(self, dt):
        return getattr(dt, 'fold', 0)

    def _fromutc(self, dt):
        """
        Given a timezone-aware datetime in a given timezone, calculates a
        timezone-aware datetime in a new timezone.

        Since this is the one time that we *know* we have an unambiguous
        datetime object, we take this opportunity to determine whether the
        datetime is ambiguous and in a "fold" state (e.g. if it's the first
        occurrence, chronologically, of the ambiguous datetime).

        :param dt:
            A timezone-aware :class:`datetime.datetime` object.
        """

        # Re-implement the algorithm from Python's datetime.py
        dtoff = dt.utcoffset()
        if dtoff is None:
            raise ValueError("fromutc() requires a non-None utcoffset() "
                             "result")

        # The original datetime.py code assumes that `dst()` defaults to
        # zero during ambiguous times. PEP 495 inverts this presumption, so
        # for pre-PEP 495 versions of python, we need to tweak the algorithm.
        dtdst = dt.dst()
        if dtdst is None:
            raise ValueError("fromutc() requires a non-None dst() result")
        delta = dtoff - dtdst

        dt += delta
        # Set fold=1 so we can default to being in the fold for
        # ambiguous dates.
        dtdst = enfold(dt, fold=1).dst()
        if dtdst is None:
            raise ValueError("fromutc(): dt.dst gave inconsistent "
                             "results; cannot convert")
        return dt + dtdst

    @_validate_fromutc_inputs
    def fromutc(self, dt):
        """
        Given a timezone-aware datetime in a given timezone, calculates a
        timezone-aware datetime in a new timezone.

        Since this is the one time that we *know* we have an unambiguous
        datetime object, we take this opportunity to determine whether the
        datetime is ambiguous and in a "fold" state (e.g. if it's the first
        occurrence, chronologically, of the ambiguous datetime).

        :param dt:
            A timezone-aware :class:`datetime.datetime` object.
        """
        dt_wall = self._fromutc(dt)

        # Calculate the fold status given the two datetimes.
        _fold = self._fold_status(dt, dt_wall)

        # Set the default fold value for ambiguous dates
        return enfold(dt_wall, fold=_fold)


class tzrangebase(_tzinfo):
    """
    This is an abstract base class for time zones represented by an annual
    transition into and out of DST. Child classes should implement the following
    methods:

        * ``__init__(self, *args, **kwargs)``
        * ``transitions(self, year)`` - this is expected to return a tuple of
          datetimes representing the DST on and off transitions in standard
          time.

    A fully initialized ``tzrangebase`` subclass should also provide the
    following attributes:
        * ``hasdst``: Boolean whether or not the zone uses DST.
        * ``_dst_offset`` / ``_std_offset``: :class:`datetime.timedelta` objects
          representing the respective UTC offsets.
        * ``_dst_abbr`` / ``_std_abbr``: Strings representing the timezone short
          abbreviations in DST and STD, respectively.
        * ``_hasdst``: Whether or not the zone has DST.

    .. versionadded:: 2.6.0
    """
    def __init__(self):
        raise NotImplementedError('tzrangebase is an abstract base class')

    def utcoffset(self, dt):
        isdst = self._isdst(dt)

        if isdst is None:
            return None
        elif isdst:
            return self._dst_offset
        else:
            return self._std_offset

    def dst(self, dt):
        isdst = self._isdst(dt)

        if isdst is None:
            return None
        elif isdst:
            return self._dst_base_offset
        else:
            return ZERO

    @tzname_in_python2
    def tzname(self, dt):
        if self._isdst(dt):
            return self._dst_abbr
        else:
            return self._std_abbr

    def fromutc(self, dt):
        """ Given a datetime in UTC, return local time """
        if not isinstance(dt, datetime):
            raise TypeError("fromutc() requires a datetime argument")

        if dt.tzinfo is not self:
            raise ValueError("dt.tzinfo is not self")

        # Get transitions - if there are none, fixed offset
        transitions = self.transitions(dt.year)
        if transitions is None:
            return dt + self.utcoffset(dt)

        # Get the transition times in UTC
        dston, dstoff = transitions

        dston -= self._std_offset
        dstoff -= self._std_offset

        utc_transitions = (dston, dstoff)
        dt_utc = dt.replace(tzinfo=None)

        isdst = self._naive_isdst(dt_utc, utc_transitions)

        if isdst:
            dt_wall = dt + self._dst_offset
        else:
            dt_wall = dt + self._std_offset

        _fold = int(not isdst and self.is_ambiguous(dt_wall))

        return enfold(dt_wall, fold=_fold)

    def is_ambiguous(self, dt):
        """
        Whether or not the "wall time" of a given datetime is ambiguous in this
        zone.

        :param dt:
            A :py:class:`datetime.datetime`, naive or time zone aware.


        :return:
            Returns ``True`` if ambiguous, ``False`` otherwise.

        .. versionadded:: 2.6.0
        """
        if not self.hasdst:
            return False

        start, end = self.transitions(dt.year)

        dt = dt.replace(tzinfo=None)
        return (end <= dt < end + self._dst_base_offset)

    def _isdst(self, dt):
        if not self.hasdst:
            return False
        elif dt is None:
            return None

        transitions = self.transitions(dt.year)

        if transitions is None:
            return False

        dt = dt.replace(tzinfo=None)

        isdst = self._naive_isdst(dt, transitions)

        # Handle ambiguous dates
        if not isdst and self.is_ambiguous(dt):
            return not self._fold(dt)
        else:
            return isdst

    def _naive_isdst(self, dt, transitions):
        dston, dstoff = transitions

        dt = dt.replace(tzinfo=None)

        if dston < dstoff:
            isdst = dston <= dt < dstoff
        else:
            isdst = not dstoff <= dt < dston

        return isdst

    @property
    def _dst_base_offset(self):
        return self._dst_offset - self._std_offset

    __hash__ = None

    def __ne__(self, other):
        return not (self == other)

    def __repr__(self):
        return "%s(...)" % self.__class__.__name__

    __reduce__ = object.__reduce__
from datetime import timedelta
import weakref
from collections import OrderedDict

from six.moves import _thread


class _TzSingleton(type):
    def __init__(cls, *args, **kwargs):
        cls.__instance = None
        super(_TzSingleton, cls).__init__(*args, **kwargs)

    def __call__(cls):
        if cls.__instance is None:
            cls.__instance = super(_TzSingleton, cls).__call__()
        return cls.__instance


class _TzFactory(type):
    def instance(cls, *args, **kwargs):
        """Alternate constructor that returns a fresh instance"""
        return type.__call__(cls, *args, **kwargs)


class _TzOffsetFactory(_TzFactory):
    def __init__(cls, *args, **kwargs):
        cls.__instances = weakref.WeakValueDictionary()
        cls.__strong_cache = OrderedDict()
        cls.__strong_cache_size = 8

        cls._cache_lock = _thread.allocate_lock()

    def __call__(cls, name, offset):
        if isinstance(offset, timedelta):
            key = (name, offset.total_seconds())
        else:
            key = (name, offset)

        instance = cls.__instances.get(key, None)
        if instance is None:
            instance = cls.__instances.setdefault(key,
                                                  cls.instance(name, offset))

        # This lock may not be necessary in Python 3. See GH issue #901
        with cls._cache_lock:
            cls.__strong_cache[key] = cls.__strong_cache.pop(key, instance)

            # Remove an item if the strong cache is overpopulated
            if len(cls.__strong_cache) > cls.__strong_cache_size:
                cls.__strong_cache.popitem(last=False)

        return instance


class _TzStrFactory(_TzFactory):
    def __init__(cls, *args, **kwargs):
        cls.__instances = weakref.WeakValueDictionary()
        cls.__strong_cache = OrderedDict()
        cls.__strong_cache_size = 8

        cls.__cache_lock = _thread.allocate_lock()

    def __call__(cls, s, posix_offset=False):
        key = (s, posix_offset)
        instance = cls.__instances.get(key, None)

        if instance is None:
            instance = cls.__instances.setdefault(key,
                cls.instance(s, posix_offset))

        # This lock may not be necessary in Python 3. See GH issue #901
        with cls.__cache_lock:
            cls.__strong_cache[key] = cls.__strong_cache.pop(key, instance)

            # Remove an item if the strong cache is overpopulated
            if len(cls.__strong_cache) > cls.__strong_cache_size:
                cls.__strong_cache.popitem(last=False)

        return instance

# -*- coding: utf-8 -*-
from .tz import *
from .tz import __doc__

__all__ = ["tzutc", "tzoffset", "tzlocal", "tzfile", "tzrange",
           "tzstr", "tzical", "tzwin", "tzwinlocal", "gettz",
           "enfold", "datetime_ambiguous", "datetime_exists",
           "resolve_imaginary", "UTC", "DeprecatedTzFormatWarning"]


class DeprecatedTzFormatWarning(Warning):
    """Warning raised when time zones are parsed from deprecated formats."""
U
    ^                     @   s  d Z ddlZddlZddlZddlZddlZddlZddlZddlm	Z	 ddl
Z
ddl
mZ ddlmZ ddlmZmZ ddlmZmZ dd	lmZ dd
lmZmZ ddlmZ zddlmZmZ W n ek
r   d ZZY nX ddlmZ edZej dZ!e!" Z#e
$eG dd dej%Z&e& Z'e
$eG dd dej%Z(G dd deZ)G dd de*Z+G dd de*Z,G dd deZ-G dd deZ.e
$eG dd de.Z/G dd de*Z0G d d! d!eZ1G d"d# d#e*Z2ej3d$krd%d&gZ4d'd(d)d*gZ5ng Z4g Z5d+d, Z6e6 Z7[6d<d-d.Z8d=d/d0Z9d1d2 Z:d3d4 Z;ej<d5krXd6d7 Z=nd8d7 Z=zdd9l>m?Z@ W n& ek
r   G d:d; d;e*Z@Y nX dS )>a  
This module offers timezone implementations subclassing the abstract
:py:class:`datetime.tzinfo` type. There are classes to handle tzfile format
files (usually are in :file:`/etc/localtime`, :file:`/usr/share/zoneinfo`,
etc), TZ environment string (in all known formats), given ranges (with help
from relative deltas), local machine timezone, fixed offset timezone, and UTC
timezone.
    N)OrderedDict)string_types)_thread   )tzname_in_python2_tzinfo)tzrangebaseenfold)_validate_fromutc_inputs)_TzSingleton_TzOffsetFactory)_TzStrFactory)tzwin
tzwinlocal)warnc                   @   sb   e Zd ZdZdd Zdd Zedd Zdd	 Ze	d
d Z
dd ZdZdd Zdd ZejZdS )tzutca  
    This is a tzinfo object that represents the UTC time zone.

    **Examples:**

    .. doctest::

        >>> from datetime import *
        >>> from dateutil.tz import *

        >>> datetime.now()
        datetime.datetime(2003, 9, 27, 9, 40, 1, 521290)

        >>> datetime.now(tzutc())
        datetime.datetime(2003, 9, 27, 12, 40, 12, 156379, tzinfo=tzutc())

        >>> datetime.now(tzutc()).tzname()
        'UTC'

    .. versionchanged:: 2.7.0
        ``tzutc()`` is now a singleton, so the result of ``tzutc()`` will
        always return the same object.

        .. doctest::

            >>> from dateutil.tz import tzutc, UTC
            >>> tzutc() is tzutc()
            True
            >>> tzutc() is UTC
            True
    c                 C   s   t S NZEROselfdt r   OC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\tz\tz.py	utcoffsetJ   s    ztzutc.utcoffsetc                 C   s   t S r   r   r   r   r   r   dstM   s    z	tzutc.dstc                 C   s   dS )NUTCr   r   r   r   r   tznameP   s    ztzutc.tznamec                 C   s   dS )6  
        Whether or not the "wall time" of a given datetime is ambiguous in this
        zone.

        :param dt:
            A :py:class:`datetime.datetime`, naive or time zone aware.


        :return:
            Returns ``True`` if ambiguous, ``False`` otherwise.

        .. versionadded:: 2.6.0
        Fr   r   r   r   r   is_ambiguousT   s    ztzutc.is_ambiguousc                 C   s   |S )z
        Fast track version of fromutc() returns the original ``dt`` object for
        any valid :py:class:`datetime.datetime` object.
        r   r   r   r   r   fromutcd   s    ztzutc.fromutcc                 C   s0   t |ttfstS t |tp.t |to.|jtkS r   )
isinstancer   tzoffsetNotImplemented_offsetr   r   otherr   r   r   __eq__l   s
    
ztzutc.__eq__Nc                 C   s
   | |k S r   r   r%   r   r   r   __ne__u   s    ztzutc.__ne__c                 C   s   d| j j S Nz%s()	__class____name__r   r   r   r   __repr__x   s    ztzutc.__repr__)r,   
__module____qualname____doc__r   r   r   r   r   r
   r    r'   __hash__r(   r.   object
__reduce__r   r   r   r   r   )   s   

r   c                   @   sj   e Zd ZdZdd Zdd Zdd Zedd	 Ze	d
d Z
dd Zdd ZdZdd Zdd ZejZdS )r"   a1  
    A simple class for representing a fixed offset from UTC.

    :param name:
        The timezone name, to be returned when ``tzname()`` is called.
    :param offset:
        The time zone offset in seconds, or (since version 2.6.0, represented
        as a :py:class:`datetime.timedelta` object).
    c              	   C   sB   || _ z| }W n ttfk
r*   Y nX tjt|d| _d S Nseconds)_nametotal_seconds	TypeErrorAttributeErrordatetime	timedelta_get_supported_offsetr$   )r   nameoffsetr   r   r   __init__   s    ztzoffset.__init__c                 C   s   | j S r   r$   r   r   r   r   r      s    ztzoffset.utcoffsetc                 C   s   t S r   r   r   r   r   r   r      s    ztzoffset.dstc                 C   s   | j S r   )r8   r   r   r   r   r      s    ztzoffset.tznamec                 C   s
   || j  S r   rB   r   r   r   r   r       s    ztzoffset.fromutcc                 C   s   dS )a4  
        Whether or not the "wall time" of a given datetime is ambiguous in this
        zone.

        :param dt:
            A :py:class:`datetime.datetime`, naive or time zone aware.
        :return:
            Returns ``True`` if ambiguous, ``False`` otherwise.

        .. versionadded:: 2.6.0
        Fr   r   r   r   r   r      s    ztzoffset.is_ambiguousc                 C   s   t |tstS | j|jkS r   )r!   r"   r#   r$   r%   r   r   r   r'      s    
ztzoffset.__eq__Nc                 C   s
   | |k S r   r   r%   r   r   r   r(      s    ztzoffset.__ne__c                 C   s"   d| j jt| jt| j f S )Nz
%s(%s, %s))r+   r,   reprr8   intr$   r9   r-   r   r   r   r.      s    ztzoffset.__repr__)r,   r/   r0   r1   rA   r   r   r   r   r
   r    r   r'   r2   r(   r.   r3   r4   r   r   r   r   r"      s   	

r"   c                       sx   e Zd ZdZ fddZdd Zdd Zedd	 Zd
d Z	dd Z
dddZdd ZdZdd Zdd ZejZ  ZS )tzlocalzR
    A :class:`tzinfo` subclass built around the ``time`` timezone functions.
    c                    sl   t t|   tjtj d| _tjr:tjtj	 d| _
n| j| _
| j
| j | _t| j| _ttj| _d S r5   )superrE   rA   r<   r=   timetimezone_std_offsetdaylightaltzone_dst_offset
_dst_savedbool_hasdsttupler   _tznamesr-   r+   r   r   rA      s    ztzlocal.__init__c                 C   s,   |d kr| j rd S | |r"| jS | jS d S r   )rO   _isdstrL   rI   r   r   r   r   r      s
    
ztzlocal.utcoffsetc                 C   s0   |d kr| j rd S | |r(| j| j S tS d S r   )rO   rS   rL   rI   r   r   r   r   r   r      s
    
ztzlocal.dstc                 C   s   | j | | S r   )rQ   rS   r   r   r   r   r      s    ztzlocal.tznamec                 C   s$   |  |}| o"||  || j kS )r   )_naive_is_dstrM   )r   r   Z	naive_dstr   r   r   r      s    
ztzlocal.is_ambiguousc                 C   s   t |}t|tj jS r   )_datetime_to_timestamprG   	localtimerH   tm_isdst)r   r   	timestampr   r   r   rT     s    ztzlocal._naive_is_dstTc                 C   sF   | j s
dS | |}t|dd }| |rB|d k	r>| | S dS |S )NFfoldT)rO   rT   getattrr   _fold)r   r   Z
fold_naiveZdstvalrY   r   r   r   rS     s    

ztzlocal._isdstc                 C   s   t |tr"| j|jko | j|jkS t |trL| j oJ| jd dkoJ| jtkS t |trz| j ox| jd |j	kox| j|j
kS tS d S )Nr   >   GMTr   )r!   rE   rI   rL   r   rO   rQ   r   r"   r8   r$   r#   r%   r   r   r   r'   .  s"    




ztzlocal.__eq__Nc                 C   s
   | |k S r   r   r%   r   r   r   r(   ?  s    ztzlocal.__ne__c                 C   s   d| j j S r)   r*   r-   r   r   r   r.   B  s    ztzlocal.__repr__)T)r,   r/   r0   r1   rA   r   r   r   r   r   rT   rS   r'   r2   r(   r.   r3   r4   __classcell__r   r   rR   r   rE      s   		

(rE   c                   @   sR   e Zd ZdddddddgZdd	 Zd
d Zdd ZdZdd Zdd Z	dd Z
dS )_ttinfor@   deltaisdstabbrisstdisgmt	dstoffsetc                 C   s   | j D ]}t| |d  qd S r   	__slots__setattr)r   attrr   r   r   rA   L  s    
z_ttinfo.__init__c                 C   sN   g }| j D ],}t| |}|d k	r
|d|t|f  q
d| jjd|f S )Nz%s=%s%s(%s)z, )rf   rZ   appendrC   r+   r,   join)r   lrh   valuer   r   r   r.   P  s    

z_ttinfo.__repr__c                 C   sb   t |tstS | j|jko`| j|jko`| j|jko`| j|jko`| j|jko`| j|jko`| j	|j	kS r   )
r!   r^   r#   r@   r_   r`   ra   rb   rc   rd   r%   r   r   r   r'   X  s    






z_ttinfo.__eq__Nc                 C   s
   | |k S r   r   r%   r   r   r   r(   f  s    z_ttinfo.__ne__c                 C   s$   i }| j D ]}t| |d ||< q
|S r   )rf   rZ   r   stater?   r   r   r   __getstate__i  s    
z_ttinfo.__getstate__c                 C   s(   | j D ]}||krt| |||  qd S r   re   rn   r   r   r   __setstate__o  s    
z_ttinfo.__setstate__)r,   r/   r0   rf   rA   r.   r'   r2   r(   rp   rq   r   r   r   r   r^   H  s     r^   c                   @   s,   e Zd ZdZdddddddd	gZd
d ZdS )_tzfilezw
    Lightweight class for holding the relevant transition and time zone
    information read from binary tzfiles.
    
trans_listtrans_list_utc	trans_idxttinfo_list
ttinfo_std
ttinfo_dstttinfo_beforettinfo_firstc                 K   s$   | j D ]}t| |||d  qd S r   )attrsrg   get)r   kwargsrh   r   r   r   rA   }  s    
z_tzfile.__init__N)r,   r/   r0   r1   r{   rA   r   r   r   r   rr   u  s      rr   c                       s   e Zd ZdZd& fdd	Zdd Zdd Zd'd
dZdd Zdd Z	dd Z
d(ddZdd Zdd Zdd Zedd Zdd ZdZdd Zd d! Zd"d# Zd$d% Z  ZS ))tzfilea	  
    This is a ``tzinfo`` subclass that allows one to use the ``tzfile(5)``
    format timezone files to extract current and historical zone information.

    :param fileobj:
        This can be an opened file stream or a file name that the time zone
        information can be read from.

    :param filename:
        This is an optional parameter specifying the source of the time zone
        information in the event that ``fileobj`` is a file object. If omitted
        and ``fileobj`` is a file stream, this parameter will be set either to
        ``fileobj``'s ``name`` attribute or to ``repr(fileobj)``.

    See `Sources for Time Zone and Daylight Saving Time Data
    <https://data.iana.org/time-zones/tz-link.html>`_ for more information.
    Time zone files can be compiled from the `IANA Time Zone database files
    <https://www.iana.org/time-zones>`_ with the `zic time zone compiler
    <https://www.freebsd.org/cgi/man.cgi?query=zic&sektion=8>`_

    .. note::

        Only construct a ``tzfile`` directly if you have a specific timezone
        file on disk that you want to read into a Python ``tzinfo`` object.
        If you want to get a ``tzfile`` representing a specific IANA zone,
        (e.g. ``'America/New_York'``), you should call
        :func:`dateutil.tz.gettz` with the zone identifier.


    **Examples:**

    Using the US Eastern time zone as an example, we can see that a ``tzfile``
    provides time zone information for the standard Daylight Saving offsets:

    .. testsetup:: tzfile

        from dateutil.tz import gettz
        from datetime import datetime

    .. doctest:: tzfile

        >>> NYC = gettz('America/New_York')
        >>> NYC
        tzfile('/usr/share/zoneinfo/America/New_York')

        >>> print(datetime(2016, 1, 3, tzinfo=NYC))     # EST
        2016-01-03 00:00:00-05:00

        >>> print(datetime(2016, 7, 7, tzinfo=NYC))     # EDT
        2016-07-07 00:00:00-04:00


    The ``tzfile`` structure contains a fully history of the time zone,
    so historical dates will also have the right offsets. For example, before
    the adoption of the UTC standards, New York used local solar  mean time:

    .. doctest:: tzfile

       >>> print(datetime(1901, 4, 12, tzinfo=NYC))    # LMT
       1901-04-12 00:00:00-04:56

    And during World War II, New York was on "Eastern War Time", which was a
    state of permanent daylight saving time:

    .. doctest:: tzfile

        >>> print(datetime(1944, 2, 7, tzinfo=NYC))    # EWT
        1944-02-07 00:00:00-04:00

    Nc              	      s   t t|   d}t|tr2|| _t|d}d}n.|d k	rB|| _nt|drV|j| _n
t	|| _|d k	r|stt
|}|}| |}W 5 Q R X | | d S )NFrbTr?   )rF   r~   rA   r!   r   	_filenameopenhasattrr?   rC   _nullcontext_read_tzfile_set_tzdata)r   fileobjfilenameZfile_opened_hereZfile_streamtzobjrR   r   r   rA     s"    




ztzfile.__init__c                 C   s&   t jD ]}t| d| t|| qdS )z= Set the time zone data of this object from a _tzfile object _N)rr   r{   rg   rZ   )r   r   rh   r   r   r   r     s    
ztzfile._set_tzdatac              	      s  t   |d dkr td|d td|d\}}}}}}|rnttd| ||d  _ng  _|rtd| || _ng  _g }t	|D ]}	|
td	|d
 q|| }
|r||d tj |rtd| ||}|rtd| ||}g  _t	|D ]}	||	 \}}}t|}t }||_td|_tj|d|_||_|
||
d| |_||	ko||	 dk|_||	ko||	 dk|_ j
| q, fdd jD  _d  _d  _d  _ jr js jd   _ _nt	|d ddD ]T}	 j|	 } jsJ|jsJ| _n js`|jr`| _ jr$ jr$ qq$ jr js j _ jD ]}|js| _ qq jd  _d }d }d }d }g  _t  jD ]\}	}|j}d}|d k	r4|jr4|s|| }|s"|r"|}tj|d|_|}|| }|}|d k	rd||krd|j|krd|}|j}|}|} j
 j|	 |  qt! j _t! j _t! j _ S )N   ZTZifzmagic not found   z>6l   z>%dlz>%dBz>lbb      z>%dbr   r6    c                    s   g | ]} j | qS r   )rv   ).0idxoutr   r   
<listcomp>s  s     z'tzfile._read_tzfile.<locals>.<listcomp>r   )"rr   readdecode
ValueErrorstructunpacklistrt   ru   rangerj   seekosSEEK_CURrv   r>   r^   r@   r<   r=   rd   r_   r`   findra   rb   rc   rw   rx   ry   rz   rs   	enumeraterP   )r   r   Z
ttisgmtcntZ
ttisstdcntZleapcntZtimecntZtypecntZcharcntZttinfoira   rb   rc   gmtoffr`   ZabbrindttiZlastdstZ
lastoffsetZlastdstoffsetZlastbaseoffsetr@   rd   Z
baseoffsetZ
adjustmentr   r   r   r     s    

	







	
ztzfile._read_tzfileFc                 C   s6   | j s
d S t|}|r| jn| j }t||}|d S )Nr   )_trans_listrU   Z_trans_list_utcbisectbisect_right)r   r   in_utcrX   rs   r   r   r   r   _find_last_transition  s    ztzfile._find_last_transitionc                 C   s8   |d ks|d t | jkr | jS |dk r.| jS | j| S )Nr   r   )lenr   _ttinfo_stdZ_ttinfo_before
_trans_idx)r   r   r   r   r   _get_ttinfo  s
    ztzfile._get_ttinfoc                 C   s   |  |}| |S r   )_resolve_ambiguous_timer   )r   r   r   r   r   r   _find_ttinfo  s    
ztzfile._find_ttinfoc                 C   sn   t |tjstd|j| k	r&td| j|dd}| |}|tj|jd }| j	||d}t
|t|dS )a  
        The ``tzfile`` implementation of :py:func:`datetime.tzinfo.fromutc`.

        :param dt:
            A :py:class:`datetime.datetime` object.

        :raises TypeError:
            Raised if ``dt`` is not a :py:class:`datetime.datetime` object.

        :raises ValueError:
            Raised if this is called with a ``dt`` which does not have this
            ``tzinfo`` attached.

        :return:
            Returns a :py:class:`datetime.datetime` object representing the
            wall time in ``self``'s time zone.
        z&fromutc() requires a datetime argumentzdt.tzinfo is not selfT)r   r6   )r   rY   )r!   r<   r:   tzinfor   r   r   r=   r@   r   r	   rD   )r   r   r   r   Zdt_outrY   r   r   r   r      s    

ztzfile.fromutcc                 C   sd   |dkr|  |}t|}| |}|dks4|dkr8dS | |d j|j }| j| }||| k S )r   Nr   Fr   )r   rU   r   r@   r   )r   r   r   rX   r   Zodttr   r   r   r     s    


ztzfile.is_ambiguousc                 C   sF   |  |}| |}|d ks$|dkr(|S t| o:| ||}|| S )Nr   )r   r[   rD   r   )r   r   r   r[   Z
idx_offsetr   r   r   r   (  s    

ztzfile._resolve_ambiguous_timec                 C   s"   |d krd S | j stS | |jS r   )r   r   r   r_   r   r   r   r   r   5  s
    ztzfile.utcoffsetc                 C   s0   |d krd S | j stS | |}|js*tS |jS r   )Z_ttinfo_dstr   r   r`   rd   )r   r   r   r   r   r   r   >  s    
z
tzfile.dstc                 C   s   | j r|d krd S | |jS r   )r   r   ra   r   r   r   r   r   N  s    ztzfile.tznamec                 C   s2   t |tstS | j|jko0| j|jko0| j|jkS r   )r!   r~   r#   r   r   Z_ttinfo_listr%   r   r   r   r'   T  s    


ztzfile.__eq__c                 C   s
   | |k S r   r   r%   r   r   r   r(   ]  s    ztzfile.__ne__c                 C   s   d| j jt| jf S Nri   )r+   r,   rC   r   r-   r   r   r   r.   `  s    ztzfile.__repr__c                 C   s
   |  d S r   )__reduce_ex__r-   r   r   r   r4   c  s    ztzfile.__reduce__c                 C   s   | j d | jf| jfS r   )r+   r   __dict__)r   protocolr   r   r   r   f  s    ztzfile.__reduce_ex__)N)F)N)r,   r/   r0   r1   rA   r   r   r   r   r   r    r   r   r   r   r   r   r'   r2   r(   r.   r4   r   r]   r   r   rR   r   r~     s*   G a
$
	
r~   c                   @   s6   e Zd ZdZdddZdd Zdd Zed	d
 ZdS )tzrangea[  
    The ``tzrange`` object is a time zone specified by a set of offsets and
    abbreviations, equivalent to the way the ``TZ`` variable can be specified
    in POSIX-like systems, but using Python delta objects to specify DST
    start, end and offsets.

    :param stdabbr:
        The abbreviation for standard time (e.g. ``'EST'``).

    :param stdoffset:
        An integer or :class:`datetime.timedelta` object or equivalent
        specifying the base offset from UTC.

        If unspecified, +00:00 is used.

    :param dstabbr:
        The abbreviation for DST / "Summer" time (e.g. ``'EDT'``).

        If specified, with no other DST information, DST is assumed to occur
        and the default behavior or ``dstoffset``, ``start`` and ``end`` is
        used. If unspecified and no other DST information is specified, it
        is assumed that this zone has no DST.

        If this is unspecified and other DST information is *is* specified,
        DST occurs in the zone but the time zone abbreviation is left
        unchanged.

    :param dstoffset:
        A an integer or :class:`datetime.timedelta` object or equivalent
        specifying the UTC offset during DST. If unspecified and any other DST
        information is specified, it is assumed to be the STD offset +1 hour.

    :param start:
        A :class:`relativedelta.relativedelta` object or equivalent specifying
        the time and time of year that daylight savings time starts. To
        specify, for example, that DST starts at 2AM on the 2nd Sunday in
        March, pass:

            ``relativedelta(hours=2, month=3, day=1, weekday=SU(+2))``

        If unspecified and any other DST information is specified, the default
        value is 2 AM on the first Sunday in April.

    :param end:
        A :class:`relativedelta.relativedelta` object or equivalent
        representing the time and time of year that daylight savings time
        ends, with the same specification method as in ``start``. One note is
        that this should point to the first time in the *standard* zone, so if
        a transition occurs at 2AM in the DST zone and the clocks are set back
        1 hour to 1AM, set the ``hours`` parameter to +1.


    **Examples:**

    .. testsetup:: tzrange

        from dateutil.tz import tzrange, tzstr

    .. doctest:: tzrange

        >>> tzstr('EST5EDT') == tzrange("EST", -18000, "EDT")
        True

        >>> from dateutil.relativedelta import *
        >>> range1 = tzrange("EST", -18000, "EDT")
        >>> range2 = tzrange("EST", -18000, "EDT", -14400,
        ...                  relativedelta(hours=+2, month=4, day=1,
        ...                                weekday=SU(+1)),
        ...                  relativedelta(hours=+1, month=10, day=31,
        ...                                weekday=SU(-1)))
        >>> tzstr('EST5EDT') == range1 == range2
        True

    Nc              	   C   s@  ddl ma || _|| _z| }W n ttfk
r<   Y nX z| }W n ttfk
rb   Y nX |d k	r|tj|d| _	nt
| _	|d k	rtj|d| _n(|r|d k	r| j	tjdd | _nt
| _|r|d krtjdddtdd| _n|| _|r|d krtjdd	d
tdd| _n|| _| j| j	 | _t| j| _d S )Nr   relativedeltar6   r   hours   r   )r   monthdayweekday
      r   )dateutilr   	_std_abbr	_dst_abbrr9   r:   r;   r<   r=   rI   r   rL   SU_start_delta
_end_delta_dst_base_offset_rN   hasdst)r   stdabbr	stdoffsetdstabbrrd   startendr   r   r   rA     sJ       
   
ztzrange.__init__c                 C   s4   | j s
dS t|dd}|| j }|| j }||fS )a  
        For a given year, get the DST on and off transition times, expressed
        always on the standard time side. For zones with no transitions, this
        function returns ``None``.

        :param year:
            The year whose transitions you would like to query.

        :return:
            Returns a :class:`tuple` of :class:`datetime.datetime` objects,
            ``(dston, dstoff)`` for zones with an annual DST transition, or
            ``None`` for fixed offset zones.
        Nr   )r   r<   r   r   )r   yearZ	base_yearr   r   r   r   r   transitions  s    

ztzrange.transitionsc                 C   sV   t |tstS | j|jkoT| j|jkoT| j|jkoT| j|jkoT| j|jkoT| j|jkS r   )	r!   r   r#   r   r   rI   rL   r   r   r%   r   r   r   r'     s    





ztzrange.__eq__c                 C   s   | j S r   )r   r-   r   r   r   _dst_base_offset  s    ztzrange._dst_base_offset)NNNNN)	r,   r/   r0   r1   rA   r   r'   propertyr   r   r   r   r   r   j  s   J       
/r   c                   @   s,   e Zd ZdZdddZdddZdd	 Zd
S )tzstra  
    ``tzstr`` objects are time zone objects specified by a time-zone string as
    it would be passed to a ``TZ`` variable on POSIX-style systems (see
    the `GNU C Library: TZ Variable`_ for more details).

    There is one notable exception, which is that POSIX-style time zones use an
    inverted offset format, so normally ``GMT+3`` would be parsed as an offset
    3 hours *behind* GMT. The ``tzstr`` time zone object will parse this as an
    offset 3 hours *ahead* of GMT. If you would like to maintain the POSIX
    behavior, pass a ``True`` value to ``posix_offset``.

    The :class:`tzrange` object provides the same functionality, but is
    specified using :class:`relativedelta.relativedelta` objects. rather than
    strings.

    :param s:
        A time zone string in ``TZ`` variable format. This can be a
        :class:`bytes` (2.x: :class:`str`), :class:`str` (2.x:
        :class:`unicode`) or a stream emitting unicode characters
        (e.g. :class:`StringIO`).

    :param posix_offset:
        Optional. If set to ``True``, interpret strings such as ``GMT+3`` or
        ``UTC+3`` as being 3 hours *behind* UTC rather than ahead, per the
        POSIX standard.

    .. caution::

        Prior to version 2.7.0, this function also supported time zones
        in the format:

            * ``EST5EDT,4,0,6,7200,10,0,26,7200,3600``
            * ``EST5EDT,4,1,0,7200,10,-1,0,7200,3600``

        This format is non-standard and has been deprecated; this function
        will raise a :class:`DeprecatedTZFormatWarning` until
        support is removed in a future version.

    .. _`GNU C Library: TZ Variable`:
        https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html
    Fc              	   C   s   ddl ma || _t|}|d ks*|jr2td|jdkrN|sN| jd9  _t	j
| |j|j|j|jddd |jsd | _d | _n&| |j| _| jr| j|jdd	| _t| j| _d S )
Nr   )_parserzunknown string formatr\   r   r   F)r   r   r   )isend)Zdateutil.parserr   parser_sZ_parsetzZany_unused_tokensr   r   r   r   rA   r   rd   r   r   _deltar   r   rN   r   )r   sZposix_offsetresr   r   r   rA   7  s(    
  ztzstr.__init__r   c                 C   s:  ddl m} i }|jd k	rr|j|d< |jd k	r`||j|j|d< |jdkrVd|d< qpd|d< q|jr|j|d< n*|jd k	r|j|d< n|jd k	r|j|d	< |s|sd
|d< d|d< |d|d< nd|d< d|d< |d|d< |j	d k	r|j	|d< nd|d< |r.| j
| j }|d  |j|jd  8  < |jf |S )Nr   r   r   r   r   r   r   ZyeardayZ	nlyeardayr   r   r   r7   i   iQ )r   r   r   r   weekr   ZydayZjydayr   rG   rL   rI   r7   days)r   xr   r   r}   r_   r   r   r   r   W  s<    









ztzstr._deltac                 C   s   d| j jt| jf S r   r+   r,   rC   r   r-   r   r   r   r.     s    ztzstr.__repr__N)F)r   )r,   r/   r0   r1   rA   r   r.   r   r   r   r   r     s   )
 
)r   c                   @   s   e Zd ZdddZdS )_tzicalvtzcompNc                 C   s@   t j|d| _t j|d| _| j| j | _|| _|| _|| _d S r5   )r<   r=   tzoffsetfrom
tzoffsettotzoffsetdiffr`   r   rrule)r   r   r   r`   r   r   r   r   r   rA     s    z_tzicalvtzcomp.__init__)NN)r,   r/   r0   rA   r   r   r   r   r     s      r   c                       sZ   e Zd Zg f fdd	Zdd Zdd Zdd Zd	d
 Zedd Z	dd Z
ejZ  ZS )
_tzicalvtzc                    s4   t t|   || _|| _g | _g | _t | _	d S r   )
rF   r   rA   _tzid_comps
_cachedate
_cachecompr   allocate_lock_cache_lock)r   tzidcompsrR   r   r   rA     s    z_tzicalvtz.__init__c              
   C   s4  t | jdkr| jd S |jd d}z<| j, | j| j|| |f W  5 Q R  W S Q R X W n tk
rt   Y nX d }d }| jD ](}| 	||}|r|r||k r|}|}q|s| jD ]}|j
s|} qq|d }| jP | jd|| |f | jd| t | jdkr&| j  | j  W 5 Q R X |S )Nr   r   r   r   )r   r   replacer   r   r   indexr[   r   _find_compdtr`   insertpop)r   r   Z
lastcompdtZlastcompcompcompdtr   r   r   
_find_comp  s<    




z_tzicalvtz._find_compc                 C   s2   |j tk r| |r||j 8 }|jj|dd}|S )NT)inc)r   r   r[   r   Zbefore)r   r   r   r   r   r   r   r     s    
z_tzicalvtz._find_compdtc                 C   s   |d krd S |  |jS r   )r   r   r   r   r   r   r     s    z_tzicalvtz.utcoffsetc                 C   s   |  |}|jr|jS tS d S r   )r   r`   r   r   )r   r   r   r   r   r   r     s    
z_tzicalvtz.dstc                 C   s   |  |jS r   )r   r   r   r   r   r   r     s    z_tzicalvtz.tznamec                 C   s   dt | j S )Nz<tzicalvtz %s>)rC   r   r-   r   r   r   r.     s    z_tzicalvtz.__repr__)r,   r/   r0   rA   r   r   r   r   r   r   r.   r3   r4   r]   r   r   rR   r   r     s   	-
r   c                   @   sB   e Zd ZdZdd Zdd ZdddZd	d
 Zdd Zdd Z	dS )tzicala[  
    This object is designed to parse an iCalendar-style ``VTIMEZONE`` structure
    as set out in `RFC 5545`_ Section 4.6.5 into one or more `tzinfo` objects.

    :param `fileobj`:
        A file or stream in iCalendar format, which should be UTF-8 encoded
        with CRLF endings.

    .. _`RFC 5545`: https://tools.ietf.org/html/rfc5545
    c              	   C   sj   ddl ma t|tr(|| _t|d}nt|dt|| _t|}i | _	|}| 
|  W 5 Q R X d S )Nr   )r   rr?   )r   r   r!   r   r   r   rZ   rC   r   _vtz
_parse_rfcr   )r   r   Zfobjr   r   r   rA     s    
ztzical.__init__c                 C   s   t | j S )z?
        Retrieves the available time zones as a list.
        )r   r   keysr-   r   r   r   r     s    ztzical.keysNc                 C   sP   |dkrDt | jdkr tdnt | jdkr6tdtt| j}| j|S )a  
        Retrieve a :py:class:`datetime.tzinfo` object by its ``tzid``.

        :param tzid:
            If there is exactly one time zone available, omitting ``tzid``
            or passing :py:const:`None` value returns it. Otherwise a valid
            key (which can be retrieved from :func:`keys`) is required.

        :raises ValueError:
            Raised if ``tzid`` is not specified but there are either more
            or fewer than 1 zone defined.

        :returns:
            Returns either a :py:class:`datetime.tzinfo` object representing
            the relevant time zone or :py:const:`None` if the ``tzid`` was
            not found.
        Nr   zno timezones definedr   z more than one timezone available)r   r   r   nextiterr|   )r   r   r   r   r   r|     s    
z
tzical.getc                 C   s   |  }|std|d dkr>d|d dk }|dd  }nd}t|dkrzt|d d d	 t|dd  d
  | S t|dkrt|d d d	 t|dd d
  t|dd   | S td| d S )Nzempty offsetr   )+-)r   r   r   r   r   r   i  <   r   zinvalid offset: )stripr   r   rD   )r   r   signalr   r   r   _parse_offset"  s    ,<ztzical._parse_offsetc                 C   sb  |  }|stdd}|t|k r~||  }|s<||= q|dkrt|d dkrt||d   |dd  7  < ||= q|d7 }qd }g }d}d }|D ]}|sq|dd\}	}
|	d}|std|d  }	|dd  }|r@|	d	kr|
d
krntd|
 |
}d}d }d }g }d }q\|	dkr|
dkrv|rDtd| |sRtd|s`tdt||| j|< d}n|
|kr|std|d krtd|d krtdd }|rtj	d
|dddd}t|||dk||}|| d }ntd|
 q\|r |	dkrN|D ] }|dkrd| }t|q|| d}n|	dkrd|| n|	dkr|rtd|	|d f | |
}nj|	dkr|rtd|d  | |
}n>|	d kr|rtd!|d  |
}n|	d"krntd#|	 n>|	d$kr&|r td%|d  |
}n|	d&kr2ntd#|	 q|	d	kr|
dkrd }g }d}qd S )'Nzempty stringr    r   F:;zempty property nameZBEGIN)ZSTANDARDDAYLIGHTzunknown component: ZENDZ	VTIMEZONEzcomponent not closed: zmandatory TZID not foundz at least one component is neededzmandatory DTSTART not foundz mandatory TZOFFSETFROM not found
T)
compatibleZignoretzcacher  zinvalid component end: ZDTSTARTzVALUE=DATE-TIMEz(Unsupported DTSTART param in VTIMEZONE: )ZRRULEZRDATEZEXRULEZEXDATEZTZOFFSETFROMzunsupported %s parm: %s Z
TZOFFSETTOzunsupported TZOFFSETTO parm: ZTZNAMEzunsupported TZNAME parm: COMMENTzunsupported property: ZTZIDzunsupported TZID parm: )ZTZURLzLAST-MODIFIEDr  )
splitlinesr   r   rstripsplitupperr   r   r   Zrrulestrrk   r   rj   r  )r   r   linesr   liner   r   Zinvtzcomptyper?   rm   ZparmsZfounddtstartr   r   Z
rrulelinesr   rrr   Zparmmsgr   r   r   r   2  s    








 













ztzical._parse_rfcc                 C   s   d| j jt| jf S r   r   r-   r   r   r   r.     s    ztzical.__repr__)N)
r,   r/   r0   r1   rA   r   r|   r  r   r.   r   r   r   r   r     s   

}r   win32z/etc/localtimerV   z/usr/share/zoneinfoz/usr/lib/zoneinfoz/usr/share/lib/zoneinfoz/etc/zoneinfoc                     s2   t f td k	r tf7  G  fdddt} |  S )Nc                       sD   e Zd ZdZdd Zd fdd	Zdd Zd	d
 ZedddZ	dS )z__get_gettz.<locals>.GettzFunca	  
        Retrieve a time zone object from a string representation

        This function is intended to retrieve the :py:class:`tzinfo` subclass
        that best represents the time zone that would be used if a POSIX
        `TZ variable`_ were set to the same value.

        If no argument or an empty string is passed to ``gettz``, local time
        is returned:

        .. code-block:: python3

            >>> gettz()
            tzfile('/etc/localtime')

        This function is also the preferred way to map IANA tz database keys
        to :class:`tzfile` objects:

        .. code-block:: python3

            >>> gettz('Pacific/Kiritimati')
            tzfile('/usr/share/zoneinfo/Pacific/Kiritimati')

        On Windows, the standard is extended to include the Windows-specific
        zone names provided by the operating system:

        .. code-block:: python3

            >>> gettz('Egypt Standard Time')
            tzwin('Egypt Standard Time')

        Passing a GNU ``TZ`` style string time zone specification returns a
        :class:`tzstr` object:

        .. code-block:: python3

            >>> gettz('AEST-10AEDT-11,M10.1.0/2,M4.1.0/3')
            tzstr('AEST-10AEDT-11,M10.1.0/2,M4.1.0/3')

        :param name:
            A time zone name (IANA, or, on Windows, Windows keys), location of
            a ``tzfile(5)`` zoneinfo file or ``TZ`` variable style time zone
            specifier. An empty string, no argument or ``None`` is interpreted
            as local time.

        :return:
            Returns an instance of one of ``dateutil``'s :py:class:`tzinfo`
            subclasses.

        .. versionchanged:: 2.7.0

            After version 2.7.0, any two calls to ``gettz`` using the same
            input strings will return the same object:

            .. code-block:: python3

                >>> tz.gettz('America/Chicago') is tz.gettz('America/Chicago')
                True

            In addition to improving performance, this ensures that
            `"same zone" semantics`_ are used for datetimes in the same zone.


        .. _`TZ variable`:
            https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html

        .. _`"same zone" semantics`:
            https://blog.ganssle.io/articles/2018/02/aware-datetime-arithmetic.html
        c                 S   s&   t  | _d| _t | _t | _d S )Nr   )	weakrefWeakValueDictionary_GettzFunc__instances_GettzFunc__strong_cache_sizer   _GettzFunc__strong_cacher   r   r   r-   r   r   r   rA   	  s    
z'__get_gettz.<locals>.GettzFunc.__init__Nc              
      s   | j  | j|d }|d kr`| j|d}|d ksPt| sP|d ksP|| j|< n|W  5 Q R  S | j||| j|< t| j| jkr| jj	dd W 5 Q R X |S )N)r?   Flast)
r   r  r|   nocacher!   r  r   r   r  popitem)r   r?   rvZtzlocal_classesr   r   __call__  s    	z'__get_gettz.<locals>.GettzFunc.__call__c              	   S   s:   | j * || _t| j|kr,| jjdd qW 5 Q R X d S )NFr  )r   r  r   r  r  )r   sizer   r   r   set_cache_size+  s    z-__get_gettz.<locals>.GettzFunc.set_cache_sizec              	   S   s*   | j  t | _| j  W 5 Q R X d S r   )r   r  r  r  r  clearr-   r   r   r   cache_clear1  s    
z*__get_gettz.<locals>.GettzFunc.cache_clearc           	      S   s  d}| s,zt jd } W n tk
r*   Y nX | dks<| dkrtD ]x}t j|s~|}tD ]"}t j||}t j|rX q~qXq@t j|r@zt	|}W  qW q@ t
ttfk
r   Y q@X q@t }nz| dr| dd } W nH tk
r& } z(t| trd}tt|| n W 5 d}~X Y nX t j| rVt j| rNt	| }nd}n8tD ]r}t j|| }t j|s|dd}t j|sqZzt	|}W  qW n t
ttfk
r   Y nX qZd}tdk	rzt| }W n ttfk
r   d}Y nX |s&dd	lm} | | }|s| D ]:}|d
kr0zt| }W n tk
r`   Y nX  qq0| dkr|t}n| tjkrt }|S )zA non-cached version of gettzNZTZr  r   z'gettz argument should be str, not bytesr  r   r   )get_zonefile_instance
0123456789r   )r   environKeyErrorTZFILESpathisabsTZPATHSrk   isfiler~   IOErrorOSErrorr   rE   
startswithr:   r!   bytessix
raise_fromr   r   WindowsErrorUnicodeEncodeErrorZdateutil.zoneinfor'  r|   r   r   rG   r   )	r?   tzfilepathr   r,  eZnew_msgr'  cr   r   r   r  6  s    









z&__get_gettz.<locals>.GettzFunc.nocache)N)N)
r,   r/   r0   r1   rA   r"  r$  r&  staticmethodr  r   r!  r   r   	GettzFunc  s   Er=  )rE   r   r3   )r=  r   r!  r   __get_gettz  s    
 Jr>  c                 C   sX   |dkr | j dkrtd| j }| jdd} | j|dt|}|jdd}| |kS )a  
    Given a datetime and a time zone, determine whether or not a given datetime
    would fall in a gap.

    :param dt:
        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz``
        is provided.)

    :param tz:
        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If
        ``None`` or not provided, the datetime's own time zone will be used.

    :return:
        Returns a boolean value whether or not the "wall time" exists in
        ``tz``.

    .. versionadded:: 2.7.0
    N,Datetime is naive and no time zone provided.r   )r   r   r   
astimezoner   )r   r8  Zdt_rtr   r   r   datetime_exists  s    
rA  c                 C   s   |dkr | j dkrtd| j }t|dd}|dk	rVz|| W S  tk
rT   Y nX | j|d} t| dd}t| dd}| | k}| | k}|o| S )a\  
    Given a datetime and a time zone, determine whether or not a given datetime
    is ambiguous (i.e if there are two times differentiated only by their DST
    status).

    :param dt:
        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz``
        is provided.)

    :param tz:
        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If
        ``None`` or not provided, the datetime's own time zone will be used.

    :return:
        Returns a boolean value whether or not the "wall time" is ambiguous in
        ``tz``.

    .. versionadded:: 2.6.0
    Nr?  r   r   r   r   r   )	r   r   rZ   r   	Exceptionr   r	   r   r   )r   r8  Zis_ambiguous_fnZwall_0Zwall_1Zsame_offsetZsame_dstr   r   r   datetime_ambiguous  s     
rC  c                 C   sJ   | j dk	rFt| sF| tjdd  }| tjdd  }| || 7 } | S )aZ  
    Given a datetime that may be imaginary, return an existing datetime.

    This function assumes that an imaginary datetime represents what the
    wall time would be in a zone had the offset transition not occurred, so
    it will always fall forward by the transition's change in offset.

    .. doctest::

        >>> from dateutil import tz
        >>> from datetime import datetime
        >>> NYC = tz.gettz('America/New_York')
        >>> print(tz.resolve_imaginary(datetime(2017, 3, 12, 2, 30, tzinfo=NYC)))
        2017-03-12 03:30:00-04:00

        >>> KIR = tz.gettz('Pacific/Kiritimati')
        >>> print(tz.resolve_imaginary(datetime(1995, 1, 1, 12, 30, tzinfo=KIR)))
        1995-01-02 12:30:00+14:00

    As a note, :func:`datetime.astimezone` is guaranteed to produce a valid,
    existing datetime, so a round-trip to and from UTC is sufficient to get
    an extant datetime, however, this generally "falls back" to an earlier time
    rather than falling forward to the STD side (though no guarantees are made
    about this behavior).

    :param dt:
        A :class:`datetime.datetime` which may or may not exist.

    :return:
        Returns an existing :class:`datetime.datetime`. If ``dt`` was not
        imaginary, the datetime returned is guaranteed to be the same object
        passed to the function.

    .. versionadded:: 2.7.0
    Nr   r   )r   rA  r<   r=   r   )r   Zcurr_offset
old_offsetr   r   r   resolve_imaginary  s
    $rE  c                 C   s   | j ddt  S )z
    Convert a :class:`datetime.datetime` object to an epoch timestamp in
    seconds since January 1, 1970, ignoring the time zone.
    Nr   )r   EPOCHr9   )r   r   r   r   rU     s    rU   )   r   c                 C   s   | S r   r   )second_offsetr   r   r   r>     s    r>   c                 C   s   | }d| d d  }|S )Nr     r   )rH  rD  Zcalculated_offsetr   r   r   r>     s    )nullcontextc                   @   s(   e Zd ZdZdd Zdd Zdd ZdS )	r   zj
        Class for wrapping contexts so that they are passed through in a
        with statement.
        c                 C   s
   || _ d S r   context)r   rL  r   r   r   rA   0  s    z_nullcontext.__init__c                 C   s   | j S r   rK  r-   r   r   r   	__enter__3  s    z_nullcontext.__enter__c                  O   s   d S r   r   )argsr}   r   r   r   __exit__6  s    z_nullcontext.__exit__N)r,   r/   r0   r1   rA   rM  rO  r   r   r   r   r   +  s   r   )N)N)Ar1   r<   r   rG   sysr   r   r  collectionsr   r4  r   Z	six.movesr   Z_commonr   r   r   r	   r
   Z
_factoriesr   r   r   winr   r   ImportErrorwarningsr   r=   r   utcfromtimestamprF  	toordinalZEPOCHORDINALadd_metaclassr   r   r   r"   rE   r3   r^   rr   r~   r   r   r   r   r   platformr+  r.  r>  ZgettzrA  rC  rE  rU   version_infor>   
contextlibrJ  r   r   r   r   r   <module>   s   
WD-   k #wV O R
"
..

U
    ^2                     @   s   d Z ddlZddlZddlmZ ddlmZ zddlZddlmZ W n e	k
r`   e
dY nX ddlmZ d	d
dgZedZdZdZdZdd Ze ZG dd deZG dd deZG dd	 d	eZG dd
 d
eZdd Zdd ZdS )z
This module provides an interface to the native time zone data on Windows,
including :py:class:`datetime.tzinfo` implementations.

Attempting to import this module on a non-Windows platform will raise an
:py:obj:`ImportError`.
    N)winreg)	text_type)wintypesz#Running tzwin on non-Windows system   )tzrangebasetzwin
tzwinlocaltzres   z7SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zonesz4SOFTWARE\Microsoft\Windows\CurrentVersion\Time Zonesz4SYSTEM\CurrentControlSet\Control\TimeZoneInformationc                  C   sL   t d t j} zt | t  t}W n tk
r>   t}Y nX |   |S N)r   ConnectRegistryHKEY_LOCAL_MACHINEOpenKeyTZKEYNAMENTCloseWindowsErrorTZKEYNAME9X)handle	TZKEYNAME r   PC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\tz\win.py_settzkeyname"   s    
r   c                   @   s6   e Zd ZdZeejZd
ddZ	dd Z
dd Zd	S )r	   z}
    Class for accessing ``tzres.dll``, which contains timezone name related
    resources.

    .. versionadded:: 2.5.0
    	tzres.dllc                 C   s@   t d}tjtjtjt jf|j_|j| _t || _	|| _
d S )Nuser32)ctypesWinDLLr   	HINSTANCEUINTLPWSTRc_intLoadStringWargtypes_tzres	tzres_loc)selfr#   r   r   r   r   __init__9   s    
ztzres.__init__c                 C   s<   |   }tt|tj}| | jj||d}|d| S )a  
        Load a timezone name from a DLL offset (integer).

        >>> from dateutil.tzwin import tzres
        >>> tzr = tzres()
        >>> print(tzr.load_name(112))
        'Eastern Standard Time'

        :param offset:
            A positive integer value referring to a string from the tzres dll.

        .. note::

            Offsets found in the registry are generally of the form
            ``@tzres.dll,-114``. The offset in this case is 114, not -114.

        r   N)	p_wcharr   castbyrefr   r   r    r"   _handle)r$   offsetresourceZlpBufferZncharr   r   r   	load_nameG   s    ztzres.load_namec                 C   sH   | ds|S |d}zt|d }W n   tdY nX | |S )a  
        Parse strings as returned from the Windows registry into the time zone
        name as defined in the registry.

        >>> from dateutil.tzwin import tzres
        >>> tzr = tzres()
        >>> print(tzr.name_from_string('@tzres.dll,-251'))
        'Dateline Daylight Time'
        >>> print(tzr.name_from_string('Eastern Standard Time'))
        'Eastern Standard Time'

        :param tzname_str:
            A timezone name string as returned from a Windows registry key.

        :return:
            Returns the localized timezone string from tzres.dll if the string
            is of the form `@tzres.dll,-offset`, else returns the input string.
        @z,-r   zMalformed timezone string.)
startswithsplitint
ValueErrorr,   )r$   Z
tzname_strZ	name_spltr*   r   r   r   name_from_string^   s    

ztzres.name_from_stringN)r   )__name__
__module____qualname____doc__r   POINTERr   WCHARr&   r%   r,   r2   r   r   r   r   r	   0   s
   
c                   @   sP   e Zd ZdZdd Zdd Zedd Zdd	 Zd
d Z	dd Z
edd ZdS )	tzwinbasezBtzinfo class based on win32's timezones available in the registry.c                 C   s   t dd S )Nz#tzwinbase is an abstract base class)NotImplementedErrorr$   r   r   r   r%      s    ztzwinbase.__init__c                 C   s   t |tstS | j|jko| j|jko| j|jko| j|jko| j|jko| j|jko| j	|j	ko| j
|j
ko| j|jko| j|jko| j|jko| j|jkS r   )
isinstancer9   NotImplemented_std_offset_dst_offset_stddayofweek_dstdayofweek_stdweeknumber_dstweeknumber_stdhour_dsthour
_stdminute
_dstminute	_std_abbr	_dst_abbr)r$   otherr   r   r   __eq__   s2    








	



ztzwinbase.__eq__c               
      sV   t dt j>} t | t&  fddtt  d D }W 5 Q R X W 5 Q R X |S )z4Return a list of all time zones known to the system.Nc                    s   g | ]}t  |qS r   )r   EnumKey).0itzkeyr   r   
<listcomp>   s   z"tzwinbase.list.<locals>.<listcomp>r   )r   r   r   r   r   rangeQueryInfoKey)r   resultr   rO   r   list   s    
ztzwinbase.listc                 C   s   | j S )z;
        Return the display name of the time zone.
        )_displayr;   r   r   r   display   s    ztzwinbase.displayc                 C   sT   | j s
dS t|| j| j| j| j| j}t|| j| j| j	| j
| j}|| j8 }||fS )a  
        For a given year, get the DST on and off transition times, expressed
        always on the standard time side. For zones with no transitions, this
        function returns ``None``.

        :param year:
            The year whose transitions you would like to query.

        :return:
            Returns a :class:`tuple` of :class:`datetime.datetime` objects,
            ``(dston, dstoff)`` for zones with an annual DST transition, or
            ``None`` for fixed offset zones.
        N)hasdstpicknthweekday	_dstmonthrA   rE   rG   rC   	_stdmonthr@   rD   rF   rB   _dst_base_offset)r$   yearZdstonZdstoffr   r   r   transitions   s      
ztzwinbase.transitionsc                 C   s
   | j dkS )Nr   )rZ   r;   r   r   r   _get_hasdst   s    ztzwinbase._get_hasdstc                 C   s   | j S r   )_dst_base_offset_r;   r   r   r   r\      s    ztzwinbase._dst_base_offsetN)r3   r4   r5   r6   r%   rK   staticmethodrU   rW   r^   r_   propertyr\   r   r   r   r   r9   }   s   
r9   c                   @   s(   e Zd ZdZdd Zdd Zdd ZdS )	r   a  
    Time zone object created from the zone info in the Windows registry

    These are similar to :py:class:`dateutil.tz.tzrange` objects in that
    the time zone data is provided in the format of a single offset rule
    for either 0 or 2 time zone transitions per year.

    :param: name
        The name of a Windows time zone key, e.g. "Eastern Standard Time".
        The full list of keys can be retrieved with :func:`tzwin.list`.
    c           	   
   C   s  || _ td tj8}tdjt|d}t||}t|}W 5 Q R X W 5 Q R X |d | _	|d | _
|d | _td|d }|d  |d	  }||d
  }tj|d| _tj|d| _|dd \| _| _| _| _| _|dd \| _| _| _| _| _| j| j | _|  | _d S )Nz{kn}\{name})knnameZStdZDltDisplayz=3l16hZTZIr   r      minutes   	         )_namer   r   r   r   formatr   r   valuestodictrH   rI   rV   structunpackdatetime	timedeltar>   r?   r[   r@   rB   rD   rF   rZ   rA   rC   rE   rG   r`   r_   rX   )	r$   rd   r   	tzkeynamerP   keydicttup	stdoffset	dstoffsetr   r   r   r%      s6    




ztzwin.__init__c                 C   s   dt | j S )Nz	tzwin(%s))reprrm   r;   r   r   r   __repr__   s    ztzwin.__repr__c                 C   s   | j | jffS r   )	__class__rm   r;   r   r   r   
__reduce__   s    ztzwin.__reduce__N)r3   r4   r5   r6   r%   rz   r|   r   r   r   r   r      s   %c                   @   s0   e Zd ZdZdd Zdd Zdd Zdd	 Zd
S )r   a,  
    Class representing the local time zone information in the Windows registry

    While :class:`dateutil.tz.tzlocal` makes system calls (via the :mod:`time`
    module) to retrieve time zone information, ``tzwinlocal`` retrieves the
    rules directly from the Windows registry and creates an object like
    :class:`dateutil.tz.tzwin`.

    Because Windows does not have an equivalent of :func:`time.tzset`, on
    Windows, :class:`dateutil.tz.tzlocal` instances will always reflect the
    time zone settings *at the time that the process was started*, meaning
    changes to the machine's time zone settings during the run of a program
    on Windows will **not** be reflected by :class:`dateutil.tz.tzlocal`.
    Because ``tzwinlocal`` reads the registry directly, it is unaffected by
    this issue.
    c           
   
   C   sn  t d t j}t |t}t|}W 5 Q R X |d | _|d | _zBtdj	t
| jd}t ||}t|}|d | _W 5 Q R X W n tk
r   d | _Y nX W 5 Q R X |d  |d  }||d  }tj|d	| _tj|d	| _td
|d }	|	dd \| _| _| _| _|	d | _td
|d }	|	dd \| _| _| _| _|	d | _| j| j | _|  | _d S )NZStandardNameZDaylightNamez	{kn}\{sn})rc   Zsnre   ZBiasZStandardBiasZDaylightBiasrg   z=8hZStandardStartr      r
   ZDaylightStart) r   r   r   r   TZLOCALKEYNAMEro   rH   rI   r   rn   r   rV   OSErrorrr   rs   r>   r?   rp   rq   r[   rB   rD   rF   r@   rZ   rC   rE   rG   rA   r`   r_   rX   )
r$   r   Z
tzlocalkeyru   rt   rP   Z_keydictrw   rx   rv   r   r   r   r%     sD    






ztzwinlocal.__init__c                 C   s   dS )Nztzwinlocal()r   r;   r   r   r   rz   B  s    ztzwinlocal.__repr__c                 C   s   dt | j S )Nztzwinlocal(%s))ry   rH   r;   r   r   r   __str__E  s    ztzwinlocal.__str__c                 C   s
   | j dfS )Nr   )r{   r;   r   r   r   r|   I  s    ztzwinlocal.__reduce__N)r3   r4   r5   r6   r%   rz   r   r|   r   r   r   r   r     s
   .c           	      C   sT   t  | |d||}|j||  d d d}||d t  }|j|krP|t8 }|S )z> dayofweek == 0 means Sunday, whichweek 5 means last instance r   r
   )day)rr   replace
isoweekdayONEWEEKmonth)	r]   r   Z	dayofweekhourminuteZ	whichweekfirstZ
weekdayonewdr   r   r   rY   M  s    
rY   c                 C   s   i }t | d }d}t|D ]v}t | |\}}}|t jksH|t jkrZ|d@ r|d }n2|t jkr|dr|pvt }|	|}|
d}|||< q|S )z0Convert a registry key's values to a dictionary.r   Nl        l        z@tzres )r   rS   rR   	EnumValue	REG_DWORDREG_DWORD_LITTLE_ENDIANREG_SZr.   r	   r2   rstrip)keyZdoutsizeZtz_resrN   Zkey_namevalueZdtyper   r   r   ro   [  s    






ro   )r6   rr   rp   Z	six.movesr   sixr   r   r   r1   ImportErrorZ_commonr   __all__rs   r   r   r   r~   r   r   objectr	   r9   r   r   rY   ro   r   r   r   r   <module>   s.   

MM9JU
    ^2                     @   s   d dl mZ d dlmZ d dlmZmZmZ ed ZddgZdd Z	e
edrZdd	dZnG d
d deZdddZdd ZG dd deZG dd deZdS )    )PY2wraps)datetime	timedeltatzinfotzname_in_python2enfoldc                    s$   t rt  fdd}|S  S dS )zChange unicode output into bytestrings in Python 2

    tzname() API changed in Python 3. It used to return bytes, but was changed
    to unicode strings
    c                     s    | |}|d k	r|  }|S N)encode)argskwargsnamenamefunc TC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\tz\_common.pyadjust_encoding   s    
z*tzname_in_python2.<locals>.adjust_encodingN)r   r   )r   r   r   r   r   r      s
    fold   c                 C   s   | j |dS )  
        Provides a unified interface for assigning the ``fold`` attribute to
        datetimes both before and after the implementation of PEP-495.

        :param fold:
            The value for the ``fold`` attribute in the returned datetime. This
            should be either 0 or 1.

        :return:
            Returns an object for which ``getattr(dt, 'fold', 0)`` returns
            ``fold`` for all versions of Python. In versions prior to
            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a
            subclass of :py:class:`datetime.datetime` with the ``fold``
            attribute added, if ``fold`` is 1.

        .. versionadded:: 2.6.0
        r   replace)dtr   r   r   r   r	   %   s    c                   @   s(   e Zd ZdZdZdd Zedd ZdS )_DatetimeWithFoldz
        This is a class designed to provide a PEP 495-compliant interface for
        Python versions before 3.6. It is used only for dates in a fold, so
        the ``fold`` attribute is fixed at ``1``.

        .. versionadded:: 2.6.0
        r   c                 O   sv   d}t ||D ]&\}}||kr,td||||< q|D ]}||kr:t| |||< q:|ddrh| jnt}|f |S )a  
            Return a datetime with the same attributes, except for those
            attributes given new values by whichever keyword arguments are
            specified. Note that tzinfo=None can be specified to create a naive
            datetime from an aware datetime with no conversion of date and time
            data.

            This is reimplemented in ``_DatetimeWithFold`` because pypy3 will
            return a ``datetime.datetime`` even if ``fold`` is unchanged.
            )yearmonthdayhourminutesecondmicrosecondr   zDuplicate argument: {}r   r   )zip	TypeErrorformatgetattrget	__class__r   )selfr   r   argnamesargargnameZdt_classr   r   r   r   D   s    
z_DatetimeWithFold.replacec                 C   s   dS )Nr   r   r)   r   r   r   r   b   s    z_DatetimeWithFold.foldN)__name__
__module____qualname____doc__	__slots__r   propertyr   r   r   r   r   r   :   s
   r   c                 C   sL   t | dd|kr| S |  dd }|| j| jf7 }|r@t| S t| S dS )r   r   r   N   )r&   	timetupler"   r   r   r   )r   r   r   r   r   r   r	   f   s    c                    s   t   fdd}|S )z
    The CPython version of ``fromutc`` checks that the input is a ``datetime``
    object and that ``self`` is attached as its ``tzinfo``.
    c                    s.   t |tstd|j| k	r$td | |S )N&fromutc() requires a datetime argumentdt.tzinfo is not self)
isinstancer   r$   r   
ValueErrorr)   r   fr   r   fromutc   s
    

z)_validate_fromutc_inputs.<locals>.fromutcr   )r<   r=   r   r;   r   _validate_fromutc_inputs   s    r>   c                   @   s<   e Zd ZdZdd Zdd Zdd Zdd	 Zed
d Z	dS )_tzinfoz=
    Base class for all ``dateutil`` ``tzinfo`` objects.
    c                 C   sV   |j | d}t|dd}t|dd}| | k}|j dd|j ddk}|oT| S )6  
        Whether or not the "wall time" of a given datetime is ambiguous in this
        zone.

        :param dt:
            A :py:class:`datetime.datetime`, naive or time zone aware.


        :return:
            Returns ``True`` if ambiguous, ``False`` otherwise.

        .. versionadded:: 2.6.0
        r   r   r   r   N)r   r	   	utcoffset)r)   r   Zwall_0Zwall_1Zsame_offsetZsame_dtr   r   r   is_ambiguous   s    z_tzinfo.is_ambiguousc                 C   s4   |  |r,|| }t|| |  k}nd}|S )a  
        Determine the fold status of a "wall" datetime, given a representation
        of the same datetime as a (naive) UTC datetime. This is calculated based
        on the assumption that ``dt.utcoffset() - dt.dst()`` is constant for all
        datetimes, and that this offset is the actual number of hours separating
        ``dt_utc`` and ``dt_wall``.

        :param dt_utc:
            Representation of the datetime as UTC

        :param dt_wall:
            Representation of the datetime as "wall time". This parameter must
            either have a `fold` attribute or have a fold-naive
            :class:`datetime.tzinfo` attached, otherwise the calculation may
            fail.
        r   )rC   intrB   dst)r)   dt_utcdt_wallZ
delta_wall_foldr   r   r   _fold_status   s
    
z_tzinfo._fold_statusc                 C   s   t |ddS )Nr   r   )r&   r:   r   r   r   rH      s    z_tzinfo._foldc                 C   sh   |  }|dkrtd| }|dkr0td|| }||7 }t|dd }|dkr`td|| S )  
        Given a timezone-aware datetime in a given timezone, calculates a
        timezone-aware datetime in a new timezone.

        Since this is the one time that we *know* we have an unambiguous
        datetime object, we take this opportunity to determine whether the
        datetime is ambiguous and in a "fold" state (e.g. if it's the first
        occurrence, chronologically, of the ambiguous datetime).

        :param dt:
            A timezone-aware :class:`datetime.datetime` object.
        Nz0fromutc() requires a non-None utcoffset() resultz*fromutc() requires a non-None dst() resultr   r   z;fromutc(): dt.dst gave inconsistent results; cannot convert)rB   r9   rE   r	   )r)   r   ZdtoffZdtdstdeltar   r   r   _fromutc   s    z_tzinfo._fromutcc                 C   s"   |  |}| ||}t||dS )rJ   r   )rL   rI   r	   )r)   r   rG   rH   r   r   r   r=      s    
z_tzinfo.fromutcN)
r.   r/   r0   r1   rC   rI   rH   rL   r>   r=   r   r   r   r   r?      s   %r?   c                   @   sz   e Zd ZdZdd Zdd Zdd Zedd	 Zd
d Z	dd Z
dd Zdd Zedd ZdZdd Zdd ZejZdS )tzrangebasea  
    This is an abstract base class for time zones represented by an annual
    transition into and out of DST. Child classes should implement the following
    methods:

        * ``__init__(self, *args, **kwargs)``
        * ``transitions(self, year)`` - this is expected to return a tuple of
          datetimes representing the DST on and off transitions in standard
          time.

    A fully initialized ``tzrangebase`` subclass should also provide the
    following attributes:
        * ``hasdst``: Boolean whether or not the zone uses DST.
        * ``_dst_offset`` / ``_std_offset``: :class:`datetime.timedelta` objects
          representing the respective UTC offsets.
        * ``_dst_abbr`` / ``_std_abbr``: Strings representing the timezone short
          abbreviations in DST and STD, respectively.
        * ``_hasdst``: Whether or not the zone has DST.

    .. versionadded:: 2.6.0
    c                 C   s   t dd S )Nz%tzrangebase is an abstract base class)NotImplementedErrorr-   r   r   r   __init__!  s    ztzrangebase.__init__c                 C   s*   |  |}|d krd S |r | jS | jS d S r
   )_isdst_dst_offset_std_offsetr)   r   isdstr   r   r   rB   $  s    
ztzrangebase.utcoffsetc                 C   s(   |  |}|d krd S |r | jS tS d S r
   )rP   _dst_base_offsetZEROrS   r   r   r   rE   .  s    
ztzrangebase.dstc                 C   s   |  |r| jS | jS d S r
   )rP   Z	_dst_abbrZ	_std_abbrr:   r   r   r   tzname8  s    
ztzrangebase.tznamec           
      C   s   t |tstd|j| k	r$td| |j}|dkrF|| | S |\}}|| j8 }|| j8 }||f}|j	dd}| 
||}|r|| j }n
|| j }t| o| |}	t||	dS )z, Given a datetime in UTC, return local time r6   r7   NrA   r   )r8   r   r$   r   r9   transitionsr   rB   rR   r   _naive_isdstrQ   rD   rC   r	   )
r)   r   rX   dstondstoffZutc_transitionsrF   rT   rG   rH   r   r   r   r=   ?  s$    




ztzrangebase.fromutcc                 C   sD   | j s
dS | |j\}}|jdd}||  ko>|| j k S   S )r@   FNrA   )hasdstrX   r   r   rU   )r)   r   startendr   r   r   rC   `  s
    ztzrangebase.is_ambiguousc                 C   sh   | j s
dS |d krd S | |j}|d kr.dS |jd d}| ||}|s`| |r`| | S |S d S )NFrA   )r\   rX   r   r   rY   rC   rH   )r)   r   rX   rT   r   r   r   rP   v  s    ztzrangebase._isdstc                 C   sT   |\}}|j d d}||k r6||  ko.|k n  }n||  koH|k n   }|S )NrA   r   )r)   r   rX   rZ   r[   rT   r   r   r   rY     s    ztzrangebase._naive_isdstc                 C   s   | j | j S r
   )rQ   rR   r-   r   r   r   rU     s    ztzrangebase._dst_base_offsetNc                 C   s
   | |k S r
   r   )r)   otherr   r   r   __ne__  s    ztzrangebase.__ne__c                 C   s   d| j j S )Nz%s(...))r(   r.   r-   r   r   r   __repr__  s    ztzrangebase.__repr__)r.   r/   r0   r1   rO   rB   rE   r   rW   r=   rC   rP   rY   r3   rU   __hash__r`   ra   object
__reduce__r   r   r   r   rM     s    


!
rM   N)r   )r   )sixr   	functoolsr   r   r   r   rV   __all__r   hasattrr	   r   r>   r?   rM   r   r   r   r   <module>   s   
,
vU
    ^	
                     @   sp   d dl mZ d dlZd dlmZ d dlmZ G dd deZG dd deZ	G d	d
 d
e	Z
G dd de	ZdS )    )	timedeltaN)OrderedDict)_threadc                       s(   e Zd Z fddZ fddZ  ZS )_TzSingletonc                    s   d | _ tt| j|| d S N)_TzSingleton__instancesuperr   __init__clsargskwargs	__class__ WC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\tz\_factories.pyr	   	   s    z_TzSingleton.__init__c                    s    | j d krtt|  | _ | j S r   )r   r   r   __call__)r   r   r   r   r      s    
z_TzSingleton.__call__)__name__
__module____qualname__r	   r   __classcell__r   r   r   r   r      s   r   c                   @   s   e Zd Zdd ZdS )
_TzFactoryc                 O   s   t j| f||S )z3Alternate constructor that returns a fresh instance)typer   r
   r   r   r   instance   s    z_TzFactory.instanceN)r   r   r   r   r   r   r   r   r      s   r   c                   @   s   e Zd Zdd Zdd ZdS )_TzOffsetFactoryc                 O   s&   t  | _t | _d| _t | _d S N   )	weakrefWeakValueDictionary_TzOffsetFactory__instancesr   _TzOffsetFactory__strong_cache#_TzOffsetFactory__strong_cache_sizer   allocate_lock_cache_lockr
   r   r   r   r	      s    
z_TzOffsetFactory.__init__c              	   C   s   t |tr|| f}n||f}| j|d }|d krL| j|| ||}| j8 | j	||| j|< t
| j| jkr| jjdd W 5 Q R X |S NF)last)
isinstancer   total_secondsr   get
setdefaultr   r#   r    poplenr!   popitem)r   nameoffsetkeyr   r   r   r   r   !   s    

z_TzOffsetFactory.__call__Nr   r   r   r	   r   r   r   r   r   r      s   r   c                   @   s   e Zd Zdd ZdddZdS )_TzStrFactoryc                 O   s&   t  | _t | _d| _t | _d S r   )	r   r   _TzStrFactory__instancesr   _TzStrFactory__strong_cache _TzStrFactory__strong_cache_sizer   r"   _TzStrFactory__cache_lockr
   r   r   r   r	   8   s    
z_TzStrFactory.__init__Fc              	   C   s|   ||f}| j |d }|d kr4| j || ||}| j8 | j||| j|< t| j| jkrn| jj	dd W 5 Q R X |S r$   )
r2   r(   r)   r   r5   r3   r*   r+   r4   r,   )r   sZposix_offsetr/   r   r   r   r   r   ?   s    
z_TzStrFactory.__call__N)Fr0   r   r   r   r   r1   7   s   r1   )datetimer   r   collectionsr   Z	six.movesr   r   r   r   r   r1   r   r   r   r   <module>   s   U
    ^                     @   sL   d dl T d dl mZ ddddddd	d
ddddddddgZG dd deZdS )   )*)__doc__ZtzutctzoffsetZtzlocalZtzfileZtzrangeZtzstrZtzicalZtzwinZ
tzwinlocalZgettzZenfoldZdatetime_ambiguousZdatetime_existsZresolve_imaginaryUTCDeprecatedTzFormatWarningc                   @   s   e Zd ZdZdS )r   zBWarning raised when time zones are parsed from deprecated formats.N)__name__
__module____qualname__r    r
   r
   UC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\tz\__init__.pyr      s   N)tzr   __all__Warningr   r
   r
   r
   r   <module>   s   
        \]dateutil-zoneinfo.tar ]@m]'V,}"UE#"b3D1l}lh,|h{gggvs737V_z7||=}=><}}~~^^^))o(RlD%?uSVod|xn	-cx0T+"Dm`\Z	bMxu@M1}jDFL?!=~x~kMxK<]~nQ1}"W-z<"j~=6g+3{w>>~QQ^=|"<Gz=|}#"##~##zt#@a6DGz|OzK?mhul~q^Qq1oX}w@q}~v~j7f@97>"2>2a	/~q{xDo}oPx\p.e^>_7xyV>w:Dy\Yl=28&Uo&[GthiJoQUy7 fvm\-Xg^`'4Pu\_2WREOd?i. <b'Mw(\:I/5}^z VFzzzj
%9TR+)_(bj~T9VGGM5zv{M}Z}KYu?NDj<PxQ^dm@jz$M? DoXaeYFCu]7>7Voj,.\3g%kMr>w}CY.w=zsNzS]rIB{A*u#K1I*H^|gM/j,LjhOT+E%q :vF3F5F7 ###bHdd?cH1q1q1qH1qxggR3r32F#srE`dn02?#F
#Had ;F#|bdN12[/F#|cd12=F8<dd.228/g{Imbc2WR<w3dee;rpo?oOF_^ciX;ty^se~5*94%;~iNysKw,;Zv-|pNP`&G*uzy,GLS-/sqSoS;=Z~.ctdH@)Gaj.~W5'\Mjymy,S\l|ZTE^r4OK^~QuZ"7>7Wn|tWZOkZ	ZZaM6Ekm5h0+3g${/3.';crts-_;fiFoU7=|]J.
c(D)(0)QX(0L I`dr02ADF&
#	ad02y@L"F&#	HbdR12\L0F&#cd	Q`LHF&%#	$&"+
l",
l"-s&o;4QX/,
z,
( C"Bb$
`,@1HI&b[mZ_k:&6:\3)9uzw~\\}kRB'fr%kl$)4=o_D+V$zIKM**IU*,i/?{s =rz.#G3J<+}Wh Eo^aV7`hM/m/.G;XI?z{{;O}O?,	7g[T^B=/vwMijzWJHo$^"}?QknkdvwH puLK-M1-5aB6Mfu_jA n66\7mm$pYimM7#o.Fdyi1&fdM7)#oVFpyi%fK~}dLx3oZ{w;CL,,mj=zCJG~t,kz-K'VNQO9;XO/3_Cu{GaTldAuJzL5z~8aS=j+exzN.\\]#X4szW/67Mm>toh"fDM<BH6+	mZy3ffM79mvF;wh n@]|CHw=;wh7!bC"m|]N"B5J7Zxq3ZH<};|;3siMlN~Mc:sd:k:-LuN~r-P4Q_}j,UjYuusfuWS59otbuSz}sB}nW?],VAVsRu.lw}VsMO|eo_-v:Zq:VOurxgzw(GVrXUclg}?9C\l VUl]ec9W)WN\S~yF>br(("Vn~
d=szkI)Rs.[(F9V PNiE\hEnol+vvVbfr4eOVl0\ |5?BJr\EJYJw|4kUfUwY	]G&cFQi5E-5CJ%>	Zriu6VR3E	4(!7pI
|,	~Vc`5u.w\Oum{eKr+Zz.e>#,KiZtT8-&et{a'rwhZzr" r|}y`>IN(%g<wDw!I{7j>F|6b<mQ7?uGZ;-_ndx.}gz<[Y?b:W?v1]*% jX$,J$J$J"DJ%Xb,c$3$x2222222222IhYlYpYtYxY|;%fdfd!%1fdAfdQfdafdq@N7dF/H<%8DHb$Qgda3IIwNwN/VrcR"ccX8%qJp )ISd7N	np<) )S"d7N	n
8%qJ.p`)`#'FN8_J<	Cc@}rrQ,E#'+FNXSb	c9al)uGIMk#~[cq#q,d1F'1J@N|b8Pc># D1bJb&/911]#1e#>.15#(1)#!1D@#q&e1F^c41F\Sc51F\Rc41F1bJb&1%W#c#dI;#'wFN93rgaJ93`dF #F6l 0I`df
Y2l<02IH0 `dS$c#F6l6p`+t>F5Tk]Z3OrKOxltzz4*9?uq-?O/f[iLlfGnfII8#DwNo6ZvjRN;u|hS_NSH7X/0zeS_-']>dtsMmVKK?%^sRfrmf-UkrqZvb'[;Zb
6B"0CmqWfs'|a9^nn7)dG>*>"Zfi%0df
Wf{2_zS--Q^9GeK,X n%@GR I*5Th$HPD"#@EFRBTdk,""_k"K2	*&TJ$+bZ-i AD2#*A@TL$9HvP1b"ATl?,O"jiZEE$d/ahVH"$e"%H25Q dTDQFEQFTFkAd}[27et]"CW7Kf@l)#
M+<Z\RRVW=[~$grwGwaTS<i<p0&A_xP8Y@pe<1hF'FN6XeXxCFl1[^U}<}^e5=?Ko3^d6kc6mlIms"hsd9y.K;P'@xQGvc~	{GSjJOKJ%dqOL[3Yjg>rvke+e7}5sWRnh-RE6Ylo(9H@L``Ph#p@eHewh knrLoUJa-y VW^cUJoZS\Ry
K}+WI|Uv*Zr%LeVj>VV#gk@awpRul,qW2^%<<.v]urT;MqTZi#%SZ1Z$i=[zLv*W&BU
]=^n|$5>_kzqZuu-:h)e&ZL%kam[nPMn_~kRyR1.[K]{-Y9q"c=rE7F^K+UFidkYVSuvrGoBB-!>^o1EPK0&9%+m[Oi5RiI/5lut%6Zu.<8_S59P2Yh~#6F?23K@b(f
$b}b-#3$32fF0oj}*&n1t|ab;#3@b>@R L&@?)&hEU6RHn#@m86RBEUmm6[6aQFv
LJ6au#######A
(lB@R"bEBT	6R&Hn!aB
6R+HDYDYD.~+h2+hm2+h2+h2+hM'mvm6RA )!l@RDHn#eD6RHRIH)QO+&mhr"KzIAf#Fj
$EET6RVH]n#ETjv).mhFv[nd^mNVcdU.mNVgHn#F-A9Ynk+v+7mDUDxFUE9Yn)*vWV{T%]E[mZ2/<kxca^/OgdTk'lQ3N-9g>r:33<sy8,Pz`Pg'QF[b)=R?WR~R::aQ]e]e)k,Y>
5\,35pV}RlyduVrj[R^,,wX8,5q}`+\w{No:kUKZ8-ux:8`1unnuAm%K-A-A4z|g[J[u6IB>r;QO--U,9M,aq)s6<gKc_eW[:xyaNvvjwjs%^NgMK1YzgJg_%vG~Wd342 `3^,6 $9i$p9lNwE#F5"dL<ugMyY}?{JlPco8BH#J%`D0D	Q(QF#J%UDQh#J}`@B@(Q	F#J%Z`D^0D1Q(QF#J%D?t0DCQ"(F(	#J%j=DQQ)(QF
#J%uD_R0(F#Jt%JaD0DoQ8(F#Jt%a@@?I`DR #zTWb4N%FdFF"+KIW%TW~eI%Y%i](#J2#JR#Jr#J#J#J#JJq_! I(}I`Dl4<DLT\dlt|!;IY`DI`DI`DI`DI`DI`DI`DI`DIe6V[VkaZ~Z3:Ow|}<3zli8=uIkVl9=W^ir-zw]dI.~[/\sS|cK_~oOO.Bun1"u[,XRSM?g}W]crHq|B;^p9E3[^5|6'q'q{q'q{S1'qm%#s?q'qH<U"[J_JcJ\gJkJoJ9.MEVFQduw
_j,E&Dx/){7||~{o_'i_u[uQ=%d)VKhIk#hB[iV.T.7/o)V&d#_9PH._]yW|}q9s-=rn$[++g|5%r8`6r0p\RlkXJLZ[>gh%Vz=['5%ms+zP*4$W,_Te\5[e7\>[+[VUj1bQ3z5Vjyjdx\s#r:u?|`7EZ[l=zlAjofB4>_@k2}^Zak<fRCkYU.Y!J7[K*;{t:V<t2U[OAZslkclji{l1Ji1Bl.>zOT8J}O~m++N_N%7B9l	FpG[b9Z=hCf=16<9DumU4g%[/>ghRO?Ysi3=_z_N]r?D0F&CDC%CF4."{^BDyf8!R<3DLg)R5I$Qq$Hyf8j&8jr8zI,eI61-k,e-WI)bZ YLS6iYiY51-"eb,bZVML*lkbZ=uR'q6$bZ	q$I'fY$bZU&eGAiYl,.bZ83U^#eUTML2bHL*iYd1-"e61-k,e=iYbZ)H51-fb	D		&eGAiYMQ$rbZVq$% I[bzuHL"nY$bZAq$VI(eMGAHiYQ$bZ'(HM1-k8
SL g]riYQ61-E*e=GANriYXZ1-"e9Q$bZ7(H_1-kE",e,c1-kE,eGA|e_Y61-\hfq2_?}YujkYxx,|<>N~Fy&YCbmFnSRbyEeO~-br_k[mN:/Yp=kG,>6]6v?Sj#IC]=uIQ-ZtRZ^KWel;h;)U]NM;%9.ju@r|N	R7jKCl)WZ66|Ig._%6MIg&	kSlShsR )oy_'#p 
_NWU"w9/~(Y]hr`QpQ" 5<CL2? vvd/"B-~_4^]&|QLPw0ED!"-ige&D$L*""|C2AD/x)"A/I;;. EDH""%|hU@R74GwN4#c#^Yq7%w@W$>mn:w\9misrLN z'VI[V9U7^|BSy'o+Yl4U7[@mb5G?kPjQj$cRsw&$fV/HIyTo^u6=>W;WX;vOv:Uh9II:^#+ZbHCHGe?LzTVR[>1
[{^^ygV_oc;':=H&zp/Izv_~S1uza1\zjn$Y~^ipvaG%3N$F1R(p?a$a:u
PSa*8xQq*Cf`cVXF_a:#9uc*C:#9uC5:#9uG0r <A|AAA<A|aUXq_!a:b$W:1uG02uG02uyRXB2uda*KaOa%d
 ,!UXpIX:_a%d ,g>_s[_yto{C7Oo\))CKv;lM/<HjUETf){^byK5CR8KS-3EQopmO-Y'^ii2UgGt0.$)Wg(<7',N-h^K
q]m \!Q{xm m57dW0~E
VqEha6hajV!1nEVA1n#'oX[	D&64ml0Fw^	5+OdLl3gSXq%.9w$lRjg85OzWc^Og+$JA724\'j5&#'qe1[8:$RSMsl%(8dri.G0#'9?W]&]}?OWx:oH/F=\kdCgcMk|Gu|3=Za3Y3H=g``*BE*l)^<SNY%g=g>]r1/g%s|&r#S7bo!#KFm3fo #oQ%P@1XVM[e: .<3d\)?Q.iz7*_,}"cQNc,PF&Yv:v,h9}1'T'H6(3kZ~C--|..y)kjRjjGa;?Nrm@bgA%xgJ:Kn,52B:v,t1hT+xvWsCW-UqT6Q}ZFEf)NfoO>\`E5pZky'K6mQja~j}<KJ!-KAj-5_B.QCwo7Yr_j:!B-Z]	U[l5)8ZnO#U
vS&5e>RW.{uJ]%S:=UcX{6/}g5v/2-o@PtJPpSJsRM[@|}:diYHm91BuyN2H%-WqbbTF,)G(khkg9$.$N=J\8$p$
ejcHL\$il-'=bl1qcC q(._`y6'q%~2OqXq_qXqO-+ 87
sH|F%N#98n9(-G:wGh#h%@{t cGshYYYY#Y'Y+` `d`d`d@j 4i#hJz1h 
I[/Y!`c7&M1a] Aa-4I0M1h& :@Z
D,)nacah3f&=4ie61qbZ8(:1-k	1h?Abtc&=tqT"I1M1hH1eJ1beN1*Z*b5c&m4+,i,Ig{&btc&4i~bKUuP1_q5xv?},OoJ#^>SgMDAVMtJ^(]IHq?9#)UMRmV[c)5=7=R^7R|*L-X./")N%C67O?oRgBJr	!>2:/J#A)k	9yHMli>EsMs;u!ae*>VFv?L4AH
;t(G?t;u`n-7JntDT2(^ %2gC1FiJ$yWu<Dm	oPUJ|c 1!uCwM!KBg#bft:kS`FaO#wGF_^_g)17'l(cK^Ez-uP)sD""HQ	'G	'G	'G
'GQ
'G
'G
'G@Q'G'G'G'GQG(Hh#	pj<1NXFS#vC%pj85b1NXFz{Aph" 1FS#V]pj085b1NFS#}(b HLc#6#pjL85b'1NX
FLS#cpj\85b/1NXdALj85b6NF,S#pjzFkX~;<GyMGW()4wwby|J|%	zaCb3.3ayR]>?->?Sm#w:>|~~vX?cis
:wI^|~vO9~nX?/~X^pm,_Z|~Xx^*/h
/[-~EXN
=Qb\~XZ?_w:-++_:'wMog&bUX7?OXm!X]6wrzyN|>es>ciA9sA0[ay_K	w{yc`h?sS|h|X|q?X?9!c'aLz--Y56[6[O^~U?#=?//3S4L{-om>4cY]e[wy+Ym5+.mSI~HVTve`m=	m{7PjsLoj;2;m"?	o;ZlrBk('Nm3sT;Sv{B9BM.,\.G~yFzdbr}v9>f1mWx\r@2Y{?<8n{j{)Hy~:kERy,;XqRRp31URy2^(I\K&%G{iqgwqa24A1A{(EF7(0Av)Bp]rP`H EF9(z(G,sa"	M(EF9(0AQ0rPa"mcRI}N'QI8yE##G$#G%#G&#G'#G(#G)#G*#G+GkQ)rq-?^\"X\F/3:s3:g J{]mg3Ov5xvF;G7H2P3hjx%|"OK$sK>3uwl%=/tbK-t/4r^>V5L|M|=Ao[|]mSwUr[a^pY,w\h`|xG{&?R3-&Mvea].-brY]*^t61G?o7]\"cmM0g!_%StN{	JRoj0GQ?>hH~vLOe!}})+26[d`i?#F-~8 Yd))))D.bbbbHKB8BXBxBBBBBC8CXCxCCCCCR"S,"S<"SL*.&'nKq1qGN
c1b;91Rs\Nnn1(A1=/<2zsA>C1g?@.IsoO!Npnxo7r{ge7xye/s=[i1yxZeiG(l3}k9}m6;_*DNWMkl_E6eajKmR\(vP\YalKgPVNvVMmVkvTdz[r[68dl<vSt9eWUJ(_'NUX`l[m5V?b~"mg]Kk>+,%yl;T~vcNH'c5&*OxUO+b|Blg{+ZUlr.Y\*QYI-fK}Sr5_S~`J6}pfxSO[OI7sSCo+Y9j*).Tr})O7sUq[.A=-OR~%o36|-e[9o
Q+lq-P+znV{Zo'i%~B.t\r	\fvoY'v3l0\\\qbr*Jw|nykU.UqP	G&0~FQi5E-5CJ%>	Zriu6VR3E	4(!7pI
|,7C.|7En|ndbf'Z	ZZkm4Vkj$?_p]'a7-eUrnW]vk=|&GYEe_EZqZL`0NZmb,c}-kqQE|QHKyjkCCn}6|my#WorK'3g}Mt;_,6C	\rEPZ^m{O...|b]^.9v1lA9OG2AXRb$e$8&I,#,#K-#-$eH2RrR$(2.5JK<R$(4NIRx\$(6%	dFIqQs\j$%Y^HqQw\j$%iBI1HMri|1H$GR )`pR)`pR)-`pRZ""49
)]Vc)u WN!;hMAkJ+hSj]yqZj2t9)eN-sJ?hS
5! ")eN)	-sJKhSjBZ249*)]0hMiAkJ_/ZS{a^98)NpJwhW,"ipJhS:d#Z-`8M2rdt)&#NFN@JF92r:eiS+#WFNf92reiS/#_ `FN@J9%3rZfS4/iFN9e3rfH)8R9#sFN93rzgiS=#{FN1#R?(3@D6 HV ,#Fl"0M`dv-#FdB0 `d;<?Ed-^0`dV#[Fl=~0adV0uj0=ad6
#F,!#[F1Iig/$\Dm#F8ls0ada{+=*}k<<3_7x^<Q];SkxKf/=9|;4H|y\d2xx8=_}5p<A^61L2^x-elg6yfkai],-/q~SzhKfomkZFs-\{k^"8g'~[P`5>}o?GOissgn8wnOu=Kp|.eTKOWrn\9lqx~um_IU}pI[;HW5z,wwIfUSzp?@c[GYl>NfV]/[32QT#egu|z-K5z_[sTL#]CTT ZP^XAkGz!R1u^Pkj%HU,zkUzT}+|TvHg\CE*ZBkkK_ZEWYZj%kLX`pzrxj|[om>s@dK[j\;eGuvl4Y G8Sq6r2Yw6`	K;{`n=ltM>x'tgi(#d3s,A8y8U=@mN(@q?89z q $N ^ n ~          K' q
5 
5 q5 5 q1pQub+s;
=llj j!j"Ff^&s2_vjd/j0j1jbhcJg(Q+Q+Q+Q+Q+gV V V Vh:Z j. I@
$zZ4ij
!HGP+V =A@$mA@$A@:Zj
;H{P+V B@:Zij% i#4
j*
WH[@._@0 #-;8^?{viq<yU|SJ(GB;7.i=}w9j{|Q]KM4t?d-/m]x<Ix94eV{A9\Y|5g+b7g;&3L91\slijY>G}f/ip"z8fb/Vz%u6<(2*&~Le[:5?o*_Q6SB9*9kg])3kLMtx0utxF7qx1u0:lJ2=^o60^<xQsZG:u?\c7-ajk=\9"s}sj&hxG;Zr:lnYc%|i{xw;sGyst=:49,>5b^}9"G+(12{]n=s	#vVG6g_8~71G|'7'eN2<^S1jhb,Gtn9?xeKU)XeklRgfovMy~a^;C=1X$&H8Vb%	gJ3%b*tb*"U8@b."NH,S$&)21|AH]&8Eb9"1HC$p~Upppp
p|BtwcNN}&r!z IAIEIIIMIQIUIYI]IaIeIi_)) I}IU& %S$5S$ES$US$eS$uB"S$S$S$S$]fUNH%br *k@V5U2*9DWHjn1)+OtO
'H*(w>!*kL1#p@RKtI1rI=5&ET]cRRtIM5&EET]cRVtI]5'B*q
	-@R]t+[L
$F]cRctI5&UFx
	3
>RkLj1)6#+7#+8p#+93Y5!1;Yw^5{'_W/)obcb#c?ow]=7[k4>47yfKI]m[9iU}j_S6`ikc}wow5sqC%v$nc?0xmcN%43B\x3+Uma*Ns)7?)`$wL9^7|]!=WB>6tO079]Iop1	5IGIGP<4,vP(+P={wWfsRUJ]{Qo'="`gle1y9j151lhlz8(5we7\j6Yx^rCwMw&{iR`'&&y2V}l
r3&RR5Me347<0-UM;%<fjnU{")w_.]&ujTM
1N(XFR22D~}fWS~+Wn;cClE~CwWIYo4Bo{c''aa;3a1ads9..f{YF=d@]5+agUZ,y9jUE#bqs&&9`c#.c.s*y9am#~$.3{T}TQ5`j$=@HtU#i(sc5H:EZHI3P5nj$@H4U#FT'/T+/T/W3W7/T;/T?/TC/TG/TK/TOISIP5^;,nqYD.YDgHsiIP5HGjle9TuW CH$CHU#i FATIQ5&j$]i#HgH#1@:jRT*Y3_ DUI4U%(
C*ISQU$mEUI4U%,+i-#-4#.U$/H`T"IQE*2F?k3P"EVc54UM"gGR?k9I"YQE$mGQ?k<"YagG@?k?"9<*rH")'%sj>]Z 2B|^)> >2.t/_bBkMf{$4igLkx^bs1?xO w3<o/=k~^'=_ 0mx*c"cJ/eI{|Kl?cvaf;Y_6Q40oH[eZJZX{i)%giX]\Ow?ql"IFBuC_H?$0N[G,3mYXs]!98.%~o{?y6TNs9o_5j7~F!u`O?+YJ7raDf/cN&MO^m:uK=-r{cVpmDaow3;'H];K~!/p-t=%fq _l.}V<1;e>-L2Jo)s5m%G5KNk_>K.7U7_og>bxp~bItKk/-_fk_S_z>P*>kZa-jMy'-`pO$tE;57iwOsi	=2fEbmlbZ[>4Z>/u^y( z:{-_&v,x9LC4s4GkIW~4<ks
'5C.~bI^3|OZ0Ms)va_sg#?-?#yVdgi<?r4GJD"#'?H^DdG5G#h\?rlEGN-?Hg?{WT)<_uPI^wK)L>!|}zl2)a}'~XXF@0@p@@@0H@0Y'G~H~I~JdLdNdPeYRNSHp@_:K)wP<fHp1ghJpYHeYHp@@@0H@@0@p@@@0@p@@@0=Ep\Hj {L-Rnlh]1X!:k uz:pI`#X%RC[_C'|t:qI
:qu3:qlIJwNT3:q}'":qS1G_"5K.1&/%RDHb^1_,+|jx//%RDjH=ci_"uK17/%RDj:qcZ}?ZN4vLk!:qcZNhiD'n7vLk%H|';XwXW/%RgFE3;uc^6|%'t0:%R&3e/%R+w+uz]SXSh;ugk;uW;u_+w+w+wv+wbNZNZN]:u1_]U|SN]:u1_|Scn\|{~uq~_4Wc93gdv#"CjtuLDCaa]g8;7\/,Z(_HEiI9L>)J!h!tv?_p.h_"%s+wwrW~L\!\Z;+-^pe0^^W<W9TN5IrrMs\X,;>ouL)rMK	yp	I&%(YB	_	wx"7]V]oN]-{d_'7
c(_=_$|b@2aNn,ZW(<pTF	'8BF[FI=3{E,{({g!>A-x=,R}7d{#"Q9RYwR]o8Ej"}xNR{G"5w.ocfIVIN3R\srG)~o9<ii0R;+	)H<'F9ZCpd6RJ>9eNN+yNz>s4-}bNG)}yo``+
ZyK=.~O&E=c}fl$(Tz9L-++= Laj 	!joCAeeHoHPi2_7LzP[ `wj_tg
t8j;V V 5}`P{}dAjAqP{]9ldGAsP{H=zP{e2^W$Cl2:P{_pP{Sd	ArP{liL1ET6Tej +^wY+-^w+>P{I^CjOP{ehj_Ka"7+rP{G1Es;Rdcb!<+Ez=\WP{p]iHP{qP{tw9jjG[(Cd=7C%AcZMr$=wj y@mNqP{t:*jo]KVP{$2^	j9j
Q;-AqP{:^j$;joJ+~joJ++pP{AaJ+v\U9=M/?4 O|$/0?JIyEuV3.{|+<P+C}$}[\[b5K[xi|1{>aY;RN-]	}[]>?5+_Ibmw/;"R#]mw4]<Wu	]`vhs8O?b<ZTDXX4[:%(wtbveK'O{KgF4z:B.x4/6]u]tv\~Fxdx}ziwJ%j?4.JK,2{W^^s<MBfOrxOiZaX[&WrQ)^Y92k^whg'BF50OqzZK+Oibz]d|>}RD!['|Jo=6K{2`\*d|8X,Z)Y;KX)ze&HEa&~aB1+vvp]\{X=c=5'_zQ1SgtW;R1;E
	-\zB^zja>gKi[%)AnybRTb}fy]._]Q+zMA6w6"v>2&bfGy-FNR\W<Th(.%)&u;$[U6!MU%.9IP]OHOH)AmRK\J+*>8-=^z1]L&M__ox/mxA!)l95RC6`0t5
<	R2(*	`!	 `"	0@#@2F@(%aapG'	x` (DvLLY0L TY0L\Y0L dY0LlH /[/	 `0	`1	 3O@R?Spf0hf0j%K`X
 `	|K`^);-xI%0N%+`	<#`	a	4`	8tXm'uX@(PE?I`~7K`ORH bORP  O`)t`)Dk,XX
]')8ti!"{X%X
iq)X
iLE?I2$BKRa)`)xbOR`)a)xuX
uEX
b,I
,o%X
DX
KaKrKaKaKaKa2r,J%,,,YXNX
	,@B_	K!^G\*Ra):rEX
N:,IKaK!SpU k%X
4X
J`)R`%Ka5Ra)+lX
uX
5X
%X
F8	B+BKK[pNV)oJ BX	RhZPRxMA0^P_^0N@.RH@,aV!%X
DX
]uX
5X
n:,2+%0_)V!0_)J,WJ@`)`R"KX
a,*b#r@8S&&$L|?_#~[-3'KYAVU^,2`jyj=)]COBFLSy]yqy

*%yk,yk;uym o om#oPnS.W oWf[[M<<[^YjuT^Q~ o*[VBG!7w^HsAlOJi#'(<{_e`Juy9Y@
-G[Os]]lH:?;q<+1f>UF'N(q}%KkQ	k*c]-OL~b%F59HY'%'JJrJq%95%$E~>s"OKYy1>"NMsUTW)RBqf	'8s,,	L2$d1Ifd1Ifd<[3@&,,d#LXX9ku NRJlR9<TcO vl)M?e*_9|AS6M?emJ A vl)lW+Ir6P*grr6R9W*g|lp_94|l Pl*_)$T9TU*gVr66v"";|k@E3
pD~""2<vXh"(!k@;b/ 	)"N_AEI|D~"" c5 a(<vXh
"(a?+<vX(l;QkuAE_yW A1_)*cRt|(";|sw+1D. 
csO^UGM),7V+Ic.l~3H;|elQU#~lk\
?{[?>3K
?7Y[gZ~nUO|}a9|mA-_'/73||Zb	vmEOzvu^;aM3|}vp <Wj`Lkk?y^KK#5t;+(r|SQnd9c:j9e7uao]UhPs+>+~k/QM,f#F[n?wxXJk6~/v^yKyj>u1xRTT[Rcr8Lu5RyNhpx_	Fya5iw)9-n\oivnr&u,-.6	Sj9cTln+|2`6}3mhGO,JNnQZze%wlx|O|-bB]n(6m@7c;*ls}Ln&53OY>g3{f1:w!6;$9$Sozu:Z}+?V+7]lIwAl7:"Ytw4Y%rp)n%*`)L.]>/o\)y3TCFd%O_be52:>4j+-3$*2%c{f}	)Yy/9j=&;'G%mI	aJ)2%$|dya>bNSM>'}Ug_;.{E+\Q	(y_ctZ#)		MOhBB
uTY{AH4H`*S|W1W2Gp)>L#\%eQ"^6e"`)f"b)<f"d)\f"f)|f"h)f"j)f"l%f{fQ"o6g"q),g"s6Lg"u-lg"w-g"y-g"{-g"}-ggFR\T9"GRR&)eR#XHI`#l$5uFR;9&[9N0!r r0!r r1!rt r|"GRc996d<z3c]9LgyU;"\"D	"LgX99 r|1qT"G"<D!rlcGX;#i,rhGM"=vDM/XT1b	N8sLp*dS!YTbNEbv8Tp*TT8hd3wm;F&Dv;Ym3[9MlSb	bT,uTHTB<b-8x;NgT$'uNET2p*TSiSxWp*\nX<ZxN3sox
	g9nMSqNd8>gTHS?Nd8X8!p*S1NgTDSSSN A,p*Lp*,xf	N~vLyl""89TSkS1%NjS1$NKv8]T,2aSdS1"S.Nca
;<D|NZ;<8|N+6p*0_)SJ
Y<iH_W?CM1N;-*OV."m4|]8,\(7h~Mk>Vr'fhS	r*=Z=6P93z_9j?>Up&\:_>W.\Yw/	We-9E6OPK-h0F-,0/	L|yNP=-ZZWxlR;FZsRgpE-\V*^Q*u,mZS`'\lEx<m2DB(z0)4o(4"VP\oN5Q4VoAq_WXzLR:-glUZE9	&9y>(/V=eh(C:cA9O-*ST^O'dP-%#JtvjA].w]w	}w=|?5T}7ycb3c+"W!Bk|h!i<PS8[wx>mc?%bT2{:0WuS#P"Q]uM./(mghi^*Nh%8C&84W*qnPabV9)Hs4~R`]!)q;?XHX'WQSlJJe5eWM+PR_QU_1)#&WYhJ[[T{3)fRc>crQzYAV"S=C_C_[ <	RtV?VPo)PSUkIV*h_Px4vg|1E'ru	xu]?E-"zumS+PTWzu=F_Pq0b|B" S> y1EDkSF^Lz/u=W?P u=NP :)p_E@} U>VvL(u}M/@]g 4C]SGPTtz
u-*PSTRu) J SG u}.B]C]PoP*:W~]VU	 5Ju= b?uB]UP* :)P* x} T  H~ Rqxrzu	Pyuu]B]Wm*Tz
u~ R b9HPPu9> WZ|X^~
WZ1_i|VAkWZ'_A|_<.&ysqSc&/#veyn?n7Lg!>z^c-{NMuI1.}l^rFtOF~vvB48Th%hr|M\;K91[d(Tz_tX|fr|.mtx_Y&3[^?j9??^&J/a!(,#s}\JB8rXF.cx,\#k"p\H5rAH.*gmBc_As@URAg)A*2V>o<+@Vp?z_~~U<Jp_dKkUg]gv;+p_Pez*c V#;bF,92H3us
,	@F6}pdpC
/|m1J+Jqkyw@kg\89)N3UGQxjo5~[T]~?_P=Jp?JN1\MEhW/4xRZdf|x&j+`2|yXx5tM#+ekkf|7V$N7^F:MT^Qa~wu??ka930CN3`#9#"g0cfL3)r1E}b/9c,%grZ gE63T9,};4X?9a;3MGztgP'|?1)qs1~_oGBq9U6]o+l.RMM}w6k(N}^).|_S-]}I{D({=Qi,~P=Tor0UJkKuQ|g67oA9S.'	].VS]W'r"ON.u]uZ|CXn
jC[8L-/ 6om1=f!
N9jg"g,@4jC" g+}ajfvLOW0'\rHs`bZ+FSU[O~T7
$?'OZ LgT7]7l.J}b8zPpSp"Zpkh5Gm;%_JXKWw2- Om9#n[[6oXRh]7x8_mkN* |C_Pd(0{N|{5(s:*=v5<_W[n0v:Yb{vC;AXm8|Tph<Oy5\d{[0g tQ5=uQ_
2!>WaEus6!_y'zEEC?"/{50i=j`hTQ}nA,5F"5=j;wj50XrwPXQKTZ5;"CDAB<>r7JHE]%Rrw,!w)T}zT,!w.KERr3P!w1KERr7T,!w5Rrw"GM&G*B~R2X*BfKEl`U	R!:+xl
YF2S$"dTHaT"!"dF1JfKEbhFf/"_!
YR2w=!qVg99[7]e\hWj^n7XZdOENk7%h-XeQe{ZltO=km	~-gL5{57D2M~z)j`!h#k4Ni#g55-v 6dDMhEMjDM+0i6x~ii[QQZQzP[QQ[QvQ~#G?W~~~N	M85asU{\}}?Oxt?U#cN&@Z3X(Xv&[kZgOm#muK:kou=zG.lkm714Xw1<Q$sdle@KDk:F7zYjx|i-kU!=jfc/O3G][gqkK!k7TNUyf'^5NUB_2jx}o1=!ogr{n[Z{l$<>1ggjocU?<iZ$09=/e4).]p>mjWSAna(N,`
8F5,eW{CtIazaE;WFFf+YQ^ZG:Yqj\x05~o56::ndzBbTg40)!)1_|\R5>=YbN>bu Zkv9ng	eE5U>c_kghZD>30F}'<Qiw9osfk=~k<	<xyIG:7H'#tstYd]KG:H1\#tst^m:MG:H9\#tst}:Fl$8@Gtx.0%D)!PB{1	##`#ac<a`
SVWG{_X =3Wss0WbR,b#Lbbs\_QKX<\_Yt\=]l$06c26<c4\c6|c8c:c<c`	1W` 	2W`!	2w`"s.)>b$)Nb%)^b&)nb')~b(	b)	b*	b+)b,)b-)b.)b/)b0	b1	b2	.b3)>b4)Nb5)^3' ]W6yvS|;hvH;UMIN?\d%p>Xz`<gbu[4\@c cj9V_Oc%:k/zGl[o:blnbl8{HXln=nn%S4zN/k6f[S~V6Xz*[8bmil=6}FulEm/:u,xe=>f7wx$jX;;DZ=fV[-_R~Xb+w`m!!7CVB^5eg5]LkuFg3/c}m`JG !. u6hid
2F_3]jV0<lnaDlqd|^j:6:~5):W=XdKpbMXk{uA	)40)Xd19fHhcK	*pZSs/JT{l/_NK_k{1'>bmg>)ZDLi!u#VP\XAi^7efP&)"^)$-+#@+3d42A m h/1  % dco7o1o6?n1fm  $tm ~V_b} G F)P 	p/F_6j
" {m YAl  sm # A	'c
: |@q})A@q})(Rp K
sl \   
@&b}l !' 
?
?_ @ ~ AFk	 7A EFR:+?? (  ]  70@GA] lA!)2OPNAAs!  Vv
 A@X?zLCR|1 /QUOQ2Z)\tSwQKkrmpu+-`?[jmy_-6ZK-_WcK0_FX4s
`~m{_x3r;oWv(///}lO2;GUp8/VmVg>7G7sNpdFY9kz7}){ZOy}hWiF75ZfM4iKf;/t6kwi{}gDn}wkLzx9$N=Tj^0&wxY?4wXg#rG1dh||"'f'IZ0dBt*|:,P:3|vHw\hw|gw;w	_"gSs+wwrW8)]d}++[#gIGo? ~N.iC>rix${!L/q:9N:6^}5"I5b5WZb/9!?]N;R]m\UwMoz[om"4H",Hw"RUoJ$Xgi2"J7\f'JnKK
KDR-ZNV"m74C(/{:=B$r`;=Z6k+)T[p/I]@on\Pzr5"q>g=?5H~}I7&oJ"c`9$xr3"Y&e@$wBR4F1|l^4{y[ rRdY59* G:Y]Tbl8E"}xN")G"Rb.ocfIVIN3R\srG)~o9<ii0n
}BJnbI=1Hk';'\^,R.3urZs}iSs:J#~ScR/ZojJ&+$_F:v^MjxosN=.22X
2Q~n?H #ec%`&-DQG8P[8)	t!Z[\]^$_$`$aJu<f#d$e6lfKI|fKIfffffKMfKMfKMfKMgKMgKM,gKM<g#t$u6lgd{ewR!KMgXr,5ARu,5PR&d,5$aa2dKMJXj;uKMvg?,5iJ;KONKOI	+k2q!a2V_)a2V%a2VO>s2'{EJ}d44s a:V|d&,R%9KK,IR%Ijp\N,y2,IKrKm,d$wudK2H%taIr$;Gk",HF8ZIj$"IdV$"`E6`E.evD9CG~VhVd+2D9_9J9U,aE`Ep"kK"6Z	V;u6kvLk41"bftX6Ve2D	Vd+r+3VVVHVBVd	Vd+ &|\S +;| Vd5Vd+CAV$	$\V"VNV:U:24	V
V0	VLVd	Vs2>2jXaQ+;V$+!||=9X1&"WHA')\'|NJyHW_`EaEV{&o	1	+sW,nH=/htty^A-,:{H!PZhkzSO-,{wla>mc+1bxd^PC[8898O{S
P:@,;+
aEi36F.GfRq(p1)UJZ7sq]&
4g6)@jiZr	)%hRMJuISsKi%C3_^wK/#8-+^WrNC_BQnP#QH
T{ad2|v3XEn{P
hCAT z4L	:Pkth:dAICDp	t:-A)F2@>Ai:Z*A^@6C5:Pth:4NZ CAd*"St;hC!t:t]rA
1C4!MZm"SthC@Z.A^@C:&e#r@H_?>U=JW].-|YTgrNI_2qg>W>|-YG7%mm@ZVnM- }G'(n,m/~SK75;"m:w@R{}gfk;7_Tx_=E}GD3v&}5B+"~dwKw)gwu;T;~D{Y;ZtyI,'+jgSvC:iByGbZKjWowo~Q ^: K6nL_(L\ &~*~zx{TnCRihM+w5~OrxOiZafSBQ)^Y92k^whg'BF50OqzZK+Oibz]d|>}RD!['|Jo=6K{2`\*d|8X,Z)Y;KX)ze&HEa&~aB1+vvp]\{X=c=5'_zQ1SgtW;RJ#<_z?\2G	c&<.@](q J.%QSlDsE1e='|#-"XGRC2z$YOg_G! !#"t8KzcztYd>YC0YzYw:|Y&Yb3z>#yF3F3MBF3DDc#8KDt3:Dq"oZ[AG0"	"/N-A$B bEp	""[k'B5txzxYOvLkn 9!)llzHz6zKzzHzDd=a"ds zizzkERXCMDDkd*v!yGG3SDDk%Z#!4d=:OYO=YO]YXGSWD(!)\|+!Y'"td=Dd=td=Y:UxHDCB3XCRBYC3KB)"IzJz\Dd=Z'LGS("# 5Y2<ZdjzzZUFQY~M1ScG>>\Qu-5{d3GCoN6jVTNox3z3s&rc+%:5)H2Cw@X_UmL2G^D@BssGM[[-*z|j=ywC+]_WzyNgckUk'_??xOXJY_w=Sx0y-2O~s#*=lN:tRo	
?8?'N?7|M7N0?|_M-:;*vyr|rE+k>Vrg)'fh	I9W96P93K9| #>3_Yw/}:-O_MrkrwONQJ-h`QJkg%/w/q<_*Tns<jNYGu0\QUBpJ]-Kwd/d7X;o8[O?$4;E
tx
.)MjSM~P-SB[VQNBG'	m|u/x=UOG,4NXxeS;ew0;I/4YTK	}/( |yW|eBc_.j-O)U~MXXU{{jH%fZAse/.VOO>U5/LAn7jTA%lW~r+aElB~Dvadf/1+lJ25.4Z+P=){	&u
e8a|?!%TU'Fy
XWHJOv.#Vu RtYMuYUJ23cissLJEn_QEwM.:a	2e~.kET, j"UEeQ`b 
&GRAi-YSIR5U5T5y">RA#AdM1A"lH*5+Sr](}EAme<n-
n3xdU/cx8#
UUy
BdcYA7dUdU*y@Ao
/VA
`/`
 y `.@`La$	00"yAQy<g?")3<AyP<8< <)<8<qa`c01E`"1u*t0 {Sy=)R<HfaD	0.(01Ep6a`c< #A
MA
` Wy@UaLP`0^al`a,`ad0*00)00:)0100n(0*0
0<r&<X<.<Ha0+0l*
e*hA
`,<P`G+PA9,V,fbXy*<<X<<P``
 V:U|9.M DJ{n7@UU+zm[:H;hPC}?J^'c}_GOL07T^~bFM]?Eg%?N81p}k(.{?1`9KP/_}-?-7O<7uw-~@y"<oW84~Pi^\t@U\wU}w%
b^>o/o=c o[[_iwy~a}qEJ=w!v7i=c?po|o*xo:%xnuko1}HS3{*OVzft{=SSns^	}WJh|s|co>}+l);e{((K j)PH@!@R
}Vx8W8DbPQE+58pE(s
R)INs+C~HeSaYY[cn7Fd#c2!q+;pMUu1}w7V2a7e(<Lm#}JZg)u6#9F}I5Tfz|=-RfLRkQwmj90#l6
{ys59Gk<l&:*8P7?'yWrdp>L H]A@&&>`O]$q~XIb'm$q~X F@O9?ILb'kkwL;9GwTFb+#r;b/71wb9Gl1wj9G1wr9oGlg$z9G) H8GJ;R"*pAcBHrF(bH2~?Cw
"d~%]wF(,H%p#)H}I8G*;R"qwJ#eH8G*;R*QHxdIy;R-FR.z1qTwd#5)H8G;R7qTwt#)HP>1#%!H9G;RF:rw#%H19oGv#e$%)HQ9G;RVrwB5^)sVyyJ+'=60?"D[qIUPrfgLj%'XLEPwa??eeXz[x~GU?_5C0GEs0?5Osa|Oe HkLaH-|xxo|GG-&GV]dH~(&GU]T(~h?`rtG7[!$Sw1c,!c~%:[wc-!_?fg?WU#?/u:?+'=?U#Oka g{
Go ?C|N*~kLU3[?~|`rdG
pk|-7[??GQw-7[??LCGZUwQC~hC'`rtG!co~ISw1C~X_
j- Cw3X0[wj- ?WjVp|"cX?eI3VF>R2sX/scF&TiI5;n?WV>^^pl3['>NtTlnTS^}fFJ@VFwU1>=|k?4nig}w)*g4MH_-F2$Hyf_G[yw%(WE}ez5Mw\qJH&)sw5]ejt7XK{gY
mk(_/M(wyo3{'~8`1]]	2+U?=iFb=vw1#zF}m$rzYw{rJ ]GKoP/B}XNYt1)>Hm;-nvd;=c;v+#xei eF~=km=:-)3s_Qr{T+_4{e{+o=(wxc\{; [ -yR<:X_~$t*EC2P@
bA. h@A: dF$oHD@R%bAN H$DV i .@"Af  6@Av H@ B  A B  B$
F D B< D!BL ABT Bd a$Bx B# 	QB' 
bHBHb`1h!\$^@"!f@fqB9HI<F= q[ !@!b !@#@!@%b	`2h!$@(#(B
!@*
!@,B!eW/#/H"!@20!KNn.]u3G82)&wc{ao-oof;~lrd[1m5Ad=Z*JmfTlHint'bW:%|X[me7&Vn!idR&c"\\-AYzJjz1Zcz!=zQeJioS_z3w4K	|Puwiz[.G]zX%<
="n9DcjwTb[@]q}Rfz^.c]oz>lSB+}BIh0#N:3|8^O,Xd[6>p-{6FWGI'42FGS*cKQg*?A]N-{Nr:uqEFEgzjeFZ`=HH62j73nL;xT|YnJZdmfI%'9>Q-0cs-ly{,_ajz[
&{yKc}=dHKuAgf66cm)S[sb'r/QS?_m&Cj"(lSq6*Cl;(kuuu_w[)km+U|G3,sl#xtG+tS5F"._u2R&_u"2 qI POB%~,O'X?^[aCo$Og$|*'lw*?n_d__&S~NI@w7Q77mXQWO2
_!'!?_/| B/1,?u?2)k~X{R]]t	;lek{6+)/Z#zmGVoz]YX-1xg7m6znyfydFg&k6M%{2y_7[?w\ouz^5{~#WkFn%]2ifHzf-wMBWu7Vw,FKnL!-*;uok1;=XJ?}DNb}M7aj6}ot>F	o3
}Cmt={#f}j'PK*	GGj?kMf6tqn^s8usM5=e\mR^Zzzp-} =vtg}Ol3;Q7WQ_Q=yGGw9jsr~AZYMymi\X!$3|JC];5'l;;7CA$)+z/5GAQ?bLT1m&?g??&?/Q@p-lc@v5@|D~4{u/k&)~
'O_O?n&_u2?!B4$_u&2@_ JI'K6a&:]e^'~:IO'_&^Sk67oE?W.:MB$'?H|?	O5	yTlXWBx+X:]TM,_
a?F	t`IQ[V^hVC}6Sc?ldwwV 2mEhlY]+Uk'.ZVZojBVGx=y7xqyxqf}MB+]Rl.Dm^Z=ZGk^f:o3Tm7~ZUQWwMWQb|,:JRCWfh]G]Kafxq5".W
dFoQcj70c[vE_3{|sZ"|g-kW~u/a}9H{kC>t'j5=j#fTG5FmWN|:Ffr}5{ty]6oMH]aN\9&>,N
]MNOTSiGi=ZO@Q 3k._RS[73gd6}6W\/i6Gmq+onS-TZ7!AMe^<:X_~$e5_mS;'{w7L@5H)D|?TlU2SBU}5|o1OO3;35GT5SLKULk}_3~
jG?_ORghU5T!,L{UL[T2qG{>2qI Le\/J$XoO%?'&oOPwT7OBHb'F['O.S>L>+LC}OW/''?N|?	I@n?d!7_!_O+_
U|?	G4TW+Y&rkSI?g?,*W$\U"b
?pk!C"bwKYC}[[i9SV6ccwxd(L*]fH?k4hS;=xx9EYU{1ON#[m5$&6;x`ZC`S5HU9B{@7brr?,*p^|'MG#/>q={7;Q@};|IoWy97Cc;;~<pck9Jzw:Z;cxGzO=WuJt{"jMG&9"mG8uOln|2O^=tnIswsnZyT++Y^S_@luw:q^W!(W,W+Uf+f+Uqh Z 5h ZZLuZM@kb@-D@"#$H-Veh] Z/ZPhu Z" "h ""
 "X9{?zY'2aJ7#'-sU/o{{c#xSz}7y_guGnyys3wrU}pn+xoZ9/zI,s9y^u]L<.=.v9jOp>(#YA:We/JYf`6r%ClG!]Nox'nv]O{^L'V7qOu~YVf$Wb	CPDD}"~e7<f-D+R-[P1Rz@ DK@(
D@0H-Dk3R@<#>HQ D$ e(")*dkD#E{4#ZPaOCOD4"2]@D#EHDugy> "H"OyH/BSRfLp
ko9wn>p~P{TLmV}%k;[?e."OgNrs?QgT9?Nj9t/*5~=\5m>?s?##c>tWDe){{%=)z}?))WUY}2qDF9~3aswlpwWrjrZY@}k jl($p~ 4t!Br
f}CUWB<UOOosH\pq~?eSI.v03p"?'dfgWkW3?{|rESr""L@T`?"[UX;0E/?f]7+2onW<};t.-;p	S(LS8VBr
n?dVFE#}I'i?%]#<G	#=KvVpU"Md7}rU(~zy
FF
H "8GIP\:f\7~?+/gtj] 	<juNP4;:+%~6.N^dcVogMcGDFY}8]j CA
(`x _fM:%;+krFvV?"&?)w
5;q.1=y:.u6QToF-s^~vO%+^YxsG-gZzZt^2F_kMl7dU=Wi'v^?{Q:K#2gXTG.Fz"cowW|'[wx}}ZOw9{5^r}g~"{9/xyp[{8<QM\1t~0Jf:F|]:8G5t8F+:G03\LWq+6-_x'87N<H;.nm68}M+[HV\G/_]5=9g6uRgmZVAwys<ys9GyRC19E>6yqhg9O4C=O/XE<#@D? @0e( X3`%@0 Fb=@0$ `]@05d2LxXH;k&`$,N 
K`*le$ZFb`0,@Fj4y,b8r `<g$x,Y@( 2 @(*R @(+5z0 "@(	j *@( 2@(j :@(H

1~"g9BP$ T	eBP( T
BP, TBc&BMEBP6 BP:g9)#y91%sbDH<	<eLRuodXuOUZw7[YZ_ccn+wVRk,+;/-p#Ly}~Thkt\1tw%skq_IF@|U .?'OO_F73mV^F_*a_w{S[W{C<;{78Bf^z{%mIg	?=:1Y6f(&x4JqQze[F-o@x QGebDYfm\[uowTwO5=,}{7EqL
W1;*-G]f'![%>91.x@7cOIncqRjv*]S\8Jr33gs/sxJ>"s9o]=i(7cl;k
q>m=45#29)!6yLfNlf;[cN_wL|}6=zOh3_>Lvl6Q![~3|F9{Rls
5oxwLoz9;wtPVx?2	h"t$d@t> !Dq
P8qwF!%BmZ@	/N,f,j,n,r@333 #!4"4#4$4%4$k$UNRrB,"|9YH!HaB
eF
gNRHs4nB	
sNRs4gzSsDN8YHT`$:p(IC'4$zpcE8i9LN]8iHaAN}8YHF,$*18iHNiWP]A1N%
qA8iWPD?NY[H]AI=259iH!QH4E@@E4= '8?I)<50>+ugm_.
O*jwYejGoW-Vc:<S0[AzN|	mx#}+so&sY\[+}SsN?-3mF~!a]AwZ_3~uj/9!j?_/ru	yVs{Vd%?2hCWc2<Rw$?Y>+?V\7Uv3O,TpgTu]tgW9smB7}/>yG!$eb=zTO:]mvN}NmKmtmxc7?Z[Gvh'Z{SYL?b\3=H>x E*"R22e/4J@\t .</D a` AQ:S0R @@4Dc`Fh< F!19GH*5,#5.wR#24jh^Fy5:/CehQ24
^F( )(x#HA(P8HD 4h$#x1s7)YCGLk ~uu?:U5*Wza\)B(g?[UH3}uFT|qBnVUzVvzN8:#72j~usNgxU/OFcC=sP{qmwtv|od7Cc;"x{Z8KWO7tv>5:K>9VTAlGl4k,9bY.9	sJN/kHCr_y%'@{;$')9Y+INhkwv\CFh_e]S	|@
tyr9B\t+owWIpS3/&:VuurLu@)\B,H:c`$.>PQ3r+)k8whk;n+xM`vYv,cJ)ekH8Z*JmfTlHint'bmW:%|X[me[-FMmt+}/r4Jq	*Wt]AinnZkA;~^whznoynT~+WzvMW-#$0Rx(.M]yet49q7['l	+8m|x=`1tco}9_Mj$T>JrOm*cK=j*?a`r	)WNEFEgzjeFZ`=HH62j73nL;xT|Y6#enhKvfFTr6DWz}V/giLec|w'n1n*f7HgXzli#)]#mwr[4CWP^j5.)BTP{-z qF(a!T$nl<L j0(o|E4@UCA-@
sM4Q!DgF4f$jAo (q;n<A @n, !@#I2TiJB2xZj%!2lZIH290 !/$1jI@j $BzY*
BB7F8 d8H!{@H!@H!r$rGH<2D!$@%nL d7H'$R
!@*
2!$@-#I.!Aa @1nd d7H3X*|L3T!$@6|!@8R%DFt	z0}3rr/?woxxTs7_ZI9i?_k+?z;3z?tpcdriv_5m5^UvGa.@2:ro\,S}mOPB)*|'95h 2yB/B^Xq9 "1~3;v]>ycm3>k}Zz;Mwz:{_uN~}3uGd$'kuFV]Q%==l*g>ww:<}r@	O\eq+nuj-Kp;\:<#&rx8{ctovp$W;L~21>;+wU:o*NGTHgB42RDkddLHn_ PD,fZv)z5SPkHf|j\hvpvOE"2E=e|v	[-#-fK&v0C%7==r1OKa[&[&&[&6[&F[&V[&fa`db#1221OrxXx1j~&]72_w,/j=?PjD\9bzFw5_1{-{mXf:z{X@8`vm)zUZ[l	5j	l>A\g-<%g+__#~=F[gpw}i~2K6<r~?y'S{Uty[<Lb3+:]kV2)k.L$!h,	JNmxL&FebE/{)UsEK[wS[ss[&4<$9gI-rJTNb 8#)9`/EyM
_]?L]v2pj,^#IHX 7TcY_k)U3w/kIm8sVnhV)g5N/.<-:NtO*/M'ios#Eshq;[1ki8henJ#im?;acHnFOdv}wq'_T0Tx2fJDI	]m!mS.SVgL=-cU}?[|}>73ihW3G2WwuP28=znxarm0nZM<`ig_OuOYw|p9gv||x>Ddy-&_*I6<_#z%\lAdYWJ5 E5nl 3`@D9#E:CD@D? @06F 
 K)@70  `lQ@
f.gb,c$6Fb}@70~~lrYSr&eN <3WZTfO`*Q_j0qDFeL kwN^hHl6~>uW\+|jE!_QC^EG~z8T|:&uk@|U}k?'-7/r:spkj>`m=~'*^6v^cxQpE?+#eR}nOS|,?.u]>Zq2kZq8W??*XRfL?(Gu{UZw+	\M"Ma\q^;+b4t|h]F_RzFi*f?Yi7$IisrUh`"]m|pq[ms]-k#iee_U5:?p-.D>p qJ@\) #]1 W*c+&;Xc+_.;@\ev*tT3U]yv,tPcV`B-Z;j~j:kWsJS~g{\-+.YN<\+3rMR&$\monn3{jQF#-\ijFumVl;nt{i{_=E;TKCu%]wCN[;g\^5v,gmGeDGnTb{|k?K<7wFa[Sjv0.{\JJAG*\4#Cag]{uWA=I6JZGGo=Q%y[}l.e7(oYLH}>q\EM,v,uONm6x7H;H1Qt{2c4{fQ2#?Tb9(M=uz/s=l=k7b}Sa1oB{)QfZ!2D!L#J4ps~
tI1twu~pe<i	do1	x7d_p0;;R1&C;;;jR1^8 C;R1X-C<bcAcAc1H*Cvb|d(C<bdAeA<e^*WR1r#W*_u!sR1>s8H	9T,C;/9Bi :R1=i#>HI8B9	Vps !i@H?8B9mF}0ps 1!~Bs B! =BI&F' 4t
B, tB0 t-B4F5 c$B; 4B?&@?b{q?1Ot/LK|[[_|0C!_Qmo+5`=^C[-?Y|[9?C34a	=Dlypw_G(jl|q~x}/HjmY97^1>?t]:n|R;~r{RZg/[QbRmN={)!*_dM/@cg,"YvoWHD^:"tvh1 ZhAFjE5yZgUyZguyZVhm ZVh} " H`h ""
 " "B "h"bxfg)rxfG)wD$"Es]Q:iv9J'^trS@q&q\BQD#J?aS9q11chJ~l(/GM<5#v&tgLXYY223S:#;
+^?%+%5kb,9*hsyC3
On:rPl8O4DOmt9ew5op~]?4=6<u_vm]|m^d[]+tw_jn.F!sjSRz.5SlR:+5.RJEj^pI"y0wJFsJk"y)5Kj^{5%5Re6Jk;<C:]k;9u@\6|nd*#S2SRs.;""h_5|~^_M.fzYS*hP[y#xM'}K}K}K}$7~F?+7f_KL19ki)Cs,WZ_Kw(sOUg4-uw]#hzzPxr7Vi3vessyV,+4Q{>2Q&jr
MHt0$BJ $YBZUj<^J1)s+xSrBR3RR,_vC?GFY??uezF	N{bqcoh(~+<`akf?s|1%;Gn{s]~u[>A<=cjd?G/3E%lg2%dFHeFX5uP]fwP	vJuPkteeFh]fvWYfj9dF&|teF_bX4mh	Fj|"*lebQbVbE-Z7 N29mb_#a?<*f;7\Yx}n;rO=R[G~ttrv<c_UmW=lGx75zrO/1v/<	-}W]Yu>8jqDmW{j[]y6qg}zQO[]tUFn)iEjC!EU;:z[=ZeovQsO9W>$9U.7l?uk@Q^ (a#M?x:pWbM\Q]|:bnj\I'>SGG=Y/uaQk_4m/xw	ER&t)wM
M`vd\Q3W:;2hF~C_mELQ;}9r>6(=5?6W~zuNi9[Qal]\7*yzW|gY?;iG>/7/7kG'O9 _8G9+G$\Up<	8D|$s.I2W%%I{TI2qIi*IeEdJ)HL|dJ.$$IOLAEdjIN2/%?qxI&*'d*5([I2=_q5(cI2.$F$n)$>I2Ii*I8x.I"I2U%t%%I^$]dZ I IV>I2y5i#$)$>I2!I"I2fI2=JiKLUI2tIi*I($IIjz3d($$IFUL.I2]JKL}5HLm54ILUI2O@h#ZHzf[@hc@hzk@h1uw@h#@ Z@">Wh%cE
B?P t-BO1_BHk575eR|s?Goo_*-^V)s})JF+=>N6z>>{a_AsJ{nJkkS[*1Ioq?Q<$T$]#gye#;O6ee);n1f4jba$7VIe:(6~k\A2X(?PRn:dL26)i1`2WSO%\gd>Sq[/#J60J93J%77GeVcoP4S2<+7(g2}|*zw3+- U}G,G;G$vG.q,GlG`!;Yb"ld'Kd$V%f2;CKS[cks{Y@,1XNW %`GKJ,)N`GK*-;ZRvhI9z%aGK*-	;YRHU\,.dIaIe%aGKT-);ZRv@r*7cxo.aGU;gh*]|ywz-+3a[~{/}u{k^]njvXm3>}mv?zSag{w7?
>>q}oq^'goa3ki$k?55w~j}qp~u/_UKV%=/dMN?t|LOQxE<dwgJ8Zd[a*6{fVa7gdUX~WE_r4-(	p8NCo,xN[/cf>]:m/3{eF)lfTp@ItZ=w^G>vfVw~OuH3~3$.4p.$+tX0+2\jkSY/OS)+{c<w(zwxNQO5^4H~tHc(~t@Im$>IX `!Z@!b@b!j@H?B+{I+{I+zII7/Y*{gKed/
2/-r~^Om[*{2rE/	*#Tn-o^7JeK!R*Y*{/7'KeojTNNkw`TNA
.T$RZ$}RH*|klVH2x!K=2eD&_fKd%LKa|@&_:da|@&_:fK|)/m5: |U"CL|iS"Cg3e%D2ez}X&_(ja|y@2T=,/PuTLL+jLL)22D&_Z"/W~LL,+2eo5|:[3?~9IJ4+g_9+2_l
WaiJ/N3/<#l2iByE+C1[T:Pkaw^mfF0O[*5Awi1\8RPEZ]Ijhci35,=9F%#Q-jLfl=_N{fWzRY^Ry`w|eZu@|moq}qn7%4ibmN5`6tc;uD:gWmZjoQW=vd&0'SRMW'.&'hiq]#jZFo[k~N_|oF~v/{T-3sWrb+D]o468j7Kn*l\Dj,+{naP/`d`yr>q*jg4SlvOlv)6OlvFX>bbkbUf^bbbff'6qSlv:'f~LHfGbkRLn>{?q!4XL.KA]D2ruUjm]U}sNontw?g'={C4;Z'hv{h<L>BN[D?fffflD4{F4{D4{h"hL4;S"NNDGS&n0J9N-5$&3f1x%'>e&]W"64FF?~O'^ h&X"c&%#:|DO +iF0FFDFk:%OtSN3_B4z1iSFgfh0303Dhht4?h~#^zZlt,aOHJ*OOOdI*P ?E
w;3zgQ,s`l[!9j]Z\a_QAoS4OA~&N4,YunTZ(c`goE?dSV+l|GW'2a#
k8 ?f/^k_F"e_}9 gqwoPa_Sr!{VC}Q?va$?TozF^}P%OKu%`'Yc/YnCKxKi_ :)%R?@(p]mqqsjswl>$?qP${GB]
>
\"\Rsa*0C?P0&"X?HdQI~>kb@EX
faCiSN,&<oX{~C!\YB+$YmNN*s'$0/cIMHNL)r?c<k=xJy/}+~*_>5rGR3;'G5NEq?>N_la3{/?:}~nvsO`u-]*MRTUL$WI5uRwn>k6d}hZEkWZdL3\)3]<n\R^xoX"9>I0,Z|sO:Z")EQe,Qf2<hgTG;tyQ:<8uIQ'8uDQ9yN;4v&y3K2D"R0^($,2h` Ua= `A,3S`gU,'&33&#51+>V\MU)=_<VK\hhz~N{Mw[&_JS~*O%Ujs\-G|Mrnkoz^'_}6	N5!L/I	,"`"Um]%:?OVi|N[9"h	 \=/$cHDQ=CEGjDT'N$OzPX/6!)it5$5pk1[FQ2bel.G K>J1SXgy@A+.r1G!;o~9924uylp)}YJ87^Nn&%%[]]$;	NJG3[Ol|q=%md/e>uN}]J'emyWzi4mCQYKkK#C+{y<_ew,P0%-%#A,_'D&W"4U&$H%u%W"L&tCbKU&n* X	XRXvX4X:OdbIS%bIK:[b$C'#PbIdbI'%bIXR{Xq<KK"VH&C4$blbI_[b('4^"DO,X1 X`XpM3W_\Bfnc?XHs<w	,WT%P+Z_WD+QV
6[&$''x(3~6k+z\BwZ(GWr	%1`pbm6@>pc9El.b8q$=pUQ`kedZPap{ossoi	n*[*a0b}:
5_;X0vgap,lHe,mP,==7OlQ
B>_GwFwt[g7> elU+CnC=k<_h O[EbJ=4[G6d6^+Txok6yS|R9vgb[^S:dsf&*AYk&.Z|\nJ,<t]>3|t\OUg~+_wQG1Ru*rL|.rVE\lVdVz*cQ;:CNrCv`dDf$d?rF>6WLdXS&ZxEJBTo9\+'X]w:)N]'.'9j3O^s)qMxi>F)I8[AN=dy,lU^XL?4D2#<sT2k}9<ia=*XVqe`:@-m6toC0P0m0-`a!=X`a(8 `XZ *`. b0[F`b`fh@, A Cx q:bp$<5g$faP%2#3Y!"*C2 t/5gF N:dL:5gpG O:CVsCQxHl+h@:dL:dB:*Y-]B 3A:d0~!y!\
} !A<s3C1<s7CRcxvHlUHdCV*CCI[]1&[2BP-OVB~nEJ?Z\>>7
,]5h:M.uaPi_y-AQ"]Br?#{sc<(e(R,D%Y!isF_/$5P4|3&dL-(~W/-51!9\?yr%\PPmr7^XDfv/hl|6|~Nv<T-RVMCm*o[nJn5lY_JwtU:w?gi-_5~s<ckhkh1'bq%}}jmZM?qy6[Qh>{E\VB^48&x{=k=;#ovwJ6O?&m!=Pz
~3tMxoajM.JuSm}/EQ##"=.D.5D&DO3D_%:7>l1}71W%2l=8{g<a00dG;ahqU#FnYeFo0U-_R8	Qs=N:GwiBaR !YeH	)CZ<!:Czjf?,[umV|N?n:#'6sluP#^o}V%[k>9ntce(oZ]8CDFDDF[o{`M4^RH\v@wsRw pEOQ4 	@			 iUE~ X:E`````7 IH5454IHTh@ |UZmimVx %2s$D(DH"6D*D@@mI<$GU$V$36+U6O$EId@-6O18Im${18Zmi+D	D@-mTIgTH"D^f#F%<F@y$6$4IUI$l$_SI"DDDNTiF9jK{$	IIH"cp$H"H"2Dv$H"UI"f#Jy$DND~^%m#jK{I8<J9Mv,$18[Idj}-s$DS%H"D~F#$r$+*I8I*IdtU*UYYgMA?C>V{31vTRR.OJ5-Po1oA!NWDux=nU}Ehph'h7R+:Ww5wDMmT=QiV'u~8=1CY1wKn)?Jw]a5gxlXhw-8(-5neKx0svC>JTV>XU#NbH?XXOI%M3;%5?9wxIV	%	pV%[3v]XI^H :>UXG#E<seG%w*20VRj1cxEo=f{eOzHH+fH\@Zu)0jcg$w'6!zY5-,@MyPq<AsU"T.kR:)w 'Iyr<<s<B$RW8RHy\IyHy|'*X)H'#N=lR X/Iy(#"HyIyHydr<X]"1#qF"#D#qZwf:Gx}?E[\)YVO`X.t/jIJ`zpCO7f),pK2ZL[1[G$5k9|=	F*=ael$|jjL^+{@X7}'rb~[{	InOU-e-3}Kycg3_u:8>-c.z-ij[8h ebro   `_6#y,X?,xphI`Zv2(`'vR`'Fl<DNoebt+VBqN/!A7LNt?%!u
_!A!F+c`M)w?sDk9WMMrGBG~,|ycG_@Ue/Qv;d;[M3lM?{VfT_
-j-OH!_j[;N
/2<@KmuAJsp 
,*Fhu
,\/ld-nZv0]Cpd3Gv=%]WpmX]c:k]o89'.Hw=@X`~{m{G`>{Xgh},"\Ru`@O$fOo!!jUG=OWO7xX%)b=#ZEsv>E>wrd;mAZnXuz7Ds;\e=;7p~`ys${e.3rOT4kt'KZS+oL[45:9? cSUh].Lj+^L~PC|
\,lsXI];XB-?2)%54(]`'+8Vm<b.\oD[{EY\rI7ns%u"EX:VR'*C	\H_^"9W*(HFH:2+l&:(^q9R^!; s>9[Fc>-Jc|_&	QsDfR^EAp4qq4U>)=Ip){~srfRfWr<)kKi+^%egtf,ZZ[rT*WMTF.[K<amV<`a AXLBA
26P20phX`a#X`aP	'PlVxEKM#p`a2X5X`ap9Xh`-`ae,  ,   x  (  ,   , -X X X X X X X4Kz%b`#IMn`K'$L cHt2P?(0(6o3n%_W{7|O^?u_'+w/GQsr(k0%e=$ph/.u]++bJC	_>2
&=f.l%GsWLj/oSHoy}ze,/&'>-HVC\dY0C4xI-?'?0Jn{&iblM,3cczO0>rbA;uo$'!Mzj)e4o4ya.uD)f.G\U<[:bO U=5Ovg=_gr)<rc)~bpz 
du}(A_.0 -.00,PdAb0Pu.0`E.]dF]a #bY.0-.0Y)x
YP4M0A|00 H]Qp wK8 Ys% ,Y<*`A4
 h/ d?@h/Sp #4S1P!
 / 2dAhJpUUIPm?Bs ?`a{z`]V+lwMQfK.{`d_/
?{Jhp6S(xYp6-Z"Wx>5C`+Pw?,O-NAAR-I4?~'GG`poKXLm}^X!{GSL-tMG^6vxl_-u.iboeawE&~boG@j)04n2zqj
vd=~G<=l>x{{M)ns#M~oS8|QEGs/Ole'Xo(x?8 s&6}#5}cCp>s#,s"GOw^`7,-N&G	QL	m~3%1jT'dL}{i2dvGjt{Z7FL,-L3{3r*fg-TXLBlmpu[	8 CF+|SLA+|/iMeii
j$-iV&jVhaRl7aRlA-b[uza0Slkb[i==a>b[vmm)N"(%Rl+Da"MVvZjI"2
_?Vh8WO@D+|o1x":> gph2`N4xhphRhp?i"`"z&I4 PDZd"vVc /evZ <N4vZ&f"J$<D4xH4h0m*+ h/@[@.|>W!_Jw?!U+|#_(k~P-My6v|iKMosfc[3m_cGvJ1yZG9>?f)9g6}80(G;hx%pl8}o[F-]'lTT3G<]~8SvO|qnj/kWVa8kkS(o1~}Zy|zoK+:hWwq
V~4eVY*_U}buzs~hvs2ueCuQQ? 04hG&b.W?&z57c]DCEbA_k-'t2nZzR];=['wG-#;okck%l-<>?TGR`T+A%],J
vJhlW:=W6l7CR6gPR~C"dGF4J%-#j^?Ju}1#}7j_]< 89vbl8b.'/9C1g6r(&9eHqS]x	b>Dbj?wxSw:Y[K^2H~{OY-/^#N[1<cb98sYK..wAT\|lg	,qs)(^'!d'1$-a2\XpS`Uw\Ven+2CaP+C6d.-sky|S08<QWx,<-sscvPsfj.Rsfj'Rsfj*RsfjX\&5lc1Pl(5;4jc9cn?XfK[1Vbi+~s]{1c,m\2Q:Z|QMRcq '5qA$5H}R_iai!A-6qb`:9hFZlhqZlh .6 - 05,L/jHUt~RTuk6r^b&U U=2Tu$R]IUJ"U<T$Rv$nvT$R.WHU/J"U}
j,WHU?T+M:,7IU%UT6AI'dI"U'Tu$R/if@RlZ#UAzTuHzTu}TuW3ER1L? uAR/f!RlZ$UTTuTjT(jTfR#EROIUwIUO0nNMDaZ%Uk6T$UA#UMa%UA	S/j'L7h'f1H]^aj&UMx)T5jRWIU?n&UbOOHMMZ
q?_+ONup}X'X5>!cWEay&WoMo]/\x{39T7~-,Qnc5UxOFW
czU=LWg=^;=/k{\EcsssqJ~ur3 COUvv.n;WWm#?]{.Ujk-Vheh{W0w:cvO[>{{=Yo1f{vw~ynq$N%j 6+8
6T}]g1;UIdb]b\erigNsQbjN(-'(>g aO&6@l`6
,,0 .d`aad6]60Fv.e#l bdFaPbDL08]6H@E+F>E-F@E/F0 F1F(@%fxd-`ae#lcDvlczlc~@2 ` #/ #01p`D"T#,h`("9 #<d 	9r4&hPQ~ Ex [w<Qm4? (|ak BUc #H*a|w~pP:IS+[-HKZzBjs/e0^]%-Q:q_B@/t~Y]&]j;ENtP!z+:Ww5s<$_w\4E+K*RUQ3S]OK5nk>\S+:nOjoyI_6N AdjO5J? GoOMQszJ5/IM3{=+5+_JVk6drz/[:Vkew4;6H]%;2_?*=>7$aOLR/-Ww=-/zN;B[{^Y,tH]L)nsf[$[~RdD97(ZhnZ$ZH}1[U=Jvc~1PGS>4MmOk#_^W3l,'.&(?saRw]s0ZW/i;I_]&ezkk)ui{d,|2C3s?<Y[^^fb4P9{f4#<sT4k)gRg52` i(arI0E0rj0D5iSNCSr<ui((!_4h:4)D9_r>`D90WW5qH(aF9O0N#eSCOrtqhQ1Ar|ph)rJr(]<SQ:Ej]'EF9oPM0(aDfF9$q(aD9fqJlxn:8\6S<Z(wf)JLQrw7vDZ(JF9{uqXQDQrY(9|CQrTE3&sG(nT'R`I:8HQ)0"F^p_$q8eT3R`RM0(((aN9OkN9I8,)F9$qh8)!j1H9&sF5/r
LqQN95q +Sqp@xJ9Wp@xwK9Wp@xK9xa7ftO2zhJ
 ]dM,AoNWnj?c9/H|yhqSD64s\Tt3e>Df/.M AtsYNYlIz(_[?:(|C)(.L5qK.O*eX;Wpohw$G;?n{M?LuHm6]Y_ej=Slbz,zaoTh{MNyk6lO6CfGqMNZ
{}nhmw~'dhea36+'f>
/6D`zBXf~B=Bl+tS7o1m7(L)gnsuFn>~C?Vd8o\U\fVc8[/Zu2|rdDI3N(^Xy0;e3c_63e3cw;-Uin/x<wcQ]u5EBZ,R}XL\D3TrC&.1tr.Jq9m]e%r	$SIvLD2eda&B[$Sh"dLdD2,L'2\	g	P0ory++\Fr@re7 r@r@rsc<<JpcQd U%JJ*Fr4$Wc8$W+Hc@h"7"W"	;\Yn rF%*e6+kT+m$W$WHlHL3\Y%\a Jr%Fr50*0J0Gr%B	]_YWuU
ke,rKq_*P)+HO!03wOL&E$s#,S-~pCb NW>{BFe|s<~7:)lvm</$^PKxwRwzw`N\~NGMOD.JS'7X)U+r5S*2*5x\wy7URux+SO*7dJd
		L9F1o)GHQ7q%o6J5d},{{Firll7Vn1o9{aNaJ3t/+* LTd9|@ZC90j4lC\M`10iyo73toJR6g#W"#F|^GbLz1UJ#BoRxVz_C}>z^c}a2F:R<a*TjI%F<jPdRnxpBS
RHBAGb!?u>mRL1F1`<6)f@3ll(fB1l<hC> bS6mO@1Hbn#D3P6Mb!<
hC>x|Q8Ob!<

hC>x CIX\b!<
hC>x|@IQ6G?8PNyXmOEb!<
+^+(VBbX==
Fq+XSBV(V0BX,-m>Xen/0u#ObPN_ECwh=a{};4a|Cuh%5+;ec$Sd26.F~(dG#?Rg#R#_"+9??`^l%)aRg'N_9lNe^a&X-r	q(OcGxZZ{1Y8.~>sN`syw|G7|uVKUZ^WWn"aUXoe@f%y;{9J%S?$;wy7w(1V9}[N8$z{(V:NSI+w7l`o1yJf:93HUz)Sb29{NQ	2?hSdIz7d~
zyC;k[kEF
,0jAF5kHC^qo5D>E>F)Z6Rz
.2B 0*k'~F6o'^sk'^#^'^#^'^C 	kk)k2E
oBaH!^SC2}5y58IkqkH ,&~O:PFBf852!>5C k5n!1%?lT:
1P72uY4ABjY~y ^	KmWTs=Do+lZNEZNR2UYYk{<l5Ja8k6Ye ,Y+#"eQY~7~.,43@jS a;L"2)V@fg32KFMD5&s<TRc 	r
-*sU}c:lh?ZcU|=o}/ qTK5c7@~z!wdkVawKNKI8_?%5+Z&?8W+qBhW5hb{M{b]'6[")&@n@n@n@n@n@n@P:k #M~o.Jrk;UT~
0~A%]j8p3^QgP|lKh D
	cE+xa QbhEQEhEQEhEQEhEQEhEQEhEQEhEQE[Ck7F+``R DaPNu_r|qJkI g)M-*[*%$O)
rilf?O3XWt'#n/6%
GZr}v[$w{K;.}_/UM;[tOm&fp!AB;&\`9tQC1^
i<)C/-;wph5 ,\p=5kMABvp]'ZNvk;:u!fO]C:"4E!B,KsEae$0:|[}rrU
_7~! {QR.R'%{a	rpJKS/n
&V?:n-5!V4g/<qcWO\M|wJgncE^M+':o9WG7}jL6}@ MW|~dJh {C{j~jZC_L5UfyGrTg:w^"qXfoPyaUj#{F6jj]L^B0<E<eMZrn\d>Rhv'yW?e}b	v1cUAoA&c!=R1.tn{LX#t}j4so=_G{V_gUR.2ERIy!akSNn'SNWkTa{lEwjlC!kSiKJEOfUVOWc\&dE9!@$F$@Bglq2^,jb6nf,p0@,x0q~ $$F1 ,-X Z[ /AB@Sf`@1 <wc Z$0L`P`T`X`\```d`h`l`p`t`x`|``h/P{ #@kVk(pHQ0a`E NGj`\+` Fk ,
> n\+xc q	j`xVkV 0' Xp`!9 N,8
, N,8	@pm9\`&3A
Xp*hc,8d,8tpej:p9"x3	-sJS@}hS3),Le`{wJv]lTLj_5u/jj/=Cy[sttqz=kWh :kOcEqFRryrJ^~'7[U2d^)tk9#q?+zqf{eOzHYjT.*>R2S$_(O\ i@N{ :|20'd`RYAX2/7d^1iaA5$,SQ5)[c+$)Rlek|S~5^)[=5fSpYSz5"upD,PyT'ZGG''%y7(YQpg?/9C9JJ%0W/u/1<"E,c6b1F),;,Wh@_	cJ)nw(-w-31'Nsdt!H 7p$tpwmj8@]k8v%A4wI[Qlw.}pmzK+7gollFl.[!dhrQmw9s:T5,7e6]'5*Pp]MhzM6(c4@k(s]-=RPe6(c4@/	1p%)ct2FQh2Fw(ctp)c@3lPG:2vO2v' 3`w;:BFV_1.
SnI[Z&ZOR
E ?
ZJRFzB9;?*\@lq*]gqOg2{%yl9 )iTkJ|}0BR>OIOcq-+:2&! e2I/ZR_[q
qLYz')\`J1KA\;U
OO(v1jIL)
oMJ`#$/2:"e5_EQ@`cv\^Te~Y=+KXhU}bz
DWjyj|c*U+W-(S9.uqyXFP93(/]'ov8sA8'@N-;?physE,3Zv`)>!FK/5M?ehHJ?
_DZ/e?6%5!m2_]_//xI6jeoO[z)V<Z~xsJ?=^7}o=7$G[[E:=6<xoAJZ+>*v*7\R:_?0767_6Y2N;D	{cys'nJi\K|U&|D|)Q-QO?:{>_lUb}J_r2/>e`H'Jh_%i#6W~ap5W~/yeeL#P-:QUOIl((*]S	GcoWvN'=YI~c 2"3?@OYP+7_nV}XoeYR
[gTS)R}*w}-.z?RX\qc60h#,j0F8X`aF<o6Q~~(
P~3$4DTdte(HhBGPP!,-C1(HhD"LNPR`hbjrzC2teHhG  X` X`;X`[e,x9 ,xI7,xYw,xAp1oyu2X@`OXHb^(`{&wc	`UXOnJ)c'V1Z2-R,5}biuY[ oo,s^F59Q7RSJY5'UXmU)
gj_*5jpUV|eu(GCc;<ZT04dT7]mrs_+'6uf+2;
gk"pxUhsCvoTg>Gvg$C-[X>>7IUxA' [`B6w-Yc[coN	!LmvEv]`J9v{/e5jdt[(hi^Fz`-&5a~#0[Du@mgbW'lq?xh'?n0<wa-ek1_cU5!*py5;']YS'n8MHr3L$$)q!arp#!5aHk'[gH/xT|Nmm3_QgfZjc3K{V->iuj0[)w&fKPgb5zWD,7KQTV<-@t^3.Ah7WjA <K 1@JH J
Tc '*c )X *X +X ,X -X .X /X 0F[Qf10bF@27+pW(2eG@r?- Pn1'r9ZPn1r9[9besh@\Z=r9[ybs"(#y9[bNs,(sA,l2Cr7<Cr<Drk#"!zHn-cpP(B,229-qbs`(C-Pn1r95[b'1'
1g9<Yes~(D 9T!xc
Ns(sD$-$Qn1Gr9K)8M{)8OPSp(#E)-PQn1r9V[bs(PSphE.ZxQf19`[	ZAuLIuL)EuLsJUYk>l\7{G7-&M-oUW6_7a$KM9^Q>crBIq_?:'Wol%?Cm'Y<-1b9kW6Rh=0;0$qn?|J?n};\K# nqP6>&ca?FmKNpT})STrsTJ% K.X$`K]pe
,\.pe,\>%]i'6!DKT]lt+O2}zG ?dDqGP5aa)SMIqO}#  <P4W`Yhi:*RYiZnV=[_o=30('=g~od{yvvI{k?~zw-&_Cv'ExF.+g5UdE7(zOtrq?:}5Rww;9}8+=k4FdtaGRn1%)&=[kb^{\n1w4c=3coH'-
2Af+g8>3-?CVuoS.|40Gf}/1-~GlsIwMOH[(M\gM'u/S3m?&uGz_&e>uz)g;$<>pB.5*_<O)2N0dp?Vq19n[7=f}T5j+ocG' bAN;"v DD31
;"v.D`!bgC:"v<D|"bGD;%#M9:)"vTY2N!t^D##bgF;6"vnDQCGg;<CBGD@D#@DC@Dc@D@D`F!"C0"D4$D4&D4(D4*D4,D4.D40D42D44D46D48`thx "!"1"A"Q"a"q"z@Y`Yvs-f+_#JzP,-(,L!uox-
|4Oh'Ch}eF3JMr1]f:c!:-U?_~[Ah1KG[Vksr\n?etaRf]oGH?yN]uJ(>"#CYaxCxW9JcH1_,zmIc(~.Y>I}Y;>'4t!<z9D)CW;l/^PHz?O%y?dW	)#)~F6#j(n_yO<~W4!m<qO*d?%f$iBzbO>BFx#>H/\70|S~No%l>)(*M3H%wl?tSazSO
C
]kg'a/~mm9	-Cjt s6e[	0t1:ah]9]-?=0&CA!`B:ASBDsbs{`RhVhZh^hbeR#hjhnhrhvhzh~hhhhhhlLM!*"+","-"."/wf{0e9#I#Y#i3u	LK0s`Le\ LIeRQ<TfL*oT T9TfWT.)TR@2)@2WJ2HeL@*sD*E:!I"NP^HeR@32R@72eR%RRq<,Tf;Tf2{tD*@*kTf#*
D*7*
4E*!BmC`HeHeIe>$|U&-\*"*Ie>%LIeR)T9Rc*^T
hTfTiTm2_$RdR'%RdH2>IeR@2?R@2^6Ie"}${E%ItJ*s{|j '?Sm qZ{I(C4[rjPc%V$.nFjlNU&l0^GEiO{EG\LAVnNM}JSsrBzdTi[jc*7LJhF*\qZiFj.n>F-j|[jL[
bKo[#wm>g6Pe/%=4;Wi-\m<~Mm:&Ul$mM!L:jC}mJO]Z<9,\D- vfMO[&f7#W\R1{]i{tyj~R06<Q 4:bTHE#dKT}v #C0HZA:a
. Q 4RZAhSK+H4RK+HkhI
RV&ii)AC+HdbM+HTD$$yo-Wd"F[9G?=;;wFVy 7?ZYpy+in:&axi Ch6/}geQ3v#.O9gwnamux+Z;Z`~~Z+Y{2L9'}<R5Q3bt@uL0c/|'gwhc\~Y~G}.bOWs5D1wg0N=(xwsg/y8nF`V)#Sihi/zt/`jsnl:NZVY0<I_f'[3GF[ESEzj: Xuf0	n_%w+'>_`8!Ov[g9]rG<hwm	RIoB>pUg"WmXYPOeJn;dRijR)\*.F3 KEHv`lU1S/Qh4Rx8S`2lsl?`>l]aDxHXEVI`fl3x8)T<dG?ERl8r=F$e#e(,{J>QG")-lPp0cRPp0gRh85)T<sVRwlXIIl5")T<mw*4@!: e-m&eKG#E]=A.HRvRv+)")l")[*tB#H/lh;)QjR8RTi-mGa@EHRv#@Il_I~LEHRv)RT-mG"eKEo
D'XMHHqQ/Qe#ZeO??9PuTkC&XQFi)!&M[	s	y!Ah@
T8m&t]6	`Bf3&te6	;LAf6w009'7)t}_%Dzc__RsHgm>[uvuY3X}kDtP4WgUt}x	2O4JCL24ed  Uc` (08@HPX#X(I^G#Kkr+97?2:JW0\E+bbGuJo8qP(F)VvKGSD{N(
=k\EG3(T,fo0%R{R;nxlu\nyP~mzxwuV-md]zAk<Tl_\;[.E'|^ilo-z1d,M-|E[t]Km,ze.A[6(A=pA;B-v\.uEmY*\hC})lT+?mX3	Tcg O<b?vr4y@V<&V}\ d3>}Xu?:w: ZG	  " " " "=hlptX D$@@HBHD!"12CDBCDRc@lHnHpHrHt >xGx@?zIXjw?rFk/Oc0u#N=)uSuVO`ET FzRNGTQz	DTt@J|RM|)+E3pG
zCHB<H\}|iy=<oO%RZ,Jn=Rd'Jm%u
nV_*PX."t>eBnGOz,	BTR6S6(89IrLXq9X7;%z>^cGB79@;/zQ/7
?+S,:/7="'^+$?+$GTd3qbR8yox/&}Uw>LH'1T7"9?SclMA[i8hO6mMAi8h_6mLpK$_J$%_DWDD+T"U_"*a .
=s']hSO3$l'];zHvIvM=B"EKb"EKb?#EKb#EKb#	$zJ%?%_%*&~JkLdm.dTkdSSDp`/x{2|{nLLo^Wn?q!u([glT=zZK$]"{,|d%z?Ld*.x`xhQ=u{6M<75*7-8 :68j]^8u0'lf^p%\}Qr@e>ep'6
mmiC1F;"[{hh|{m
oFivQYUi;/	w]~My5Um4'-=Uu0
|RigN}6?-$!j*	*{|"(UaFiB/y /W+k(>s7G,?K9^h]IWe1uc65 wb.aS[Ozz}~?#/T+v7re~?9.I4z=.Z`}DK+PL1YdFj8@2CEDcEDEDEDexiEL_^70+US9/4_.72B*)W'VSNO=Us9v>Rk&x\k}r\<.?$5Vu3m-a?w*{drl!%`>(^]RA~JBY?1L_6r})X-hP\ _T9W{RwnYABE>jms9;5=kg%&`/w_W~Ha7|`_<W:yfPaYBWU^Mmkm/l>e{5;>E7Z{=4o.,=zf_wbim3xrqCz7KrJT$Jz:9/a^9]1~Ti{< k0OFABO:+
4 ,@au A"QA{	 D
eD3D12LXTCd.*f dTCd4*Cd6*x!2|=FK"Q!8dL<J`*ye2R PF)C.bjue`}O0O]SJ&UdFI|tN 5dIt_[\^rBoWo|~7=#Z{liOT	}#wbI;5I6M|[-mj%ba;7HnQ|1#w#` u4`n	#t 1@x)1uQ[n[s7_k
7I:=vF/cwB
B,,x~Tk
u$`,L_I|0/H$aD6C4($C%qHc=`pLjo'mIj,>*MHR{HR{HRAf## GR v4GRGR%GRH4f}Q3]RcQnFKxF$Hm7**SfjHWF)?yRN.\lZ3'4Bq`OJ'4>NM_-s8cO?_^_/<'| }MoSNp$9S^n00dh1,N_^)N1\IKle^iU0=A2vjH-V+Fl}U1Y0 -#=#M#]#m#}###3ec SVmogHW
Zp\SS>#;w8Fz\:nl(s\[XSu?B?Ft2gEW*R^VLBmNbsS?3  M-W.A5#YEXnxo<\\Yc	vV/.[x@n(Oev!{.)Zn|ksIt;}BcF	yx0{S`|10eiNww&,o Mn&cGbB0fC^1iK/qqhPxQ	bJR8E8[8vf10c~kq`L'0|CqN7vi<MZ'f~@voh>%Nx>Y
cAO1ps_)b5C-7*1q&|uY3D/(?0ER)DaT f[:c|l98eAK`uecP)zK	 fJ`Ln3&d6=C0}&
`4@r&^,~@&'NInInInG$;$[$BpBa!G3Gd(ndB E id]"n"nHHH+HY$Y%.?s$w$s$?HvBFId
dK"9E`tG{H{H{H;V$'#*$J42J$M0HLv=#Gu3F$$_HvIv?$$ J%&IvIv'$S9=E	na!
H$'ETL;@$}|_eq$$q$7$$Iv?%Vh
].v4pe?5?,e??Jl[3OmQ}SIAvUznr\eg]4\Yk| oc[r,J,5vBBX b`E,,!X bVEJ2b{,gM}9mm.!Jm$$h/XQ)IS6|hC!|-~5qmg\mPmI_Y{A[m\<Yf6p'mN7y@f'4lmYnRGS}:;>t]>cqK(?Z}YdjgAt~/}Q=9@Z:x_O~gtSsag5_b2jJdo:kmbS| vZgU;~D_7'o))QR!dVfqb]=l%~a<k(m9,x= V
8UbXE(#k"~UF*AG1b"T*BQUiPZ9V
"p[E(+V.tXP+Y% d3lFh VT!
l V#f4[p 2ey&sY~	.C^g<\F>FDNFD^fy),/ Gi\RY>
p2(3*7Q
N8tKN^L/:P5`zv9'h'\kRv]=_UPK_]ndj/cvRQEeJ#uQrBftc@W`)^W7(/;}bZAZm|Sl#S
,Y5*wo*"6)cjur?h@e\g?9?F1I&#J/ngO{}SI#gy)I]
u:wJ(~P k2o6,9	u;)x]I(]g&LWU\~S
kmO2nH%6EU.{]N$Ha|7E7?<G{x!W1SYPVu'`8W[awY/\h+kPjf:uWzYv	(Yr%rfySOk=_dNonW\W$4.<X
wi24G(zMN{7Q-5 T6*5=q^76zO#q-Y6=a;H^|Pj"_j(]eHI(;FjYj+T[}C]?K1w3&hw:RYJ9rLZt'1aBc(~xm;}sB VrB|ECBB$($+'<N<;/txhsQ-~ X`pF\R#6{3lN~Wn@[#ZH=$<jIx!
mJC%9o	%	%	tHgD3F"Y"*/U$<OW.<HxHxHxHxnHx;eKe+e3eLs!)	2		2	^	xgg''Hxi<{!$(+|W&YL}|#2		\dkyc?]?7){:s-leR0){)ccsl\NW?7'?2JjO[`7DW#AslI+['=[X%ls9_h,eV|.|B3~6|5wMf/ZKPQm?L5 ~N5 V-tYD5 ,W`?\J_8$zrqTkC&XQFi)!VMy+B	\q{@CkV1`j$Q9Y$H$%?@*PQ+ D&4lX VHe @>T S|a!< %V
>9*N:
>CS	
>hE*P$T[ 6@pnX`U
> )V)
d%&dJ'@,HuK TDBzqe{e:dSVCQ*T?7<8+xG^el0y/Wp =z<o`y0|@q	iGmckvuI>j3@8Y|DRwPR|VRXCvcj~p`
Pty?uEJH51%C*%`2j9Q2V`f7]}}Y\Pc|*=FR`>
IAj@7`	M0o|  y0'_I&@$H&/
C J@.l}@2H4U$Q|~}e@`@QDX^R/l7>JYZu?K+9$?:\xQXek%F~P`Av[_s~"|wT~{a_ht	?l})Wv;/>|W!.w}\oT-3B?Z?k>67j+b+>)6IneNo+ud',^QvbZYV#ya57hUSJr_p~VQ6-]v2	sl@Og
70C`VY!0"C`DdDdDx ,A`DdDdDdDdDd0'X!0S`6YHCa"0s}|b"slE`$,+1gIqgQqYFI?9=4FB"<-N7eyaoO{gEbX	\l/j`tcyuT8vpgZ" %W,US^@%OD%O6<^Q B)'SVf=O9Rs=4UNzmw\&7]X(/bb=eZ"5 1H$\^?B2LQ~@_b;/SO;bW_.Iva7w|]~szye{
Go{J>0Eb)fY#2%WN#T#86r71nF0kW)vV&<<V KEv[ qOIS?"Q{D9Rnep7='POOs/JI( !pl()gL?^<#QOL?uC(R2^Yb<peT 
T eDY!%*cdHo^C)RsgxNi"Fu>BjSs&>ZW>ZIqc~nFm,%IA)3{a`Q|IrK~YM-[6<Lc|v9N"Vd;Za?;Q
o=_k
7IvV){")~X:]@&@Q5XA{Y|F,2/|ggvec`2-%eRM	eil|Fedk'_Yws|gve%eq/	v|-e.(e/SKxe
lb|+{vIER|XYev[cj?j#AS8ateE7,<?6]umk7p$e&^

ao5\#6>y.7Y%:Kb*;v,>,zR Rc.%@e	Pqo%@e_JYtisCQPS-T]b7ef/4tf_+/jmE=pq7|rpstc:h_ Al;UK]n~Dl#,*+\5[)P}LQ
P>&v:}/5apK^@n/?QP	M+m\*9`s5v-9rIhg_8|d7/ns6{FE(#5Y1q!~JMV}?J1J<+58mTh<AYqT+Uz~m.U+5PuFm~#u ^ZX#0ma`<lm	Kd `#ZeDxw^.oF:$:~;qOP4gJww JQnj
Pet(=VbW?yQml	AzxK$(oD9}1J,U9?\((cvygY(aY%KQH1aSImoHzh{oyW>./R||,&BOlUJi4SJw~Q(ttxhjV&V{yw%? eHd|';B =cH->I6jX&q%a#Q--hpZ8AK\"t&K$5Ij#%I3I-T"HRsBR3\ YTt%j$9jyd<INg<INGt2d5l$9jHrNIrFI$9x!I<INOSl;'AIr6`;*YIr<!\*!|:2IB$}II\^WEL_?g"V-)k&j"J_-~t}9yRs25]?[	%Yoi;eec9llh-QqrB!rmovo?K|p6B>9!nrwn+_y!>!!!^ozWTXt?_ozDv!Hn3>*N1UW*@	r;	rQAQ,*EiH/	w	7m2222{Q&}Oc#}_(/p{	mRRHIH_IHRvP{e	/DHc'fSKvfEo:9r=0Ge]W;<#8*FVt|\Q{{3Q1f?%~bT{|g*XO6JWND;H+s$M<OEk\T`UkFGe4JFi4se}{47=HV0"uOmfOxi>RRn?7#:fo1bKvn!bza74nGP; hb;q9j^?\O'(sLiZGaJ<]>hKY D:nxq\z=z+/BMMZ0jlaT-S`FL)qjsjHohjj9R8RK`U;+u%Ynt8RG/q]RKAt,CJr8~njVfnT!.Zw?qMmO5.m^lG&%"Qc*~5zK998{D$}$,+J"NYBLmN==>f)QrSv9'f^Y?ec^j]5wu5U(M:UK?$yXaqPA?:>up.3\B+rlkibl3XMFNqMlu,Vbo;>(P7-RfWV O Cb4]\$>b#G#w%RE^ UQv-DjCews.:VUXYso>PO*m<oA7~"4D#4};lvyZrO-NCoy6tg-N#s\eegK7\aGt9Z'`,,!X"Z"Z	"Z
{`-&X{Fzl@!hEL%l1ZC*&HOIojeZqjuJI^Li3
_c?"{)'wz^_G(7&lMk[no1pPLW=ye86h8VZ6-:}CT.8(U#^L^]_)qVfF%73je2{_nLz4k8+_+_]>O\
J82S	Z',yO8@I/-\
fBk`uTh(%T)H~E{>xk
8JMSg'c8%:C9*#Mij5^{A9'#f_j|s)[m+k99%REA-X6Y-~Y#gp~j>~_djoUAP5$9\nJ>gE	>i]qviYfbOc5f;l6v*J	A;b;j-Ukv{c;j5hG;j@;DD[dJ.2{^xJsAgD\Ao9W?pzq;E+\|.jwxQW4ep>%SAe]N=xLrw+w5u)\kEw|p4
nWvW83 ,V1?XS`Q,	J,%	J]QUfFeNQQGpfq+*\dOp[lT6T}25}X?d3hm0fr)>k?*R^/ZrgeLFV<76Q6\m;7Yk^Rbwjh `Gz@T4;6	djf;A^9yNXZh)WGJRz/%FnTol=ASj0R=k56H}(R<<zqb3bVoI^Ur,'_H >^i-?#K#/Q_F2?f4vo?O(Z"MihW~Rj`>Sg~r?KD(~Lr^413q)W~%n	Zs#/bR{BY{^f0D@%Z'qiK90t)	t)z5;}Osh#"Z[5Bjz9w!b!b;1y ^6c<h;~1#D1'DnJ/Q/D>Jf7D'<"ZKgH&%b?`@ZK<Ny"7I0O	D0OD0OD0OD1O'DhkS~@1>y"'y"'y"'y"'t}1\-9DP(Rjj*C*-9g9;;?2^?/G'f)+?i\SdlsGyFHjc#bu/uBXLI7Q:@z'e|'~O#|?2o
G"n!iLSl~Uz(__PUCQ9CPKk5Z+b.?#&NKz.; PWp AHM?8'VD|uD|. u |;&Up   '-2t[W3MO+x7[d%glof{nC&kG\qo~6+v/Ccxcqm|]q]w5+0e~ N%G|$D9 A?"~>D9"E>7"~vD sjIKL*?EyG\4q*Yt#
wC0=z.
[2oLP_Ls=2#(8Q!>}&	1S9ju\h0xV_+yk5* /kz kW8>=Q>5y?Q7i|dK_i}MaYI|1E.?$itzHc= }tw	-OI_IOK{_Ik=H$s{HYgHv#l]5[K.IN[[~?~/
$~4k^IiwiN=}1}.~_kvT8&>-Z[!"Ch%Dl)Dl-FbjB!b2Vd=Z!&"(ChUDlYB/@z"+g0=!D)[ bA{CEBoBz",1^=!6Dq!bc+z'QUFn=t8#gl2AirA~h.2o%qc,(RZtKxH!DSI0ey?G)%	z8IlEu`\"N-8}pEUD<  e/\BU}^p;J+IZ |,7	@?/]66_++hwVfN5AG)?{/r'?zfSGTuZSQiO9GoP~RX(9Or'|%6eni7g@;W(!@X>.sAt }p[s"ES	$<FfH6p
Ga(4=	?+?"~<DcxG?6c9xG!|U0DZWw~7V
\?07'7 _Q#F94d6+_gnfN^~n!Zilf9<T+ W1g)2;(x\O8l)ec}tI^j%DAjPWd9#$+nTC	 A]VGE*[C<7Es\I;f_4?pF3'KU[S;2"15%5u+V"5EhT1M7B+~u|1WabN7x+ &bnlR`GFa_cB?vGT@6y_.U!{\{7b<J[<3)-\	|4Z{o^2KVkj-ZNXblX{^o5h5W17M5)_?T`)<r?ekx7][<.7j[_+foRLD5p(Z/6de//*
\PS?*JsV:Yx~+6rTUViKFTh -ku]##"z+D\,O!\?^8Yo2G6:s"<pg> F1#NhyrT!'E%A,J0"dTO-L~/\ 9/[bw-7<(~4M$y=/'^#.1	s&gW|VDy,%~OCLP=bLXpmuQjQXY!~FoiDGoyD%5EB b b b!b+!bK!bk!b!b!b!b!b"b+"bK2CDe----F/Ya*mT&Tr+_U_f=h|{WE!:8"ciU-boJ' ap?bo-N72r'w"mltQpHP;
/]^VG LTs,oO7-@|s~lH>\e76@7*A8VTolwmNiciKp#+QX!f-*tsGV*N)TUQl0XMa{72%wDJ\j9&CAN-s-yfvuSf?rJr/6wrn"t7]nzj,951Vo6\b^c8ay55MnYtL!c4}rYH;-ec}ed^v6Mem?dk*o5/t=MY
	&7Y2'),Z8{3#}\ y3#F>?"~{@!|0 w"~W}!w"~w!wGD.Y;xmoon2(W_h[g_q'e?i7{u+_^=awh?:#
1j-&OoRJt[+E%S~MBP.'@]w\_F_H~xe[_|g5?D`	yo[B]>\&:6!b\ PG [Eo!mD|#0QBNx^%o)|fA;c_(S?+zZ/MPG?;5eP_j=wJS_m}[LfSOF?`FcPo|g?R/|;5WCF	_)Y+q	uX/o/F~XbW~K%'\\m{>pzY5=kzAy@EB1mr~1g.UjA@-K_4cmb~[utw\x\\z7q]q]'v;EK:AKB4n#FE%F1as'~;6\\s\%,SW{sy15o}0@7\Q\]80B 3F:)M8qQ?,8nq-m/M(M,q|b4n<.5&K4KMn4M$f2\h>nQzZ%N%YQM'gt=w>MJnDnY'q8{%x>]buGa~f#gx7<fc"(lM!gL!i&ESBDsb/&
M!"C03D456A
hvx hx)$C0K<4@DDefMMM4cD4eD4g<@M!7hyf@M) i1:P""R""R""RC	6T)=mg6RH#x tjD<Z^bf@a+RH;x RHCx t\$D%D&D'6 E!"M!"U1BDbsR"u!"}!"4RHgx RHox 4RHwHyvECDCD
DDDD*DD:DDJDDZDDjH<&@d%+R&]:@)Q<JNRV|Sk ^v_+F<\ZzV 
*_To,^3C)oPxEGR[W^olW}~E-z)
`QUU_U5v@p*TzW5.|XzUSUM/>j3TBf(*
I.
]7(E$~QQknY]3x]5_U0dUxTN:[|(Yu;TQ;xg~JdlQxSHG|Q6Et\QE1aU1}IuCELoUwT}yNoKxTE	S%(JoQaf>Un*yPq3"TFaEzh5E#4F}F^h_tc~h/Tw?Te*IgRcTiV$&7*,1e2(E(6EM]?{WU/*:h. 
l,\RB@ t\yQl2-3_Tj>TVf7YJ
S;8X|9=w
-?5S?8$|4mTL9sS7+7O1e3^]e>SP<*J't?H/R
B)83c(0)8 ct*8 %($37vQRPp%)(88E*(xLAqI28`0IfdJq@&If,8 e,/8
fQi/((88`()H;I28`(x
% f ]Fq2(h_Fq@W 4*8 DAqQ|Aq2*(^Aq
>PPRAq:oQ0_Aq }n 3pCq@N =Q@
PDq +@c(u8 ZW,NQp ZW0^/8 ZW4h](u81
2Q@
Hq +@! <A
Hq7e4SP@
PIq +@& R0WAqYAq@eR@
[1oBtmZ>!PD$'}&7|68]z<ot:ytlH&;SA/.7 &:WO]O\=E#~?k[],+c y 0+_1Z/yz@wm/<|s- fUYMzqNYp|vq_1=D_{K<)u2{Se4%?sB8C;h	/D.EsgIG`^+?u`M-q#Qg~!6z?:+)_cOiDCR$
$'{Yz`]c'3_Z9|cOODx={1c &3(x =WU2x?*(L'\B(s2(x =W'\b(s2xI_V_g)y^Ss^oWc*rTOWO_ 4*QnU^R92	9 j?%WeAKhg}z=476kodK[w2?~a1S;L=>eZa-vnY1zUz ] g> ;!&5!v! yAr[7TOk$8e/m	YHbw%8F%	fKkjuM[ wQponW/?/?`e0h'|z;g @_`Yy0Es}yF_g|4U.Z]'/+iAmrXcy8^An[Dsrv4ybFbG{N9;*5';CW~<~4<b2s91=GZDfl-2D9:D)4's'f_{{F=q+87/OrcS3_3K1;&,2'G-S9S;2sw}^G83V.|s\M)N^dSjPc[q68g_;Qm2qc9v{lqBNid9')
L(1o91`9P7;_i,,3O(ZE1B:OYvyiKWO>s9iD">T<\}MlTBM~#4Z)e|8'-qSK2LrP.qf\15q!E8{f!,t|\A;6`!) drHf!i dL8d>S!dC*1Jf>	+Lr#>"L8z|&F)|FC.G2IQfO:C>VNIrb9qNCrvd&+TCC`!OC~%L!d&Hro9q9Cn,'is\\Na'qi!!$PNrHr8dH2L2T$LHLG8!3q1@qNCt|8KN+C>$98Ny!:C1${ !9D$9qBu8oNsyO%u%/>w{8u7rOp+z{O0Ixc>bEYM_?F3T\pw}Jo_?u~s,.[P?y7\\t`r7)6S=]q=z\NRb4E%udc4sS|loL_wTtKrT;dzwY~xcx[UTsTgR;vfhPy`#jQ50+Y0fom,^IG*
&Y)0+Q`v<Q`3${`J*$=Q	8P! F94;pR0U/:s-*;_VN[O*Z7]aIMyu:{nso]	%Eub\m=W#=3q^u=2N(WXhk.Mk,*_vU48.k.-Wmdp.!WL4LkbjNmwu_6hP
}:Ue+6gXRg2n]#dHGyi3z;Tc9:eG[CO7>{%co#jb1rBc%fxC_0h5XGl c^g[9oa[d|01qgFcc'6T]5?I~

\SO3~MkWmVV$#HX2(	V
$HX1j a@	V$&HXQ aeAd+V$4JlA	4 $h A#@V4$hHLK@d4$hH= A@M	(4iH4\'zd5NSx5R6.LjX<UnK8Qw'J,4[txOK:<,;yS%k5!u)B 5$}3??{7 E>*G7H=ge	+eMVA-A&;9B'^c!d{>-/)$,}eIq=MrjrOrZ@wyJ!_2W\_=P!ZC}J~_fyQ'jG+Ij{#c!]	w_5{^is!r;)/\8\|\T8Og*'x$^Vc0iwFSSawwf< -Ih >8w[=1Gb'Uv*pOx -ZSR_AQIPV AiQ2E%S` AA2	J&SntLm2%G&SvtLm2GNn Mf.!dKf1@w%3tH]2CAwKf4.dKfD&!cB
%3*t]2Bw%32t]2cCw%3:t:@	F!3F`(QD$(H0R` XA	A0H0b`(1F$6H0n` Ac	$>H0~   @0 	H @@ 	@$ H   <@	@F$ 
hXP2p	 @$ H  8 t&*Ej(}O{j
y	Zmuh_}][
Ya<G`u6A6gPmnBB~:LVP.tC_sBgnMBCO?#^7{=V#&Qr: h]JyV'4Bl3r
~/Fory9a*9q?dcvwsB	!k4^%vNRi	i#B^]?v6_ce6q@]0nAF	;z}5<z-oQQf))DVSaDxBMI+Dhe$B'#@6Ol%
DxSJ"<@l%!6TFLe(P Sa,">DH$VeJ" VTAj!+bEIzdlJrQa>CVTDX%S2%dJ"<TYSOdELE15EVTSWLe1ETYS_dEL15FVTj3Mh}KL^hb1+_W_(oX~:prlGOb2KjT
Yz~qLwSF9%5R>9>Y!\}G|zc+|YO=KfYoCb	rBrQBh!0`>#LFcW.{F5o u=1kHsUl$- aoRVJjuSeZ?e#o}N)Py)v(wrX!Qr	p.Q?%,"yy`^-*ys<yk[v_[~'oM9P /[[eJ) A))Pr
(RNRxr
<) JetBdt@h|J	\V[:T7YfMOtK!c,MKcaR	|R*>nU(F=>aNc>qa#w'KuN~F/i~mU_zjV0OO('$	%	KJ$	$OO'$$	*|B(O>O>1O>0O>G|'U	uJ.'Jo]>&WmW_Jaj@o~VmzL2nS
x{S?sRLe +?5	>L ^5ia_AOV4o~ZbD<P*/UrtU ?xK9Prr<%c\qs8:oAmw=)oal{|l U8&V.wk+wD|N$jl	<DKf'qfqQVYzxkg83-r1^bNz}E>^/>bI(8-3/q.)cKr[\fr\e$1_sE!VSWaz
n@g-b=[$#ay0lqKdz"O	cep-JX<s2a1&`1SjaQ"E7Y,2b<[hxhGTXtxNGSPva1e@yNk@NO@N%Ag1~J 9Nk/P D A	@T1bS^_SW}we'n;W{|eT2\?OTU^CLljN_*gW(}MV8(~8Ghu][k	4.vJmz.%pqY7{`(r-Fm%n7zX,6me;+%)6.YRNpvK=V5.mfnE\K]X2?ZepJ-waR024^-{[>o@^k1R5sxM?+xYy"nSuGFb~V3e2_he~)@3A(K^IY:T@(K@Q`(1Hj%  , xR.jHYbLCg*+'2H(*J*_@A2HPg A2h7HPU'D}O:)cPrWP{0f?@8{;HxjJ/?i/VqNRKve>pnVE+!\lssKA08%n({;aW;if~%k{&oCPa65u+#QGY^F/e1i^Gre3;R?H?8_59?1,z?EW5hA8k|5ut?jlJj?nvfU1VYc"W
[?e'?N;Q;Qf(A33A;Q=vomF*,%BTX\"58EM\LX7Mi+:ltP0Hb;(tFi2c:LpP0HC
>iB k(W\Zy5?|?{|AaeziUPyuCS_>[t$C
?|*H??2#H_<W/>O(9RO!J|K:;w't=!u |/.u&w7".T1em1$h!/#_=Fz`	1~)	H]
)IWIIi%<tCr||<h]?0Iw!~tG0mF>!a1+]tC;qIW	cY
|hwcewJE9sw6&O%)T<9 ?ln7KS/wg<XxlW?&@(/|-P&YM 	$H`+(A$Jf? @[	l
$m	6`1yc&1D)T (?f"c,?f"c0>f-dln:lX.xK==Rf\[Jso)uordCv2!w;m Dlo@loDl<!LlL"GVc gU7(c w(Q,(cQvtl*%UO @N	xY @v	p$`H3i P2l	0$H:w @	0$ HBH&\D$#J.	X	$`&HMo1,uO,vG0?u0.\co#u+U{\uV5+Os:+]wZc?~!_;3k@_:3_4 nUg$QL\r`13wdTWnU]|f
t-5\**ocbz-0VuBQacXx"jZ#_PZn"j_PZ.v/5Z/ "jAED#@DHJADm/>eJ(})/.-VG]Ko9'4yfJr1:5&kkV&\cO2L(-)1y_:cYse?p"=%-64?vH-sWeXaV{[ t2 @uvv-(t]!\4^ZS4%\FF-BV<?w=Z8gSIe6,Cs696gnJdX,a*v})s.Xovkeo?X_b2r}Y=K2xflU[dtF]_:6Tg'?P&Xd~)IZNQ$L\hM=^jM[v<k2s~uX_wsOI?Ffa<PM_M"B\PC lm)|rH\B9N
-(NeHeBx+QV
-;X)TZ)C	z%
-Z)|JF+Z~r;J-dC!J))Z}J
1G+3^I\|1
1Z)jBF$Q?1!L1dH!(A/)\5%;b.RR-`jSTgZ(%
T(R-'jZ+zY0XI`||W	e/o*!`W=>_G[|i<RaCG=/#"{xOy/41=v~Tf=;iCf=tQSGBtR44=%>gs/Xf=dM,o1f}%[%'Y,]ZSBkwZbo26Hrd#07^te#ULY\Tc\}kji7OO{CGk[#u#G0(u`xL$I^Q#NNN=m2DJFcXmJ|<zSM7eZizSMF 1@oL^i%=mAo4%9=t0jJIM9QAEDj|[(ARwkw(YiT?U\/1<\&5kf3Ww8B'+.2BI@Rr8pH=#`TJ~S'2iZMW+p<k?Y<vezVqWt~Ef#TtiSklzAph}(g[o5ND	czpVk6K\ajnYxI\b??>;9zxjRt_zka.g|N_Y"\=rOkl`ak=QeEqwg\.(M&~Y(k'qO~>zRlWgGDU4#ANq%\],]Z%[BC_GaYo#^z,G{.'G-t	zM.~`hSos#>Hg>W[=G_PYHz\2'
}Lp|j>9r<'/z|6By?.Gw*{5~Ds'#['GI4^)H;*Og<X9I4~DsH4~DsH4~$Os{M8?xC/8~9%>wUXro3bV;%!fMcYbV;eN!f] @K	,$XH<`}(+D,$X#HH` 2AubB`Xa
$X,HZ` z,7bA5`$X8Cc^4U-1/1RP 	0G_0P0(J`!AZ0<(C2<(C2<(CtI0ahC2T<yt<(C2(O6XudyR:'eyR>'eyRB'Jw!C; 0O	#N'eU	
/zX(j!v<za}($H@4jtCo5v<a^VK; @<@; @	($!H@D 1_$ $H@I -Ab<B; 9Q2	
P$ )H@S Ul$+H@X i0	.H@^'@` AD	E"EWEEsM^/_<GWyouzu8w1j'_-]em^8&fnyrHnKVmk<V_b\e'Y"Xgc_X5|;\S&_uom-A\qJ=8N-;"W7L{gZn=WO47M4 zu15^FoL7_9}#X 5=KnwV=zP}V,,5p^h1T[[u~Sh}
MBSsCOro4/fPBaVY!M%BaVHg>IY8OkV?^h=`R:;{kUo&kM|xogkY[]$WkeoiTxh2])[f\X9QlT]mYMm!=$%Ly(+IyCV
>U:>uYQflWb|5|5oT}Y{rbYpPeQn8'Zyq{('i+KR(Ks=[Y';Qf5KSu}r73y>8uYkhkfqoD'=]v0@DmTqLIPy,N1|S},N`XbfYTs 	&$H0dDQ03A&L%3ddQ|B 0b)9+)9+)T|Z1g==g5=gTLoq{\Q2-Jfb.fXbf.fXb.fXbf.fyc8c:#9b&E.f(c?JX:Dd`$`4`D`T 43b,r1@$``	`
````d \\kPp$,rP&,rP(,r1"*,r1",9 ](|aqAJ e iXbEi2<OWq(RM<Xaj^ch4^wypwOK=~,8Ux y}leo,}o T?wO&r>zy	ksjWO|<y(>,k{]H6L/~bc]jB*tkr3%r?W.<~zc=Uc.w\"NgJ?~$9|F?"sz/h%}Bt 7Gimb&{_|OWO)r%Cr1ugEW_$(x9|fJ,|~Bd|w#-;>F~9:s?/`k=_K5P1=_qZ{{!2|Cs{fWgJ~@gdm=_a=_/uj {V@gVbv%@8-\Hm	8[b2,3	L$H05`nH0;`zx43+);6~Ic0M:R5`pRY[Yy|Kg{06138j8&7f(i#f8rAL9)&=r`f#f r` fr`U90@r`TT2A9ArJP28A. 0Z3xA.7HnP2A.`0~3B.`0"3HB`	0&_
%+?Q [_3C.`02oUob\raud`%>
 9'pU9k)5\U4~1pUGW_u*SUE
jhb`9-wW$1]u1]`91rbwe&<_+SL^#`*,b?ZY+^VeXaGIp~}Cyhm/glkfcc{t3`b=B.8dGAEkLrBO>F?{|q_V<wc]<i"/t5l&2AAL/tg]2J  7|!_f37Dh\Rn\t15J'2dTc=sUM`r%T&(z&(RL\2K(3g.0g\zQ91Zk0p*\W.g?9q?155>#Mf0G9soo-gMF[$XhB>YhaxB>Xh;XG8Lf}Ytn>/\jK=A1{a_8{-K_{J8]Y};-\>1~Lak 	#CAO-HxAG.#*|\9Z>qWxWXc=Z=R|\9R&V#5zl)Gj%=R--Fly1reK+[f\Rc#WeG(cK+[~\
` #W
))>A5*8nqIj?M]2u%X-na'V&KE6E\34LKmBu*qgsol]">und-AU=S{pT8xYsKVm;m6-:me3ogblKU-_Uq+7J*qf1MU,W%MdK:[?Gy-L[Z{limm/2vUeK\YUn^LobFMWtQupq& LZE RU%NCRWK$,=J)9oeZom#n#g#i#F~v&~F~6[loQTz/aV\SzrMfjF5u/rF#% Je#ffJcj&7cj*7Le1Ec/$Zj43LQ2,Sm2,Sq25Gh`^2[{|`:a+-^|S&^54u%;_	;,3y}q7goqYHO)pzw3 k3	GUI7p8J])%AU+G>9`O59;Zw%Zlnbi7f~.`AHV!}s1#2;?t {b5&|O7y_k5u	?FJ8#q z],	]y	um-d'JsV1w[E\<}%Rpc616gPmHpc4sAWy
4A?#^7{4zL3e	Q	8HgzAs@0;,=#~r-k>q+fC6f}g>'KON`f)IQrjd!xV;RxH!|KJG)V{x5a%v	8 I?@~Gc(Bc|gm'5FJSRO)o5RRwOQhij8M}r4VNUJI6Z9yX+'OSkA%U(A(_%J_QR]|FI5%.SRydJS{5!%(LI}@IJGO(.PRIW]>[T3&Dj>-_lW}	mCy
k5[{a}m&3\f~xn2>t1VO^*pX
^So	`?Y.c*`cs{ZvZVH.o/h**VzXOT$\@U@6F<0H"2W{!?	!c4)?>\NR_3m%][.Z[(8yC<Yw\n+Qa@QV~VJ6Zi?'J*=AO+iOT%	=AJTd=ACZqOp562K[X^2~+S&<,Wr}gnK%MXjI$=hv,s,iYvYbI9/96z/h\1j20g
?_@Bzc~.S{I,qu"i4i6?-9io,=.S@(]Ytq"3.v]BYwIrI+{Z)]Jb%Q$+0=t{T%{F+)]tkS=J01tkSEL1MTN|I=VJt	%?PRc%djKiL})mLA)mLY<PgJs6,6A6NPJ*uE&^?I	%:c_lTX4T=Wzmy5q~egn;aAU"k/W9~\{u!Kc0]Ub8S{>N{{mmpBzZVnkW{X\8G5kgIZ5J;-gkk`7h;cMvRrgu&fS'.6f;_+	>NIZc_N=|=cW:s~}X7PW_Ww]n6K-+q*xEVx+8x48h'N8^JP	xvxm'G8A]}m$7$SxP[&7GMo8^8(5qYvxT8U#$S9xFz:}L1U$815qjv{EM];q'h:,q;K$SavW;nNwsUqrbi_:1e|s #kGOS0_`cp#7ilvX}
p - 7S[sCUm.*qO	hp qk{$z=F*kz3ug'y%j}QoMK6nI-6=T0u7?o'?Qaygq#=Tvq&}eg)~#90K 3&fdjq
xtfuVvx+
1J@[CHx(	o%{ -doOqfo$}D Pg$Wu<\)_bAsfei`*Zh_=;uw:w@uv3'Rc&~b.{iJ2'u~3E>}'e_oyw<ygqO6;.5m:5Gk~t'6Qvbk<M'aRa^5to]-o54{=5veu^A5
l?52 aLFk43>qa}/6aM>{1?+EQoKF~q_t?u$%sEZSpBdl0]85:-8j9`	,0 	z%	 A7OH' AW@NLoP_; A@=Bt	$JS8
B`~Lp3tG!0}QLp;t3QLqCt$#@`:%B`~	z
u@_,.9[ AA=	J%i^dLA]Y==;ORKhCE#1e
Z_o%EkBc66g7}vWg>xZl~^}*qgb}6]"^/5yLmzz6>}3b}1Y	%=,S36C(Q?Eblp#g{^uQo3ng	;<4f?;s/L0_Lz3%I9S;S}Z/#B	 <^gVR)f]RRS0AE$*>o"sTSP-RHE"}" 	,2"{"7T|Q"T"j']T3"#N*NsR0IE1N*f:"`O'UN*fT%RHE@%J9L?Rp#>]" G*"z'wR)'T4;8_"N*"TBcRPO1[TX}_06HUaMBF~&Ma$?.a?,IP"O;7ndAa}k+h,Kcz08/d^9W;c1*-KO[jw^*~S(,]A_M#d=t7pB(wHDL	F)8ed
.$\~<Od&R/Z]/t)g\Ay;oPG</\_:03C~>m_*1s~v'&?==wjy@}]uO:u]u?A#.4FmY21j.ph':t%V0u2huVmUA	|f4f0y/e1i^Gre3;R?H?8_psa#uU.h[j~M_mVyWfI,4;m$v0H H`Db4$;d$vA@m$vpAAi#Fb0;8 vH`2#b3;< v0$dbt3hh7V_[x'zn/w=_u_skP
}:Ue+6gXRg2n]#dHGyi3z;Tc9:eG[CO7>{%co#jFmN qwaq@p:PL]>[frG)Ovq  A?AJPr8p?v?o$HOI:4so_l*gEz_zkr&|*lGOb2KjT
Yz~qLwSF9%519?H%@;|V7/~w~@X[b.DZ&,Y f
/Gd]UCe6S6&'0f}G	q7B6B1wV3<s%n0\XU}?k<navM+AO~nnI;P)vr$r{%r#$r$r$r%r(aEmmmC	+2mMn+6M'M mm/m/mm,~D&mmer$O mmgcrQhE&>)>).=q-,8.+@L9E>
KL|u^Sh/]mn5s
;+@_z9^79@FtUpN;+NQ^m;4O\0mS
s<uUk]wg]}.$xOW}:7nm kx!eb /;S/kwJ<75:}%-6_>BTo5JQslX~xc?nMB?|_f=,JyX-.CJ!YA(b^g[>U|P>z||1G,NtNzns\li7L5^]rm.CqR@_K,S@rz<)4P)O) D)(4VPD)DLY(4PD)R@T<ByJP&J)#O) N|
u	iSL^-{Xk}96y
f*` aP;;	KiV..5 hUJ5,b*)*_j_w]w/;9'~$B6@{bN' 9BM<ym^\|L'Lv3"@l/9NXqo:kySMYRc|j_}Ew@qyN?~c9kk6I-8?Gbs\Xz^g>.nA.~.a,R{3ovkm;b5r"l6bq*|~R}gMgAk|}:0>0Blmp;xw:F uR}g}zO4
5{g+\LiChNxzR^}vWmq4}gzpX_3dpo
sr=vu$f^aI,*+uYES=rU1^5X;wsI[s/?'f{|FGo?E<Js.wTm0on|^A$wk})*G6m~9G@nnDn?/[0c*H;;e]z4kvH?O0cr	?Og8f0jrT
Yth^zoPcq^ mXOk~w>+ ~NmrbS:7Z3V>D K-yh5yVdV3eV%2ylpUL*V&o[fVW9;Agx7toOX:8q;<gwytp>=BXe*F1QMUO|gRUi<yU>_e7>:F?][n^]M16ww}7V%Mkc)FppsV8+y%*9U_w&1[57|>E{@q[X ?Z5o:*-.{qJ2ZLABE@"Cy+.VdE@;1`9ORZB&&K93ss#mt^b/2Q*Vx?+vFFt2RoLHaXhcV?hL0z`?T#cm'T*wNuyX-gC"[Nd+l/"[}Rd7l"[<8{8zGpl0QITi`^.o~i"%,Ln[#j{5^~`7AM&\=38%j4.,TXRj 'qhYp,b\,rn'2Y_Y_}Rd{}FWo,ru'^XP^W=cA{]pUuL#UGQHYPj 	KA%3K j
@,)X)S`	(@%")AQ$y%<Mx_&8u;'[r2oJ1fxn{
Y 6}-F_R&0o`nz8cR\lP5w6.FR<aFwRn3%A,!c	83K5,!]Tg	:(BDPANJK@IicMYyWY#>XYyFe9jXuyPC"'Y>k,9o9nr38`,r(hD	*z	-k	wawe(P,je`xYZbU9,5X/B,T@=bb$E'?Y7/S2v'OSw@By'M`c:9[vaE?rW~4G2S5ol1\UGC]![c:Kl 5K ?K\wDjniYR'[|SrhEOv?~:zx+SeBRg>tDDJ%^kI,-ioWCR[K|wZ#y>c|7WE#WJ>GEzgJWs^zRJR~|)Gf$/3c)~w	(o22vz\4Ao10U]Hwo+1@b'D:0O$wKo_!1gNug:xQ<wO-1Tb5!Mxtc<??3g}}>&P>&PCy3%s$+%KVjNg?&??y1;c?JUdF-oY*
]->2+{kQ=f/G_]m8Fc94M;+f|7$"_@/++`w.<K}~~-xx{)BowH[~egqZ=wY\8[vp:C5=\7Y\GH"r/F_+dcV.ol?v}o~l9sm^vZslYHmVuzVw2ucN5[xC.ol%0tR-!2t!*GBCt[_u:q>k&9b52:zwc>bl|.w4rwM=z7;Xww?6H'<Z3V3]w$s[s2B1=<<wyZs40y+:>k``{y^`{yWAfws50mc$2:>%so&Dc;W1).
)HcVx_"ar2H}}yXQ&g${>+O:1tk A.\\"^"^"^Il<cF~~?t}Y)pJH`l+Q+y(k@ { A5s&fV
\?'}elZzz_%(V|)%P?:V<6.u*!)VN?But[(w!|kLc=*Ej9wE\rq
uzzYcmb7h0WZ.^,Y.~K-Xbn?-<W\M\'>s#sUM_U$W=ZZB:=:+/[uEvS^{S}Vl(u5Nki\#-+_TspxH5Tsi"dTs0h*-WkSi!FoZ {kVsH5[TsH5^	;9xOvUVsPz}m1^pp}6><=K*hSiuY}kT\<uU.uOARiTBD:!"VH-
^T};>rc*FD=B]PhT$:R(RHO| E4RHW| eRKv0eY*R)Ml;P@o)4l;PCY] R@{)l; eA([~])@5XUO*z
PmwS STe]J,)P( Tz
P5)@XUOz
PARTe]\Q5)~U\fOeydUrow_)b3t]_apO-(Q/gF;Zuz<?16dwJ)B{3=g~?m}ipwCs}}5U#s=!)';5	W9_#TJ/m+d)l*5"AYn9:\Wwv[[/+tIBCS	]7}54mzcO/Z\mV>xmlkv	6AeStNSIV-?XFh+:CBF2X.kTl=v:.-+K=$>6DggYAW\nklnsOl]7b/npEarDNk+~,(Y.;i(wP?cq+sm5Trm=A)y!PiBTAD "ehyPy@!4yDD&V@-Db4o	F&r4o	G&4o	Hp
)IYl&4o	hJ&*4o	hK&.Y51G
	hM4oJ|	hM%6@q7]f;	#i$yl'a>Q5	TM4oy!@=AEhU";P7  -Pe*jD"jE* j	%Bs?&E5*y/{5Ja  K2~MNo}qzSzjxSi{)KKl7]~o* Sz_,Q*/U"BM/IQA_W/w{_XY9]5j/3|^?Ei@z.DKkn)&HC"?l'?OL0$o|;)F>q!)|r5e>RIRI-Ro?.gL,e.M$T?'dM>+>ucU:U&_=-M->E3kT4kV+0?}(^w9l2MA^ 3@v4q!ir$YI2	& _ir	<& oir	<GD "4>'D"ry\AD "g7D"ry\BD>W-D"ry\CD!"w=D"ryH2G|$N""/	9<ED""_inm/"xWFQU}yCPyGxW}??~[7;{+3)QOJ?(t5yDaUm3}`Mqm8q*3 +vP(&Tk'W
U*S~?Uj4g<{mps[)}GkypOrG~?"GL-iYF#Diexko1hS?aOukV% p`}<J A%z{P3Lh'L?8}-)9?A^wc]l~[A_>15cQ|WO']V-p;VS[
ozQ&gDQ6A?4-+v-;JQqc]mXXzY#KZvZO*mh_[MgL
zV]=4U-\S. -<GI|o6ycxSv Q95HL&1>>?v'?(l?f3=!jO7VU&zs-4s.3CJo_(-4KZoi,%-$%ii~I+}_f_k-5g,Fe?i7sUw:9d4KCiwx,!oJH$j\:?<?xgx;t4G]5Xm$w\<w_:lEiS>+:u>}5_y.\V^#na([^lT;RHrZ7._Ka++yX~ex0FM /^*^{
Z_W%ZrRsJ|3kej2oXkTZ3/.>ZgBk*_?stQpEENq&+(ohn-O6]R6N9(*	Iye=Wx{*W|c"gH:o EL*uWW=X:=/3(U"@3\yO=a_i~r~J(x#H|'Ty{JqpT<!m=Gp!;WqC$D!!XDjkV-#"ZGD$m%"ZLDh9iF`A"%EDkUEDED+-"Z\Dhy"FD+1"ZdDh:}`RFDV,7"Zosl<%GDkN:!XvD`GDkOZ},?"ZD  "zB+ g]-; @D/@D^="z!xo
"zJwAD^="zD8u ~Q[?DHa#!WBD	="z)DTc!BDE2!'CDo"z6Dn!CDo"z>D~"'DDo""zFD!)P/%"zLD9{2xQBM"WED=,"zYD4 o(w	P>@ 9dB#B3#!4n$_Ra?'Yb`n!9N_Wr*~8^{UwWMk6zG?5[vj]G:?2|z;v54XDpF?q4Df_w4olo_3ZoqC[= 7X2WEwtksh6}X<Gx!{/owdabxcCyvi1n"kQn}bWO8z_n3iCJ}b]SCqu7o~cMcHM!.8}O1'O$p\bFL7$t'UeHnOcHiO9V}j0^W[;^g\nt_^a9fwdmalt\1	2<Y[g}ak?yFwvMO4)JI5"RMGD#")S`hO.P]? U`]P	
rA-( \PBP
vAU(u`T]P
vAu(`T]P#
vA(u`T]P+
rAA(#5`T]P7
vA(`T]P?`:Fud:FdQ=Y{~k`B,cTcGufnZSMMA.8!9SjO.>	` `
(s@.
v,9@\0`&(SA]0`L`>(B.
vP]0)Y`L`^(Cf\05`n(Cf]0=`L`(SD.#
v$Qf]0My`L!)
rTg&#h(]M2}ESF.3
r5|QmU-T~,<}?M!(?\/5Kw~jC{FsRR_>j]X+>a-l]7!_78W[F1|NQ|Zi|ARRoJ-OZ.-s!GYV+~qq=7csM!})hL1P% XYrV% gK,g	5<K@.YRYr2% yY2g	H-ydj% J,YCb	K	I
-_#%[	?r/ xr5,	zsWL8j+].x/nEPf.$v^+pi0&[L) OLr}R!fg^b)vXrS8yW81G?OQ(7SqocXxOt +REI2S'-	:YL4/i"C?_
V?|\Ok4?OJ?[\0IYG&^..zI\q:nemqoqoPrk#DjUqQ9LTSqS^7[m}0C\yqOss;vu*;dq@gqOm_~`yH<tnwxn$wxPydahNS}}Z/O=}kw-;'|vcp+Sc;ysmm_ZJ]n[K7:.	k!|{p`37 s#7?h	?#Km$'U&o0/Ry0n!VN-V%U)6<O=;LO-3/SN |3N<=u@.M\|U\- :%/QUd_EV%k7-%$gDVuh=Y[/%F&pKY""a"!X[VId_{8Vc_"z
9V*.Z""Z1222<8jf_6':,q9d__`BvqVC`_1o^XWX6Vmc_6V5m+ZXW*gc_aj<	
&D~X:"	kk6V%XdXW"CF0hIK~)z&Z%hx-f3wrNy!s'G:%?<~(^+'(U-1.I{Aq&KJW#9O=6qU2B)gx |_Wv9=AQoFKX/(]|dG0m_hxDvigavrTF[kno^m/|VOwCt>V]IBc^!q[QZbzg[tRCgisff?	-mJhs-ZvtA:~MqN5tMbi47#ua{6hmkV8:}<f#bqK}avxxEY?]a2hNLC;3[kCZBS^	
 xwRY(!F#'hA%q(~,_MJ)\,pAS
L[4!N)\:pAS@Z M,RHJ)(Rx@JI(DRx@Ji(Rx@ B H@&J(Rx@.J($t} kyRx@<J($""	BR
HI)< &R
HJ)< *R
K)< /@bJ	HhB 5rS
N)< y~D*B'-ivR
rg/kBZ(cP,bg~=CR9`'/Q?-.9qKZnJ\jjp<}yBWw_L	nm'4{{rwd767,^@n'9m~r}ft>j}T[7&wm<AK+^}~cqag/fO^)3a`&lS
f<"5[,CH<`	a(G'")"+"--E!FaE!0(vBzZc0P(@@DqHhhhEbE# *Z4E# 2Z4bE# :Z4#HDJ3+8@4 DL338@:TdC7sSn5k1{y'o?=%<UUZ}s6wyr{:i5,s.;\2!T3tS)RfZ}5oYj61#'_%pFsV8za:26\nbFr%eJ
gRp4~(]8^"PX{]E@e<`^gF$~roA\xP3B7Z%
cGDa(@1U0JVx*QS
`\i(-!/9<,ai$7~|cai#=rGGA2e"BM zPa!JA)?Ew3fGF0VyU)9i>RYdW:L$tgQ_pHs
]/(7?*'6LZV1GW	"_+t83l\OIb}@]O'N=?5z5 kl]""/
6rb086-==7&rGC3*'#!')=dG,J=*G7g+2&%/&HM7s{{2c7Zt7?\fgos
glt7_bq9WEFps\3sk~V}-V}
}
kYv: hu@z5.l5nMCk5[Nt([:uuiW)TW9Uj:$:7ba+ok}d-#ROYRaQ	]v+jHnM>[|pk-icSsfh:+2VSecxr5{~bl|Z}7uF	&+>gQ<sbub"dQ[`|]%c
|R nH@[ )
ID"2!"TtA@,B "H2D$ pH:D$>|H@B !"DDR""1HPD$)!%""q	H`B 1!&R@pD$9!NGD	  $(,048<@??T$BP&DT(QAQAQQQAQD$|]'*"!(#"*$"*%"*&!('"*(!()"**Jv{@'?Wa]+//4a9uWW:?'x5t<}?S_eqaYGHv/_BZ:/ftuq}g:~tZ7o^$W]elW\0}tlcNfX>/sat~iItl^:^v]y&:bKVvvysux	aim&{%O0=Z?]M:!QA-a]y:v#9:6u$:t;N?u:2,k}tvzuJCg]+CH3t|t&t:>]jtdV:OoI"u~3cx]Z=|p	>E}NwU*U2/zY,4pQae2W8YO~=5{^Awv%Jy	S ? ZpmpB|DWW{OY4-Al>#+3]W^MorSNzp9Vyh]3)82'=JyFjedr8cs+&TG%rD4_o	)]i9Z-RZTNGc6ry=xGP^/;glsJb 5P
0*|].zo'|w_=,|kRkmL0YL~"V{-FC_T{RY	9_-6L/8	CkfGfeGof1$WJUq)L3d<URo_Y?M>S`|9	[y"BO\JYy35p>b/ix{)QB_FQsM_NsrU^_a+df+Od^5uZ{kH}1*?^P}^rp[=\Rwi8zKM@YVD!fQ Pn&@q(q8qHqXqh !0!P!pQJf0tR*!Ta)
CCCK'!Eom||g3P|O5ZM9RV:T~s?w>%8x/>?L(?PC
 zF*rG(c3'??3+eSwycL1eq~mOK${CSU29Z#)cf_OH0f*9G*<cIVH9~JRY 4Y$Co,bLJJzW4fU|;t"YG<0,3D`^o_c97nU&,n3Sn`@	c=*QEheO_\<9\yC@ X5`MqXlG1	O/ >;?OPo1NL5egA*/bL2r@J	d{Sz%i/>3F{j}0m_&>\/	r\%5jP"335vac\Vnl0/G' g
|ZFB=??f6MOUF,Nf*ER_|+F60ww\<tkp#59j>oC_8+Xe2g17ZSgM;uin-3[%K(
hB+;/D;iE%/J#c].*Rdh">08lQ""un60h0p0x "@"`0x18EEAFFFGAGGGD8"yT0lG9djJ+ejA(Y63=sz^|K4/j~:/zW;+_~bq\1OJ/gr]=Lzkd[?%Y'|s=W{l.:{IYO|aSonkF8\|5@%~07|qt<Lc[4d}*`g6LU*uguojFdr@DY < D"29Q^ 3D"2DD9eJdKn13!dNn'wGD "=D"D	pB=OyCx/8$DC~Oh6 p import logging
import os
import tempfile
import shutil
import json
from subprocess import check_call
from tarfile import TarFile

from dateutil.zoneinfo import METADATA_FN, ZONEFILENAME


def rebuild(filename, tag=None, format="gz", zonegroups=[], metadata=None):
    """Rebuild the internal timezone info in dateutil/zoneinfo/zoneinfo*tar*

    filename is the timezone tarball from ``ftp.iana.org/tz``.

    """
    tmpdir = tempfile.mkdtemp()
    zonedir = os.path.join(tmpdir, "zoneinfo")
    moduledir = os.path.dirname(__file__)
    try:
        with TarFile.open(filename) as tf:
            for name in zonegroups:
                tf.extract(name, tmpdir)
            filepaths = [os.path.join(tmpdir, n) for n in zonegroups]
            try:
                check_call(["zic", "-d", zonedir] + filepaths)
            except OSError as e:
                _print_on_nosuchfile(e)
                raise
        # write metadata file
        with open(os.path.join(zonedir, METADATA_FN), 'w') as f:
            json.dump(metadata, f, indent=4, sort_keys=True)
        target = os.path.join(moduledir, ZONEFILENAME)
        with TarFile.open(target, "w:%s" % format) as tf:
            for entry in os.listdir(zonedir):
                entrypath = os.path.join(zonedir, entry)
                tf.add(entrypath, entry)
    finally:
        shutil.rmtree(tmpdir)


def _print_on_nosuchfile(e):
    """Print helpful troubleshooting message

    e is an exception raised by subprocess.check_call()

    """
    if e.errno == 2:
        logging.error(
            "Could not find zic. Perhaps you need to install "
            "libc-bin or some other package that provides it, "
            "or it's not in your PATH?")
# -*- coding: utf-8 -*-
import warnings
import json

from tarfile import TarFile
from pkgutil import get_data
from io import BytesIO

from dateutil.tz import tzfile as _tzfile

__all__ = ["get_zonefile_instance", "gettz", "gettz_db_metadata"]

ZONEFILENAME = "dateutil-zoneinfo.tar.gz"
METADATA_FN = 'METADATA'


class tzfile(_tzfile):
    def __reduce__(self):
        return (gettz, (self._filename,))


def getzoneinfofile_stream():
    try:
        return BytesIO(get_data(__name__, ZONEFILENAME))
    except IOError as e:  # TODO  switch to FileNotFoundError?
        warnings.warn("I/O error({0}): {1}".format(e.errno, e.strerror))
        return None


class ZoneInfoFile(object):
    def __init__(self, zonefile_stream=None):
        if zonefile_stream is not None:
            with TarFile.open(fileobj=zonefile_stream) as tf:
                self.zones = {zf.name: tzfile(tf.extractfile(zf), filename=zf.name)
                              for zf in tf.getmembers()
                              if zf.isfile() and zf.name != METADATA_FN}
                # deal with links: They'll point to their parent object. Less
                # waste of memory
                links = {zl.name: self.zones[zl.linkname]
                         for zl in tf.getmembers() if
                         zl.islnk() or zl.issym()}
                self.zones.update(links)
                try:
                    metadata_json = tf.extractfile(tf.getmember(METADATA_FN))
                    metadata_str = metadata_json.read().decode('UTF-8')
                    self.metadata = json.loads(metadata_str)
                except KeyError:
                    # no metadata in tar file
                    self.metadata = None
        else:
            self.zones = {}
            self.metadata = None

    def get(self, name, default=None):
        """
        Wrapper for :func:`ZoneInfoFile.zones.get`. This is a convenience method
        for retrieving zones from the zone dictionary.

        :param name:
            The name of the zone to retrieve. (Generally IANA zone names)

        :param default:
            The value to return in the event of a missing key.

        .. versionadded:: 2.6.0

        """
        return self.zones.get(name, default)


# The current API has gettz as a module function, although in fact it taps into
# a stateful class. So as a workaround for now, without changing the API, we
# will create a new "global" class instance the first time a user requests a
# timezone. Ugly, but adheres to the api.
#
# TODO: Remove after deprecation period.
_CLASS_ZONE_INSTANCE = []


def get_zonefile_instance(new_instance=False):
    """
    This is a convenience function which provides a :class:`ZoneInfoFile`
    instance using the data provided by the ``dateutil`` package. By default, it
    caches a single instance of the ZoneInfoFile object and returns that.

    :param new_instance:
        If ``True``, a new instance of :class:`ZoneInfoFile` is instantiated and
        used as the cached instance for the next call. Otherwise, new instances
        are created only as necessary.

    :return:
        Returns a :class:`ZoneInfoFile` object.

    .. versionadded:: 2.6
    """
    if new_instance:
        zif = None
    else:
        zif = getattr(get_zonefile_instance, '_cached_instance', None)

    if zif is None:
        zif = ZoneInfoFile(getzoneinfofile_stream())

        get_zonefile_instance._cached_instance = zif

    return zif


def gettz(name):
    """
    This retrieves a time zone from the local zoneinfo tarball that is packaged
    with dateutil.

    :param name:
        An IANA-style time zone name, as found in the zoneinfo file.

    :return:
        Returns a :class:`dateutil.tz.tzfile` time zone object.

    .. warning::
        It is generally inadvisable to use this function, and it is only
        provided for API compatibility with earlier versions. This is *not*
        equivalent to ``dateutil.tz.gettz()``, which selects an appropriate
        time zone based on the inputs, favoring system zoneinfo. This is ONLY
        for accessing the dateutil-specific zoneinfo (which may be out of
        date compared to the system zoneinfo).

    .. deprecated:: 2.6
        If you need to use a specific zoneinfofile over the system zoneinfo,
        instantiate a :class:`dateutil.zoneinfo.ZoneInfoFile` object and call
        :func:`dateutil.zoneinfo.ZoneInfoFile.get(name)` instead.

        Use :func:`get_zonefile_instance` to retrieve an instance of the
        dateutil-provided zoneinfo.
    """
    warnings.warn("zoneinfo.gettz() will be removed in future versions, "
                  "to use the dateutil-provided zoneinfo files, instantiate a "
                  "ZoneInfoFile object and use ZoneInfoFile.zones.get() "
                  "instead. See the documentation for details.",
                  DeprecationWarning)

    if len(_CLASS_ZONE_INSTANCE) == 0:
        _CLASS_ZONE_INSTANCE.append(ZoneInfoFile(getzoneinfofile_stream()))
    return _CLASS_ZONE_INSTANCE[0].zones.get(name)


def gettz_db_metadata():
    """ Get the zonefile metadata

    See `zonefile_metadata`_

    :returns:
        A dictionary with the database metadata

    .. deprecated:: 2.6
        See deprecation warning in :func:`zoneinfo.gettz`. To get metadata,
        query the attribute ``zoneinfo.ZoneInfoFile.metadata``.
    """
    warnings.warn("zoneinfo.gettz_db_metadata() will be removed in future "
                  "versions, to use the dateutil-provided zoneinfo files, "
                  "ZoneInfoFile object and query the 'metadata' attribute "
                  "instead. See the documentation for details.",
                  DeprecationWarning)

    if len(_CLASS_ZONE_INSTANCE) == 0:
        _CLASS_ZONE_INSTANCE.append(ZoneInfoFile(getzoneinfofile_stream()))
    return _CLASS_ZONE_INSTANCE[0].metadata
U
    ^                     @   sn   d dl Z d dlZd dlZd dlZd dlZd dlmZ d dlmZ d dl	m
Z
mZ ddg dfddZdd	 ZdS )
    N)
check_call)TarFile)METADATA_FNZONEFILENAMEgzc                    sD  t   tj d}tjt}zt	
| r}|D ]}||  q6 fdd|D }	ztdd|g|	  W n, tk
r }
 zt|
  W 5 d}
~
X Y nX W 5 Q R X t
tj|td}tj||dd	d
 W 5 Q R X tj|t}t	
|d| 2}t|D ] }tj||}||| qW 5 Q R X W 5 t  X dS )zRebuild the internal timezone info in dateutil/zoneinfo/zoneinfo*tar*

    filename is the timezone tarball from ``ftp.iana.org/tz``.

    Zzoneinfoc                    s   g | ]}t j |qS  )ospathjoin).0nZtmpdirr   ZC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\zoneinfo\rebuild.py
<listcomp>   s     zrebuild.<locals>.<listcomp>Zzicz-dNw   T)indent	sort_keyszw:%s)tempfilemkdtempr   r	   r
   dirname__file__shutilrmtreer   openextractr   OSError_print_on_nosuchfiler   jsondumpr   listdiradd)filenametagformatZ
zonegroupsmetadataZzonedirZ	moduledirtfnameZ	filepathseftargetentryZ	entrypathr   r   r   rebuild   s*    r,   c                 C   s   | j dkrtd dS )zdPrint helpful troubleshooting message

    e is an exception raised by subprocess.check_call()

       zzCould not find zic. Perhaps you need to install libc-bin or some other package that provides it, or it's not in your PATH?N)errnologgingerror)r(   r   r   r   r   +   s    
r   )r/   r   r   r   r   
subprocessr   tarfiler   Zdateutil.zoneinfor   r   r,   r   r   r   r   r   <module>   s   U
    ^                     @   s   d dl Z d dlZd dlmZ d dlmZ d dlmZ d dlm	Z
 dddgZd	Zd
ZG dd de
Z	dd ZG dd deZg ZdddZdd Zdd ZdS )    N)TarFile)get_data)BytesIO)tzfileget_zonefile_instancegettzgettz_db_metadatazdateutil-zoneinfo.tar.gzMETADATAc                   @   s   e Zd Zdd ZdS )r   c                 C   s   t | jffS )N)r   	_filenameself r   [C:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\zoneinfo\__init__.py
__reduce__   s    ztzfile.__reduce__N)__name__
__module____qualname__r   r   r   r   r   r      s   r   c               
   C   sT   zt tttW S  tk
rN }  z td| j| j	 W Y d S d } ~ X Y nX d S )NzI/O error({0}): {1})
r   r   r   ZONEFILENAMEIOErrorwarningswarnformaterrnostrerror)er   r   r   getzoneinfofile_stream   s
    r   c                   @   s    e Zd ZdddZdddZdS )ZoneInfoFileNc              	      s   |d k	rt j|dfdd D  _ fdd D } j| z.t}| 	d}t
| _W n tk
r   d  _Y nX W 5 Q R X ni  _d  _d S )N)fileobjc                    s6   i | ].}|  r|jtkr|jt ||jd qS ))filename)isfilenameMETADATA_FNr   extractfile).0zf)tfr   r   
<dictcomp>"   s
    
 z)ZoneInfoFile.__init__.<locals>.<dictcomp>c                    s,   i | ]$}|  s| r|j j|j qS r   )islnkissymr    zoneslinkname)r#   Zzlr   r   r   r&   '   s
     zUTF-8)r   open
getmembersr)   updater"   	getmemberr!   readdecodejsonloadsmetadataKeyError)r   Zzonefile_streamlinksZmetadata_jsonZmetadata_strr   )r   r%   r   __init__   s"    

zZoneInfoFile.__init__c                 C   s   | j ||S )ak  
        Wrapper for :func:`ZoneInfoFile.zones.get`. This is a convenience method
        for retrieving zones from the zone dictionary.

        :param name:
            The name of the zone to retrieve. (Generally IANA zone names)

        :param default:
            The value to return in the event of a missing key.

        .. versionadded:: 2.6.0

        )r)   get)r   r    defaultr   r   r   r7   6   s    zZoneInfoFile.get)N)N)r   r   r   r6   r7   r   r   r   r   r      s   
r   Fc                 C   s2   | r
d}nt tdd}|dkr.tt }|t_|S )a%  
    This is a convenience function which provides a :class:`ZoneInfoFile`
    instance using the data provided by the ``dateutil`` package. By default, it
    caches a single instance of the ZoneInfoFile object and returns that.

    :param new_instance:
        If ``True``, a new instance of :class:`ZoneInfoFile` is instantiated and
        used as the cached instance for the next call. Otherwise, new instances
        are created only as necessary.

    :return:
        Returns a :class:`ZoneInfoFile` object.

    .. versionadded:: 2.6
    N_cached_instance)getattrr   r   r   r9   )Znew_instanceZzifr   r   r   r   P   s    
c                 C   s8   t dt ttdkr(ttt  td j	| S )a+  
    This retrieves a time zone from the local zoneinfo tarball that is packaged
    with dateutil.

    :param name:
        An IANA-style time zone name, as found in the zoneinfo file.

    :return:
        Returns a :class:`dateutil.tz.tzfile` time zone object.

    .. warning::
        It is generally inadvisable to use this function, and it is only
        provided for API compatibility with earlier versions. This is *not*
        equivalent to ``dateutil.tz.gettz()``, which selects an appropriate
        time zone based on the inputs, favoring system zoneinfo. This is ONLY
        for accessing the dateutil-specific zoneinfo (which may be out of
        date compared to the system zoneinfo).

    .. deprecated:: 2.6
        If you need to use a specific zoneinfofile over the system zoneinfo,
        instantiate a :class:`dateutil.zoneinfo.ZoneInfoFile` object and call
        :func:`dateutil.zoneinfo.ZoneInfoFile.get(name)` instead.

        Use :func:`get_zonefile_instance` to retrieve an instance of the
        dateutil-provided zoneinfo.
    zzoneinfo.gettz() will be removed in future versions, to use the dateutil-provided zoneinfo files, instantiate a ZoneInfoFile object and use ZoneInfoFile.zones.get() instead. See the documentation for details.r   )
r   r   DeprecationWarninglen_CLASS_ZONE_INSTANCEappendr   r   r)   r7   )r    r   r   r   r   m   s    c                   C   s2   t dt ttdkr(ttt  td jS )a!   Get the zonefile metadata

    See `zonefile_metadata`_

    :returns:
        A dictionary with the database metadata

    .. deprecated:: 2.6
        See deprecation warning in :func:`zoneinfo.gettz`. To get metadata,
        query the attribute ``zoneinfo.ZoneInfoFile.metadata``.
    zzoneinfo.gettz_db_metadata() will be removed in future versions, to use the dateutil-provided zoneinfo files, ZoneInfoFile object and query the 'metadata' attribute instead. See the documentation for details.r   )	r   r   r;   r<   r=   r>   r   r   r3   r   r   r   r   r      s    )F)r   r1   tarfiler   pkgutilr   ior   Zdateutil.tzr   Z_tzfile__all__r   r!   r   objectr   r=   r   r   r   r   r   r   r   <module>   s   
/
&U
    ^|
                     @   s4   d Z ddlZddddgZdZdZd	Zefd
dZdS )zx
This module offers a generic easter computing method for any given year, using
Western, Orthodox or Julian algorithms.
    NeasterEASTER_JULIANEASTER_ORTHODOXEASTER_WESTERN         c                 C   sj  d|  krdksn t d| }|d }d}|dk rd| d d }||d  | d	 }|d
krd}|dkr||d  d |d d d  }n|d }||d  d| d d  d|  d d }||d d|d d|d   d| d     }||d  | d
 | |d  d	 }|| | }	d|	d |	d d  d  }
d|	d d  }tt|t|t|
S )a  
    This method was ported from the work done by GM Arts,
    on top of the algorithm by Claus Tondering, which was
    based in part on the algorithm of Ouding (1940), as
    quoted in "Explanatory Supplement to the Astronomical
    Almanac", P.  Kenneth Seidelmann, editor.

    This algorithm implements three different easter
    calculation methods:

    1 - Original calculation in Julian calendar, valid in
        dates after 326 AD
    2 - Original method, with date converted to Gregorian
        calendar, valid in years 1583 to 4099
    3 - Revised method, in Gregorian calendar, valid in
        years 1583 to 4099 as well

    These methods are represented by the constants:

    * ``EASTER_JULIAN   = 1``
    * ``EASTER_ORTHODOX = 2``
    * ``EASTER_WESTERN  = 3``

    The default method is method 3.

    More about the algorithm may be found at:

    `GM Arts: Easter Algorithms <http://www.gmarts.org/index.php?go=415>`_

    and

    `The Calendar FAQ: Easter <https://www.tondering.dk/claus/cal/easter.php>`_

    r   r   zinvalid method   r               r   
   i@  d                                 (         )
ValueErrordatetimedateint)yearmethodygeijchpdm r-   PC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\easter.pyr      s(    $",0$)__doc__r   __all__r   r   r   r   r-   r-   r-   r.   <module>   s   U
    ^Ha                     @   s   d dl Z d dlZd dlZd dlmZ d dlmZ d dlmZ ddl	m
Z
 edd ed	D  \ZZZZZZZZd
dddddddgZG dd
 d
eZdd ZdS )    N)copysign)integer_types)warn   weekdayc                 c   s   | ]}t |V  qd S Nr   .0x r   WC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\relativedelta.py	<genexpr>   s     r      relativedeltaMOTUWETHFRSASUc                   @   s   e Zd ZdZd)ddZdd Zedd	 Zejd
d	 Zdd Z	dd Z
dd Zdd Zdd Zdd Zdd Zdd Zdd ZeZdd ZeZdd  Zd!d" Zd#d$ Zd%d& ZeZd'd( ZdS )*r   a;  
    The relativedelta type is designed to be applied to an existing datetime and
    can replace specific components of that datetime, or represents an interval
    of time.

    It is based on the specification of the excellent work done by M.-A. Lemburg
    in his
    `mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/>`_ extension.
    However, notice that this type does *NOT* implement the same algorithm as
    his work. Do *NOT* expect it to behave like mx.DateTime's counterpart.

    There are two different ways to build a relativedelta instance. The
    first one is passing it two date/datetime classes::

        relativedelta(datetime1, datetime2)

    The second one is passing it any number of the following keyword arguments::

        relativedelta(arg1=x,arg2=y,arg3=z...)

        year, month, day, hour, minute, second, microsecond:
            Absolute information (argument is singular); adding or subtracting a
            relativedelta with absolute information does not perform an arithmetic
            operation, but rather REPLACES the corresponding value in the
            original datetime with the value(s) in relativedelta.

        years, months, weeks, days, hours, minutes, seconds, microseconds:
            Relative information, may be negative (argument is plural); adding
            or subtracting a relativedelta with relative information performs
            the corresponding arithmetic operation on the original datetime value
            with the information in the relativedelta.

        weekday: 
            One of the weekday instances (MO, TU, etc) available in the
            relativedelta module. These instances may receive a parameter N,
            specifying the Nth weekday, which could be positive or negative
            (like MO(+1) or MO(-2)). Not specifying it is the same as specifying
            +1. You can also use an integer, where 0=MO. This argument is always
            relative e.g. if the calculated date is already Monday, using MO(1)
            or MO(-1) won't change the day. To effectively make it absolute, use
            it in combination with the day argument (e.g. day=1, MO(1) for first
            Monday of the month).

        leapdays:
            Will add given days to the date found, if year is a leap
            year, and the date found is post 28 of february.

        yearday, nlyearday:
            Set the yearday or the non-leap year day (jump leap days).
            These are converted to day/month/leapdays information.

    There are relative and absolute forms of the keyword
    arguments. The plural is relative, and the singular is
    absolute. For each argument in the order below, the absolute form
    is applied first (by setting each attribute to that value) and
    then the relative form (by adding the value to the attribute).

    The order of attributes considered when this relativedelta is
    added to a datetime is:

    1. Year
    2. Month
    3. Day
    4. Hours
    5. Minutes
    6. Seconds
    7. Microseconds

    Finally, weekday is applied, using the rule described above.

    For example

    >>> from datetime import datetime
    >>> from dateutil.relativedelta import relativedelta, MO
    >>> dt = datetime(2018, 4, 9, 13, 37, 0)
    >>> delta = relativedelta(hours=25, day=1, weekday=MO(1))
    >>> dt + delta
    datetime.datetime(2018, 4, 2, 14, 37)

    First, the day is set to 1 (the first of the month), then 25 hours
    are added, to get to the 2nd day and 14th hour, finally the
    weekday is applied, but since the 2nd is already a Monday there is
    no effect.

    Nr   c                 C   s  |r|rt |tjr$t |tjs,tdt |tjt |tjkr~t |tjsbtj| }nt |tjs~tj| }d| _d| _d| _d| _	d| _
d| _d| _d| _d | _d | _d | _d | _d | _d | _d | _d | _d| _|j|j d |j|j  }| | | |}||k r*tj}d}n
tj}d}|||r`||7 }| | | |}q4|| }|j|jd  | _|j| _n~tdd ||fD rtd	t|| _t|| _||d
  | _|| _	|| _
|	| _|
| _|| _|| _|| _|| _|| _|| _|| _|| _tdd |||||||fD r<tdt  t |t!rTt"| | _n|| _d}|rj|}n|r|}|dkrd| _	|rddddddddddddg}t#|D ]H\}}||kr|d | _|dkr|| _n|||d   | _ qqtd| | $  d S )Nz&relativedelta only diffs datetime/dater      r   iQ c                 s   s"   | ]}|d k	o|t |kV  qd S r   intr	   r   r   r   r      s     z)relativedelta.__init__.<locals>.<genexpr>zGNon-integer years and months are ambiguous and not currently supported.r   c                 s   s"   | ]}|d k	ot ||kV  qd S r   r   r	   r   r   r   r      s   zNon-integer value passed as absolute information. This is not a well-defined condition and will raise errors in future versions.;      Z   x               i  i0  iN  in  zinvalid year day (%d))%
isinstancedatetimedate	TypeErrorfromordinal	toordinalyearsmonthsdaysleapdayshoursminutessecondsmicrosecondsyearmonthdayr   hourminutesecondmicrosecond	_has_time_set_months__radd__operatorgtltany
ValueErrorr   r   DeprecationWarningr   weekdays	enumerate_fix)selfZdt1Zdt2r*   r+   r,   r-   weeksr.   r/   r0   r1   r2   r3   r4   r   ZyeardayZ	nlyeardayr5   r6   r7   r8   Zdtmcompare	incrementdeltaZydayZydayidxidxZydaysr   r   r   __init__i   s    








  

    



zrelativedelta.__init__c                 C   s  t | jdkrHt| j}t| j| d\}}|| | _|  j|| 7  _t | jdkrt| j}t| j| d\}}|| | _|  j|| 7  _t | jdkrt| j}t| j| d\}}|| | _|  j|| 7  _t | jdkr"t| j}t| j| d\}}|| | _|  j|| 7  _t | jdkrlt| j}t| j| d\}}|| | _|  j	|| 7  _	| js| js| js| js| j
d k	s| jd k	s| jd k	s| jd k	rd	| _nd
| _d S )Ni?B i@B r   <            r   r   r   )absr1   _signdivmodr0   r/   r.   r,   r+   r*   r5   r6   r7   r8   r9   )rE   sdivmodr   r   r   rD      sH    









 zrelativedelta._fixc                 C   s   t | jd S )Ng      @)r   r,   rE   r   r   r   rF     s    zrelativedelta.weeksc                 C   s   | j | jd  |d  | _ d S )Nr   )r,   rF   )rE   valuer   r   r   rF     s    c                 C   sR   || _ t| j dkrHt| j }t| j | d\}}|| | _ || | _nd| _d S )NrO   r   r   )r+   rP   rQ   rR   r*   )rE   r+   rS   rT   rU   r   r   r   r:     s    

zrelativedelta._set_monthsc           	      C   s   t | j}t| jd| j|   d}t |}t| jd||   d}t |}t| jd||   d}t |}t| jd||   }| j| j| j	|||||| j
| j| j| j| j| j| j| j| jdS )aC  
        Return a version of this object represented entirely using integer
        values for the relative attributes.

        >>> relativedelta(days=1.5, hours=2).normalized()
        relativedelta(days=+1, hours=+14)

        :return:
            Returns a :class:`dateutil.relativedelta.relativedelta` object.
        rN   rO   rL   
      g    .Ar*   r+   r,   r.   r/   r0   r1   r-   r2   r3   r4   r   r5   r6   r7   r8   )r   r,   roundr.   r/   r0   r1   	__class__r*   r+   r-   r2   r3   r4   r   r5   r6   r7   r8   )	rE   r,   Zhours_fr.   Z	minutes_fr/   Z	seconds_fr0   r1   r   r   r   
normalized  s0    
       zrelativedelta.normalizedc                 C   sd  t |tr| j|j| j |j| j |j| j |j| j |j| j |j| j |j	| j	 |j
p`| j
|jd k	rp|jn| j|jd k	r|jn| j|jd k	r|jn| j|jd k	r|jn| j|jd k	r|jn| j|jd k	r|jn| j|jd k	r|jn| j|jd k	r|jn| jdS t |tjrp| j| j| j| j|j | j| j| j|j | j	|j	 | j
| j| j| j| j| j| j| j| jdS t |tjstS | jrt |tjstj| }| jp|j| j }| jp|j}| jr6dt| j  krdksn t|| j7 }|dkr|d7 }|d8 }n|dk r6|d8 }|d7 }tt||d | jpR|j}|||d}dD ]"}t| |}|d k	rf|||< qf| j}| j
r|dkrt |r|| j
7 }|j!f |tj|| j| j| j| j	d }	| jr`| jj| jj"pd }
}t|d d }|d	kr4|d|	  |
 d 7 }n||	 |
 d 7 }|d
9 }|	tj|d7 }	|	S )NrZ   r   r   )r2   r3   r4   )r5   r6   r7   r8      )r,   r.   r/   r0   r1   r   r   r   )r,   )#r$   r   r\   r*   r+   r,   r.   r/   r0   r1   r-   r2   r3   r4   r   r5   r6   r7   r8   r%   	timedeltar&   NotImplementedr9   r(   r)   rP   AssertionErrormincalendar
monthrangegetattrisleapreplacen)rE   otherr2   r3   r4   replattrrW   r,   retr   ZnthZjumpdaysr   r   r   __add__=  s    









$








zrelativedelta.__add__c                 C   s
   |  |S r   )rm   rE   ri   r   r   r   r;     s    zrelativedelta.__radd__c                 C   s   |   |S r   )__neg__r;   rn   r   r   r   __rsub__  s    zrelativedelta.__rsub__c                 C   s  t |tstS | j| j|j | j|j | j|j | j|j | j|j | j	|j	 | j
|j
 | jpb|j| jd k	rr| jn|j| jd k	r| jn|j| jd k	r| jn|j| jd k	r| jn|j| jd k	r| jn|j| jd k	r| jn|j| jd k	r| jn|j| jd k	r| jn|jdS NrZ   )r$   r   r`   r\   r*   r+   r,   r.   r/   r0   r1   r-   r2   r3   r4   r   r5   r6   r7   r8   rn   r   r   r   __sub__  s:    








zrelativedelta.__sub__c                 C   sf   | j t| jt| jt| jt| jt| jt| jt| j| j	| j
| j| j| j| j| j| j| jdS rq   )r\   rP   r*   r+   r,   r.   r/   r0   r1   r-   r2   r3   r4   r   r5   r6   r7   r8   rV   r   r   r   __abs__  s"    zrelativedelta.__abs__c                 C   sX   | j | j | j | j | j | j | j | j | j| j	| j
| j| j| j| j| j| jdS rq   )r\   r*   r+   r,   r.   r/   r0   r1   r-   r2   r3   r4   r   r5   r6   r7   r8   rV   r   r   r   ro     s"    
zrelativedelta.__neg__c                 C   s   | j  o| j o| j o| j o| j o| j o| j o| j o| jd ko| j	d ko| j
d ko| jd ko| jd ko| jd ko| jd ko| jd k S r   rZ   rV   r   r   r   __bool__  s>    	
zrelativedelta.__bool__c                 C   s   zt |}W n tk
r$   t Y S X | jt| j| t| j| t| j| t| j| t| j	| t| j
| t| j| | j| j| j| j| j| j| j| j| jdS rq   )floatr'   r`   r\   r   r*   r+   r,   r.   r/   r0   r1   r-   r2   r3   r4   r   r5   r6   r7   r8   )rE   ri   fr   r   r   __mul__  s*    
zrelativedelta.__mul__c                 C   sD  t |tstS | js|jrt| jr&|js*dS | jj|jjkr>dS | jj|jj }}||krt|rd|dkrp|rt|dkstdS | j|jkoB| j|jkoB| j|jkoB| j|jkoB| j	|j	koB| j
|j
koB| j|jkoB| j|jkoB| j|jkoB| j|jkoB| j|jkoB| j|jkoB| j|jkoB| j|jkoB| j|jkS )NFr   )r$   r   r`   r   rh   r*   r+   r,   r.   r/   r0   r1   r-   r2   r3   r4   r5   r6   r7   r8   )rE   ri   Zn1Zn2r   r   r   __eq__  sN    
 







	






zrelativedelta.__eq__c                 C   sH   t | j| j| j| j| j| j| j| j| j	| j
| j| j| j| j| j| jfS r   )hashr   r*   r+   r,   r.   r/   r0   r1   r-   r2   r3   r4   r5   r6   r7   r8   rV   r   r   r   __hash__#  s$    zrelativedelta.__hash__c                 C   s   |  | S r   )rx   rn   r   r   r   __ne__7  s    zrelativedelta.__ne__c                 C   s4   zdt | }W n tk
r(   t Y S X | |S Nr   )ru   r'   r`   rw   )rE   ri   Z
reciprocalr   r   r   __div__:  s
    
zrelativedelta.__div__c                 C   s|   g }dD ]&}t | |}|r|dj||d qdD ].}t | |}|d k	r4|dj|t|d q4dj| jjd|dS )	N)r*   r+   r,   r-   r.   r/   r0   r1   z{attr}={value:+g})rk   rW   )r2   r3   r4   r   r5   r6   r7   r8   z{attr}={value}z{classname}({attrs})z, )	classnameattrs)re   appendformatreprr\   __name__join)rE   lrk   rW   r   r   r   __repr__D  s    


zrelativedelta.__repr__)NNr   r   r   r   r   r   r   r   r   NNNNNNNNNN)r   
__module____qualname____doc__rK   rD   propertyrF   setterr:   r]   rm   r;   rp   rr   rs   ro   rt   __nonzero__rw   __rmul__rx   rz   r{   r}   __truediv__r   r   r   r   r   r      sZ   V                                  
~!


#Wc                 C   s   t td| S r|   )r   r   )r   r   r   r   rQ   T  s    rQ   )r%   rc   r<   mathr   sixr   warningsr   Z_commonr   tupleranger   r   r   r   r   r   r   rB   __all__objectr   rQ   r   r   r   r   <module>   s   (    FU
    ^                    @   sR  d Z ddlZddlZddlZddlZddlZzddlmZ W n  ek
r\   ddl	mZ Y nX ddl
mZmZ ddlmZmZ ddlZddlmZ ddlmZ d	d
dddddddddddddddgZedgd dgd  dgd  dgd  d gd  d!gd  d"gd  d#gd  d$gd  d%gd  d&gd  d'gd  dgd"  ZeeZeeddeeddeedd(  ZZZeee e e e e e e e e e e edd"  ZeeZeed)deed*deed+d  ZZZeee e e e e e e e e e e edd"  Z ee Z!d,Z"d-Z#dddddd d!gd. Z$[[[ed/= ed/= e!d= eeZeeZdddddddgZ%eed"\Z&Z'Z(Z)Z*Z+Z,da-da.G d0d1 d1eZed2d3 ed"D  \Z/Z0Z1Z2Z3Z4Z5Z6d4d5 Z7G d6d7 d7e8Z9G d8d	 d	e9Z:G d9d: d:e8Z;G d;d
 d
e9Z<G d<d= d=e8Z=e= Z>dS )>z
The rrule module offers a small, complete, and very fast, implementation of
the recurrence rules documented in the
`iCalendar RFC <https://tools.ietf.org/html/rfc5545>`_,
including support for caching of results.
    N)gcd)advance_iteratorinteger_types)_threadrange   weekday)warnrrulerrulesetrrulestrYEARLYMONTHLYWEEKLYDAILYHOURLYMINUTELYSECONDLYMOTUWETHFRSASU                              	   
             iii)r   r   <   [   y               i  i1  iO  n  )r   r   ;   Z   x               i  i0  iN  m  7   r3   c                       s"   e Zd ZdZd fdd	Z  ZS )r	   z7
    This version of weekday does not allow n = 0.
    Nc                    s&   |dkrt dtt| || d S )Nr   zCan't create weekday with n==0)
ValueErrorsuperr	   __init__)selfZwkdayn	__class__ OC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\rrule.pyr>   E   s    zweekday.__init__)N)__name__
__module____qualname____doc__r>   __classcell__rC   rC   rA   rD   r	   A   s   r	   c                 c   s   | ]}t |V  qd S Nr   .0xrC   rC   rD   	<genexpr>L   s     rN   c                    s    fdd}|S )zT
    Decorator for rruleset methods which may invalidate the
    cached length.
    c                    s    | f||}|    |S rJ   )_invalidate_cache)r?   argskwargsrvfrC   rD   
inner_funcT   s    z&_invalidates_cache.<locals>.inner_funcrC   )rT   rU   rC   rS   rD   _invalidates_cacheO   s    rV   c                   @   sn   e Zd ZdddZdd Zdd Zdd	 Zd
d Zdd Zdd Z	dddZ
dddZdddZdddZdS )	rrulebaseFc                 C   s4   |rg | _ t | _|   nd | _ d| _d | _d S NF)_cacher   allocate_lock_cache_lockrO   _cache_complete_lenr?   cacherC   rC   rD   r>   ]   s    

zrrulebase.__init__c                 C   s.   | j rt| jS | jd kr"|  S |  S d S rJ   )r\   iterrY   _iter_iter_cachedr?   rC   rC   rD   __iter__g   s
    

zrrulebase.__iter__c                 C   s>   | j d k	r4g | _ d| _|  | _| j r4| j  d | _d S rX   )rY   r\   ra   
_cache_genr[   lockedreleaser]   rc   rC   rC   rD   rO   o   s    



zrrulebase._invalidate_cachec                 c   s   d}| j }| j}| jj}| jj}|r|t|kr|  | jr>qz tdD ]}|t	| qHW n( t
k
r   d  | _ }d| _Y qY nX |  || V  |d7 }q || jk r|| V  |d7 }qd S )Nr   r'   Tr   )re   rY   r[   acquirerg   lenr\   r   appendr   StopIterationr]   )r?   igenr_   rh   rg   jrC   rC   rD   rb   z   s.    





zrrulebase._iter_cachedc                 C   s   | j r| j| S t|trd|jr:|jdk r:tt| | S tt| |j	pJd|j
pTtj|jp\dS n\|dkrt| }zt|d D ]}t|}qW n tk
r   tY nX |S tt| | S d S )Nr   r   )r\   rY   
isinstanceslicesteplistr`   	itertoolsislicestartstopsysmaxsizer   r   rk   
IndexError)r?   itemrm   rl   resrC   rC   rD   __getitem__   s&    



zrrulebase.__getitem__c                 C   s:   | j r|| jkS | D ] }||kr& dS ||kr dS qdS )NTFr\   rY   )r?   rz   rl   rC   rC   rD   __contains__   s    
zrrulebase.__contains__c                 C   s   | j dkr| D ]}q| j S )z Returns the number of recurrences in this set. It will have go
            trough the whole recurrence, if this hasn't been done before. N)r]   )r?   rM   rC   rC   rD   count   s    
zrrulebase.countc                 C   sT   | j r| j}n| }d}|r6|D ]}||kr. qP|}qn|D ]}||krJ qP|}q:|S )z Returns the last recurrence before the given datetime instance. The
            inc keyword defines what happens if dt is an occurrence. With
            inc=True, if dt itself is an occurrence, it will be returned. Nr}   )r?   dtincrm   lastrl   rC   rC   rD   before   s    zrrulebase.beforec                 C   sP   | j r| j}n| }|r2|D ]}||kr|  S qn|D ]}||kr6|  S q6dS )z Returns the first recurrence after the given datetime instance. The
            inc keyword defines what happens if dt is an occurrence. With
            inc=True, if dt itself is an occurrence, it will be returned.  Nr}   )r?   r   r   rm   rl   rC   rC   rD   after   s    
zrrulebase.afterNc                 c   sf   | j r| j}n| }|r dd }ndd }d}|D ]0}|||r0|dk	rZ|d7 }||krZ qb|V  q0dS )aH  
        Generator which yields up to `count` recurrences after the given
        datetime instance, equivalent to `after`.

        :param dt:
            The datetime at which to start generating recurrences.

        :param count:
            The maximum number of recurrences to generate. If `None` (default),
            dates are generated until the recurrence rule is exhausted.

        :param inc:
            If `dt` is an instance of the rule and `inc` is `True`, it is
            included in the output.

        :yields: Yields a sequence of `datetime` objects.
        c                 S   s   | |kS rJ   rC   dcZdtcrC   rC   rD   <lambda>       z"rrulebase.xafter.<locals>.<lambda>c                 S   s   | |kS rJ   rC   r   rC   rC   rD   r      r   r   Nr   r}   )r?   r   r   r   rm   compr@   drC   rC   rD   xafter   s    

zrrulebase.xafterr   c           	      C   s   | j r| j}n| }d}g }|r^|D ]8}||kr4 qq"|sP||krZd}|| q"|| q"n>|D ]8}||krt qqb|s||krd}|| qb|| qb|S )a   Returns all the occurrences of the rrule between after and before.
        The inc keyword defines what happens if after and/or before are
        themselves occurrences. With inc=True, they will be included in the
        list, if they are found in the recurrence set. FT)r\   rY   rj   )	r?   r   r   r   r   rm   startedlrl   rC   rC   rD   between  s.    zrrulebase.between)F)F)F)NF)Fr   )rE   rF   rG   r>   rd   rO   rb   r|   r~   r   r   r   r   r   rC   rC   rC   rD   rW   \   s   




)rW   c                       sJ   e Zd ZdZd fdd	Zdd Zd	d
 Zdd Zdd Zdd Z	  Z
S )r   aP  
    That's the base of the rrule operation. It accepts all the keywords
    defined in the RFC as its constructor parameters (except byday,
    which was renamed to byweekday) and more. The constructor prototype is::

            rrule(freq)

    Where freq must be one of YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY,
    or SECONDLY.

    .. note::
        Per RFC section 3.3.10, recurrence instances falling on invalid dates
        and times are ignored rather than coerced:

            Recurrence rules may generate recurrence instances with an invalid
            date (e.g., February 30) or nonexistent local time (e.g., 1:30 AM
            on a day where the local time is moved forward by an hour at 1:00
            AM).  Such recurrence instances MUST be ignored and MUST NOT be
            counted as part of the recurrence set.

        This can lead to possibly surprising behavior when, for example, the
        start date occurs at the end of the month:

        >>> from dateutil.rrule import rrule, MONTHLY
        >>> from datetime import datetime
        >>> start_date = datetime(2014, 12, 31)
        >>> list(rrule(freq=MONTHLY, count=4, dtstart=start_date))
        ... # doctest: +NORMALIZE_WHITESPACE
        [datetime.datetime(2014, 12, 31, 0, 0),
         datetime.datetime(2015, 1, 31, 0, 0),
         datetime.datetime(2015, 3, 31, 0, 0),
         datetime.datetime(2015, 5, 31, 0, 0)]

    Additionally, it supports the following keyword arguments:

    :param dtstart:
        The recurrence start. Besides being the base for the recurrence,
        missing parameters in the final recurrence instances will also be
        extracted from this date. If not given, datetime.now() will be used
        instead.
    :param interval:
        The interval between each freq iteration. For example, when using
        YEARLY, an interval of 2 means once every two years, but with HOURLY,
        it means once every two hours. The default interval is 1.
    :param wkst:
        The week start day. Must be one of the MO, TU, WE constants, or an
        integer, specifying the first day of the week. This will affect
        recurrences based on weekly periods. The default week start is got
        from calendar.firstweekday(), and may be modified by
        calendar.setfirstweekday().
    :param count:
        If given, this determines how many occurrences will be generated.

        .. note::
            As of version 2.5.0, the use of the keyword ``until`` in conjunction
            with ``count`` is deprecated, to make sure ``dateutil`` is fully
            compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/
            html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``
            **must not** occur in the same call to ``rrule``.
    :param until:
        If given, this must be a datetime instance specifying the upper-bound
        limit of the recurrence. The last recurrence in the rule is the greatest
        datetime that is less than or equal to the value specified in the
        ``until`` parameter.

        .. note::
            As of version 2.5.0, the use of the keyword ``until`` in conjunction
            with ``count`` is deprecated, to make sure ``dateutil`` is fully
            compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/
            html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``
            **must not** occur in the same call to ``rrule``.
    :param bysetpos:
        If given, it must be either an integer, or a sequence of integers,
        positive or negative. Each given integer will specify an occurrence
        number, corresponding to the nth occurrence of the rule inside the
        frequency period. For example, a bysetpos of -1 if combined with a
        MONTHLY frequency, and a byweekday of (MO, TU, WE, TH, FR), will
        result in the last work day of every month.
    :param bymonth:
        If given, it must be either an integer, or a sequence of integers,
        meaning the months to apply the recurrence to.
    :param bymonthday:
        If given, it must be either an integer, or a sequence of integers,
        meaning the month days to apply the recurrence to.
    :param byyearday:
        If given, it must be either an integer, or a sequence of integers,
        meaning the year days to apply the recurrence to.
    :param byeaster:
        If given, it must be either an integer, or a sequence of integers,
        positive or negative. Each integer will define an offset from the
        Easter Sunday. Passing the offset 0 to byeaster will yield the Easter
        Sunday itself. This is an extension to the RFC specification.
    :param byweekno:
        If given, it must be either an integer, or a sequence of integers,
        meaning the week numbers to apply the recurrence to. Week numbers
        have the meaning described in ISO8601, that is, the first week of
        the year is that containing at least four days of the new year.
    :param byweekday:
        If given, it must be either an integer (0 == MO), a sequence of
        integers, one of the weekday constants (MO, TU, etc), or a sequence
        of these constants. When given, these variables will define the
        weekdays where the recurrence will be applied. It's also possible to
        use an argument n for the weekday instances, which will mean the nth
        occurrence of this weekday in the period. For example, with MONTHLY,
        or with YEARLY and BYMONTH, using FR(+1) in byweekday will specify the
        first friday of the month where the recurrence happens. Notice that in
        the RFC documentation, this is specified as BYDAY, but was renamed to
        avoid the ambiguity of that keyword.
    :param byhour:
        If given, it must be either an integer, or a sequence of integers,
        meaning the hours to apply the recurrence to.
    :param byminute:
        If given, it must be either an integer, or a sequence of integers,
        meaning the minutes to apply the recurrence to.
    :param bysecond:
        If given, it must be either an integer, or a sequence of integers,
        meaning the seconds to apply the recurrence to.
    :param cache:
        If given, it must be a boolean value specifying to enable or disable
        caching of results. If you will use the same rrule instance multiple
        times, enabling caching will improve the performance considerably.
     Nr   Fc                    s  t t| | |sL|r8|jr8tjj|jdjdd}qvtj jdd}n*t|tjsjtj|	 }n|jdd}|| _
|j| _|| _|| _|| _i | _|rt|tjstj|	 }|| _| j
r| jr| j
jd k	| jjd k	krtd|d k	r|rtdt |d krt | _nt|tr2|| _n|j| _|d krLd | _nt|tr|dks|d|  krzdksn td|f| _nDt|| _| jD ]2}|dksd|  krdksn tdq| jr| j| jd	< |d kr|
d kr|	d kr|d kr|d kr|tkrN|d kr<|j}d | jd
< |j}	d | jd< n8|tkrj|j}	d | jd< n|tkr| }d | jd< |d krd | _ n<t|tr|f}tt!t"|| _ d
| jkr| j | jd
< |
d krd | _#n0t|
tr|
f}
tt!t"|
| _#| j#| jd< |d k	rdt$s2ddl%m$a$ t|trH|f| _&ntt!|| _&| j&| jd< nd | _&|	d krd| _'d| _(npt|	tr|	f}	t"|	}	tt!dd |	D | _'tt!dd |	D | _(d| jkrtt)*| j'| j(| jd< |d krd | _+n0t|tr|f}tt!t"|| _+| j+| jd< |d krNd | _,d | _-n.t|tsft.|drl|f}t" | _,t" | _-|D ]V}t|tr| j,/| n6|j0r|tkr| j,/|j n| j-/|j|j0f q| j,sd | _,n| j-sd | _-| j,d k	r$tt!| j,| _,dd | j,D }nd}| j-d k	rVtt!| j-| _-dd | j-D }nd}d| jkr|tt)*||| jd< |d kr|t1k r|j2h| _3nd | _3nXt|tr|f}|t1kr| j4|j2|dd| _3n
t"|| _3tt!| j3| _3| j3| jd< |d kr$|t5k r|j6h| _7nd | _7nXt|tr6|f}|t5krV| j4|j6|dd| _7n
t"|| _7tt!| j7| _7| j7| jd< |d kr|t8k r|j9f| _:nd | _:nbt|tr|f}t"|| _:|t8kr| j4|j9|dd| _:n
t"|| _:tt!| j:| _:| j:| jd< | jt1krd | _;nbg | _;| j3D ]>}| j7D ]0}| j:D ]"}| j;<tj=|||| jd q:q0q&| j;>  t| j;| _;d S ) Ntzr   )microsecondzJRRULE UNTIL values must be specified in UTC when DTSTART is timezone-awarezUsing both 'count' and 'until' is inconsistent with RFC 5545 and has been deprecated in dateutil. Future versions will raise an error.ir2   z:bysetpos must be between 1 and 366, or between -366 and -1bysetposbymonth
bymonthday	byweekday	byyearday)easterbyeasterrC   c                 s   s   | ]}|d kr|V  qdS r   NrC   rK   rC   rC   rD   rN   2  s      z!rrule.__init__.<locals>.<genexpr>c                 s   s   | ]}|d k r|V  qdS r   rC   rK   rC   rC   rD   rN   3  s      byweeknor@   c                 S   s   g | ]}t |qS rC   r   rK   rC   rC   rD   
<listcomp>a  s     z"rrule.__init__.<locals>.<listcomp>c                 S   s   g | ]}t | qS rC   r   rK   rC   rC   rD   r   g  s        )ru   byxxxbasebyhourr+   byminutebysecondtzinfo)?r=   r   r>   r   datetimenowreplacero   fromordinal	toordinal_dtstart_tzinfo_freq	_interval_count_original_rule_untilr<   r
   DeprecationWarningcalendarfirstweekday_wkstr   r	   	_bysetpostupler   monthdayr   r   _bymonthsortedset
_byyeardayr   dateutil	_byeaster_bymonthday_bynmonthdayrs   chain	_byweekno
_byweekday_bynweekdayhasattraddr@   r   hour_byhour_rrule__construct_bysetr   minute	_byminuter   second	_bysecond_timesetrj   timesort)r?   freqdtstartintervalwkstr   untilr   r   r   r   r   r   r   r   r   r   r_   poswdayZorig_byweekdayZorig_bynweekdayr   r   r   rA   rC   rD   r>     sr   


$


$














 




















zrrule.__init__c              	   C   s  g }dgd \}}}| j rD|| j d | j  dd \}}}dt| j  g}| jdkrr|dt| j  | jr|dt	t
| jd	d
   | jdk	r|dt| j  | jr|| jd | jddk	r@t| j}g }|d D ]>}|jr&|dj|jt	|d	d
 d q|t	| q||d< n| j}d}	dD ]>\}
}||}|rN||	j|
ddd |D d qN|dd|  d|S )z
        Output a string that would generate this RRULE if passed to rrulestr.
        This is mostly compatible with RFC5545, except for the
        dateutil-specific extension BYEASTER.
        Nr   zDTSTART:%Y%m%dT%H%M%Sr#   zFREQ=r   z	INTERVAL=zWKST=r   r   zCOUNT=zUNTIL=%Y%m%dT%H%M%Sr   z{n:+d}{wday})r@   r   z{name}={vals})
)ZBYSETPOSr   )ZBYMONTHr   )Z
BYMONTHDAYr   )Z	BYYEARDAYr   )ZBYWEEKNOr   )ZBYDAYr   )ZBYHOURr   )ZBYMINUTEr   )ZBYSECONDr   )ZBYEASTERr   ,c                 s   s   | ]}t |V  qd S rJ   )str)rL   vrC   rC   rD   rN     s   z rrule.__str__.<locals>.<genexpr>)namevalsRRULE:;
)r   rj   strftime	timetuple	FREQNAMESr   r   r   r   reprr	   r   r   r   getdictr@   formatjoin)r?   outputhmspartsZoriginal_ruleZwday_stringsr   Zpartfmtr   keyvaluerC   rC   rD   __str__  sF    
 





zrrule.__str__c                 K   sN   | j | j| j| j| j| j| jdkr&dndd}|| j || t	f |S )zReturn new rrule with same attributes except for those attributes given new
           values by whichever keyword arguments are specified.NFT)r   r   r   r   r   r   r_   )
r   r   r   r   r   r   rY   updater   r   )r?   rQ   Z
new_kwargsrC   rC   rD   r     s    
zrrule.replacec           5      c   s  | j  \	}}}}}}}}}	| j}
| j}| j}| j}| j}| j}| j}| j	}| j
}| j}| j}| j}| j}| j}| j}t| }||| t|jt|jt|jt|jt|jt|jt|ji|
 }|
tk r| j}nt|jt|j t|j!i|
 }|
tkr| jr|| jks@|
tkr"| jr"|| jks@|
tkrF| jrF|| jkrFd}n||||}d}| j"}||||\}} }!d}"|| |! D ]}#|r|j#|# |ks~|r|j$|# r~|r|j%|# |ks~|j&r|j&|# r~|r|j'|# r~|s|r|j(|# |kr|j)|# |ks~|r~|#|j*k rF|#d |krF|j* |# |ks~|#|j*kr~|#d |j* |kr~|j+ |# |j* |kr~d ||#< d}"q~|r|rg }$|D ]}%|%dk rt,|%t-|\}&}'nt,|%d t-|\}&}'z&dd || |! D |& }#||' }(W n t.k
r   Y n6X t/j01|j2|# })t/j/3|)|(}*|*|$kr|$4|* q|$5  |$D ]d}*|r||*|kr||| _6 d S |*| j kr\|d k	r|d8 }|dk r|| _6 d S |d7 }|*V  q\n|| |! D ]}#|#d k	rt/j01|j2|# })|D ]v}(t/j/3|)|(}*|r$|*|kr$|| _6  d S |*| j kr|d k	rZ|d8 }|dk rZ|| _6  d S |d7 }|*V  qqd}+|
tkr||7 }|t/j7kr|| _6d S ||| nV|
tkr||7 }|dkrt,|d\},}-|-}||,7 }|dkrd}|d8 }|t/j7kr|| _6d S ||| n|
tkrx||krT||d d	|   | jd
  7 }n|||  | jd
  7 }|}d}+n|
tkr||7 }d}+np|
tkr|"r|d| | | 7 }|r| j8|| jdd\}.}nt,|| d\}.}|.r||.7 }d}+||||}n|
tkr|"r4|d|d |  | | 7 }d}/d}0t9|0t:||0 D ]x}1|rp| j8|| jdd\}2}nt,|| d\}2}t,||2 d\},}|,r||,7 }d}+d}"|r||krNd}/ qqN|/st;d||||}n|
tkr|"r|d|d |d  |  | | 7 }d}0d}/t9d|0t:||0 D ]}1|rX| j8|| jdd\}3}nt,|| d\}3}t,||3 d\},}|,r||,7 }t,|d\},}|,r||,7 }d}+|r||kr6|r||kr6|r||kr6d}/ qq6|/st;d||||}|+r\|dkr\t<=||d }4||4kr\||4kr||48 }|d7 }|dkrrd}|d7 }|t/j7krr|| _6d S t<=||d }4q,||| q\d S )NrC   r   Fr   Tc                 S   s   g | ]}|d k	r|qS rJ   rC   rK   rC   rC   rD   r   X  s    zrrule._iter.<locals>.<listcomp>r)   r#   r$      r   )r   r   r   i  r+   i  zCInvalid combination of interval and byhour resulting in empty rule.iQ i  iQ zMInvalid combination of interval, byhour and byminute resulting in empty rule.      )>r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   	_iterinforebuildr   ydaysetr   mdaysetr   wdaysetr   ddaysetr   r   r   r   htimesetmtimesetstimesetr   mmaskwnomaskwdaymask	nwdaymask
eastermaskmdaymask	nmdaymaskyearlennextyearlendivmodri   ry   r   dater   yearordinalcombinerj   r   r]   MAXYEAR_rrule__mod_distancer   r   r<   r   
monthrange)5r?   yearr   r   r   r   r   r	   Zyearday_r   r   r   r   r   r   r   r   r   r   Zbynmonthdayr   r   r   r   iiZ	getdaysetZtimesetZ
gettimesettotalr   Zdaysetru   endfilteredrl   Zposlistr   ZdayposZtimeposr   r  r{   ZfixdaydivmodndaysZvalidZrep_ratern   ZnhoursZnminutesZdaysinmonthrC   rC   rD   ra     s$           
		














"








zrrule._iterc                 C   sl   t  }t|tr|f}|D ]8}t| j|}|dksHt|| |d dkr|| qt|dkrhtd|S )a  
        If a `BYXXX` sequence is passed to the constructor at the same level as
        `FREQ` (e.g. `FREQ=HOURLY,BYHOUR={2,4,7},INTERVAL=3`), there are some
        specifications which cannot be reached given some starting conditions.

        This occurs whenever the interval is not coprime with the base of a
        given unit and the difference between the starting position and the
        ending position is not coprime with the greatest common denominator
        between the interval and the base. For example, with a FREQ of hourly
        starting at 17:00 and an interval of 4, the only valid values for
        BYHOUR would be {21, 1, 5, 9, 13, 17}, because 4 and 24 are not
        coprime.

        :param start:
            Specifies the starting position.
        :param byxxx:
            An iterable containing the list of allowed values.
        :param base:
            The largest allowable value for the specified frequency (e.g.
            24 hours, 60 minutes).

        This does not preserve the type of the iterable, returning a set, since
        the values should be unique and the order is irrelevant, this will
        speed up later lookups.

        In the event of an empty set, raises a :exception:`ValueError`, as this
        results in an empty rrule.
        r   r   z+Invalid rrule byxxx generates an empty set.)	r   ro   r   r   r   r  r   ri   r<   )r?   ru   r   r   ZcsetnumZi_gcdrC   rC   rD   Z__construct_byset  s    
zrrule.__construct_bysetc                 C   sL   d}t d|d D ]4}t|| j |\}}||7 }||kr||f  S qdS )a  
        Calculates the next value in a sequence where the `FREQ` parameter is
        specified along with a `BYXXX` parameter at the same "level"
        (e.g. `HOURLY` specified with `BYHOUR`).

        :param value:
            The old value of the component.
        :param byxxx:
            The `BYXXX` set, which should have been generated by
            `rrule._construct_byset`, or something else which checks that a
            valid rule is present.
        :param base:
            The largest allowable value for the specified frequency (e.g.
            24 hours, 60 minutes).

        If a valid value is not found after `base` iterations (the maximum
        number before the sequence would start to repeat), this raises a
        :exception:`ValueError`, as no valid values were found.

        This returns a tuple of `divmod(n*interval, base)`, where `n` is the
        smallest number of `interval` repetitions until the next specified
        value in `byxxx` is found.
        r   r   N)r   r  r   )r?   r   r   r   Zaccumulatorr  r  rC   rC   rD   Z__mod_distance5  s    zrrule.__mod_distance)Nr   NNNNNNNNNNNNNF)rE   rF   rG   rH   r>   r   r   ra   r   r
  rI   rC   rC   rA   rD   r   /  s6   z                            >  /c                   @   sv   e Zd Zddddddddd	d
dddddgZdd Zdd Zdd Zdd Zdd Zdd Z	dd Z
dd Zd d! Zd"S )#r   r   lastyear	lastmonthr  r  r  yearweekdayr   mranger  r  r   r   r   r   c                 C   s"   | j D ]}t| |d  q|| _d S rJ   )	__slots__setattrr   )r?   r   attrrC   rC   rD   r>   \  s    
z_iterinfo.__init__c                 C   s  | j }|| jkr(dt| | _dt|d  | _t|dd}| | _	|
 | _t|dd
 }| jdkrt| _t| _t| _t|d  | _t| _n&t| _t| _t| _t|d  | _t| _|jsd | _nVdg| jd  | _d| j |j d  }}|dkr"d}| j| j|j d  }n
| j| }t|d\}	}
|	|
d  }|jD ]}|dk rf||d 7 }d|  k r~|ksn qL|dkr||d d  }||kr|d| 8 }n|}tdD ]0}d| j|< |d7 }| j| |jkr qLqqLd|jkrl||d  }||kr&|d| 8 }|| jk rltdD ]0}d| j|< |d7 }| j| |jkr: qlq:|r(d|jkrt|d dd
 }d| |j d }dt|d  }|dkrd}d|||j d  d d  }nd| j| d d  }nd}||jkr(t|D ]}d| j|< q|jr~|| j ksH|| jkr~g }|j!t"kr|j#r|j#D ]"}|$| j|d |d   qfnd| jfg}n$|j!t%kr| j|d |d  g}|r~dg| j | _&|D ]\}}|d8 }|jD ]\}}|dk r&||d d  }|| j| | d 8 }n*||d d  }|d| j|  | d 7 }||  krh|krn n
d| j&|< qq|j'rdg| jd  | _(t))| | j	 }|j'D ]}d| j(|| < q|| _|| _ d S )Nr:   r   r   r$   r    4   )*r   r  r   isleapr  r  r   r  r   r  r	   r  M365MASKr   MDAY365MASKr  NMDAY365MASKr  WDAYMASKr   	M365RANGEr  M366MASKMDAY366MASKNMDAY366MASK	M366RANGEr   r   r   r  r   r   r  r   r   r   rj   r   r   r   r   r   )r?   r  r   rrZ	firstydayr   Zno1wkstZ	firstwkstZwyearlenr  r  Znumweeksr@   rl   rn   ZlyearweekdayZlno1wkstZlyearlenZ	lnumweeksrangesfirstr   ZeydayoffsetrC   rC   rD   r   a  s    















"

z_iterinfo.rebuildc                 C   s   t t| jd| jfS Nr   )rr   r   r  )r?   r  r   r   rC   rC   rD   r     s    z_iterinfo.ydaysetc                 C   sH   d g| j  }| j|d |d  \}}t||D ]}|||< q0|||fS Nr   )r  r  r   )r?   r  r   r   dsetru   r  rl   rC   rC   rD   r     s
    
z_iterinfo.mdaysetc                 C   sj   d g| j d  }t||| | j }|}tdD ]*}|||< |d7 }| j| | jjkr4 q`q4|||fS )Nr$   r   )	r  r   r  r   r  r   r   r   r   )r?   r  r   r   r/  rl   ru   rn   rC   rC   rD   r     s    z_iterinfo.wdaysetc                 C   s:   d g| j  }t||| | j }|||< |||d fS r.  )r  r   r  r   r  )r?   r  r   r   r/  rl   rC   rC   rD   r     s    z_iterinfo.ddaysetc              
   C   sH   g }| j }|jD ]*}|jD ]}|tj||||jd qq|  |S Nr   )r   r   r   rj   r   r   r   r   r?   r   r   r   Ztsetr)  rC   rC   rD   r     s    

z_iterinfo.htimesetc              	   C   s<   g }| j }|jD ]}|tj||||jd q|  |S r0  )r   r   rj   r   r   r   r   r1  rC   rC   rD   r     s    
z_iterinfo.mtimesetc                 C   s   t j|||| jjdfS r0  )r   r   r   r   )r?   r   r   r   rC   rC   rD   r     s    
z_iterinfo.stimesetN)rE   rF   rG   r  r>   r   r   r   r   r   r   r   r   rC   rC   rC   rD   r   V  s0             
r   c                       sj   e Zd ZdZG dd deZd fdd	Zedd Zed	d
 Z	edd Z
edd Zdd Z  ZS )r   aL   The rruleset type allows more complex recurrence setups, mixing
    multiple rules, dates, exclusion rules, and exclusion dates. The type
    constructor takes the following keyword arguments:

    :param cache: If True, caching of results will be enabled, improving
                  performance of multiple queries considerably. c                   @   s@   e Zd Zdd Zdd ZeZdd Zdd Zd	d
 Zdd Z	dS )zrruleset._genitemc                 C   s>   zt || _||  W n tk
r,   Y nX || _|| _d S rJ   )r   r   rj   rk   genlistrm   )r?   r2  rm   rC   rC   rD   r>   "  s    
zrruleset._genitem.__init__c                 C   s^   zt | j| _W nH tk
rX   | jd | kr<t| j n| j|  t| j Y nX d S r-  )	r   rm   r   rk   r2  heapqheappopremoveheapifyrc   rC   rC   rD   __next__+  s    zrruleset._genitem.__next__c                 C   s   | j |j k S rJ   r   r?   otherrC   rC   rD   __lt__7  s    zrruleset._genitem.__lt__c                 C   s   | j |j kS rJ   r8  r9  rC   rC   rD   __gt__:  s    zrruleset._genitem.__gt__c                 C   s   | j |j kS rJ   r8  r9  rC   rC   rD   __eq__=  s    zrruleset._genitem.__eq__c                 C   s   | j |j kS rJ   r8  r9  rC   rC   rD   __ne__@  s    zrruleset._genitem.__ne__N)
rE   rF   rG   r>   r7  nextr;  r<  r=  r>  rC   rC   rC   rD   _genitem!  s   	
r@  Fc                    s,   t t| | g | _g | _g | _g | _d S rJ   )r=   r   r>   _rrule_rdate_exrule_exdater^   rA   rC   rD   r>   C  s
    zrruleset.__init__c                 C   s   | j | dS )z\ Include the given :py:class:`rrule` instance in the recurrence set
            generation. N)rA  rj   )r?   r   rC   rC   rD   r   J  s    zrruleset.rrulec                 C   s   | j | dS )z_ Include the given :py:class:`datetime` instance in the recurrence
            set generation. N)rB  rj   )r?   rdaterC   rC   rD   rE  P  s    zrruleset.rdatec                 C   s   | j | dS )z Include the given rrule instance in the recurrence set exclusion
            list. Dates which are part of the given recurrence rules will not
            be generated, even if some inclusive rrule or rdate matches them.
        N)rC  rj   )r?   exrulerC   rC   rD   rF  V  s    zrruleset.exrulec                 C   s   | j | dS )z Include the given datetime instance in the recurrence set
            exclusion list. Dates included that way will not be generated,
            even if some inclusive rrule or rdate matches them. N)rD  rj   )r?   exdaterC   rC   rD   rG  ^  s    zrruleset.exdatec                 c   sV  g }| j   | |t| j  dd | jD D ]}| || q0g }| j  | |t| j dd | jD D ]}| || qrd }d}t| t| |rL|d }|r||j	kr&|r|d |k r|d }t
| |r|d |krt|| q|r||d kr |d7 }|j	V  |j	}t
| |r|d |krt|| q|| _d S )Nc                 S   s   g | ]}t |qS rC   r`   rK   rC   rC   rD   r   i  s     z"rruleset._iter.<locals>.<listcomp>c                 S   s   g | ]}t |qS rC   rH  rK   rC   rC   rD   r   n  s     r   r   )rB  r   r@  r`   rA  rD  rC  r3  r6  r   r   heapreplacer]   )r?   Zrlistrm   ZexlistZlastdtr  ZritemZexitemrC   rC   rD   ra   e  s<    



zrruleset._iter)F)rE   rF   rG   rH   objectr@  r>   rV   r   rE  rF  rG  ra   rI   rC   rC   rA   rD   r     s   "



c                   @   s   e Zd ZdZeeeeee	e
dZddddddd	d
Zdd Zdd ZeZeZeZeZeZeZeZeZeZeZeZdd Zdd Zdd Zdd ZeZd!ddZdd Z d"ddZ!dd  Z"dS )#	_rrulestra   Parses a string representation of a recurrence rule or set of
    recurrence rules.

    :param s:
        Required, a string defining one or more recurrence rules.

    :param dtstart:
        If given, used as the default recurrence start if not specified in the
        rule string.

    :param cache:
        If set ``True`` caching of results will be enabled, improving
        performance of multiple queries considerably.

    :param unfold:
        If set ``True`` indicates that a rule string is split over more
        than one line and should be joined before processing.

    :param forceset:
        If set ``True`` forces a :class:`dateutil.rrule.rruleset` to
        be returned.

    :param compatible:
        If set ``True`` forces ``unfold`` and ``forceset`` to be ``True``.

    :param ignoretz:
        If set ``True``, time zones in parsed strings are ignored and a naive
        :class:`datetime.datetime` object is returned.

    :param tzids:
        If given, a callable or mapping used to retrieve a
        :class:`datetime.tzinfo` from a string representation.
        Defaults to :func:`dateutil.tz.gettz`.

    :param tzinfos:
        Additional time zone names / aliases which may be present in a string
        representation.  See :func:`dateutil.parser.parse` for more
        information.

    :return:
        Returns a :class:`dateutil.rrule.rruleset` or
        :class:`dateutil.rrule.rrule`
    )r   r   r   r   r   r   r   r   r   r   r   r    r"   r#   )r   r   r   r   r   r   r   c                 K   s   t ||| < d S rJ   )intlowerr?   rrkwargsr   r   rQ   rC   rC   rD   _handle_int  s    z_rrulestr._handle_intc                 K   s    dd | dD || < d S )Nc                 S   s   g | ]}t |qS rC   )rL  rK   rC   rC   rD   r     s     z._rrulestr._handle_int_list.<locals>.<listcomp>r   )splitrM  rN  rC   rC   rD   _handle_int_list  s    z_rrulestr._handle_int_listc                 K   s   | j | |d< d S )Nr   )	_freq_maprN  rC   rC   rD   _handle_FREQ  s    z_rrulestr._handle_FREQc                 K   sV   t sddlm a  z$t j||d|dd|d< W n tk
rP   tdY nX d S )Nr   parserignoretztzinfosrW  rX  r   zinvalid until date)rV  r   parser   r<   rN  rC   rC   rD   _handle_UNTIL  s    z_rrulestr._handle_UNTILc                 K   s   | j | |d< d S )Nr   )_weekday_maprN  rC   rC   rD   _handle_WKST  s    z_rrulestr._handle_WKSTc                 K   s   g }| dD ]}d|krB| d}|d }t|d dd }	n\t|rtt|D ]}
||
 dkrV qlqV|d|
 pzd}	||
d }|	rt|	}	ntd|t| j|  |	 q||d	< dS )
z:
        Two ways to specify this: +1MO or MO(+1)
        r   (r   r   Nr  z+-0123456789z$Invalid (empty) BYDAY specification.r   )rQ  rL  ri   r   r<   rj   weekdaysr\  )r?   rO  r   r   rQ   r   r   Zspltwr@   rl   rC   rC   rD   _handle_BYWEEKDAY  s"    

z_rrulestr._handle_BYWEEKDAYNFc           
   
   C   s   | ddkr.|d\}}|dkr2tdn|}i }|dD ]}	|	d\}}| }| }z t| d| |||||d W q@ tk
r   td	| Y q@ ttfk
r   td
||f Y q@X q@tf ||d|S )N:r  RRULEzunknown parameter namer   =Z_handle_rY  zunknown parameter '%s'zinvalid '%s': %s)r   r_   )findrQ  r<   uppergetattrAttributeErrorKeyErrorr   )
r?   liner   r_   rW  rX  r   r   rO  pairrC   rC   rD   _parse_rfc_rrule  s(    

z_rrulestr._parse_rfc_rrulec              	   C   s@  t sddlm a  g }d}d }	|D ]}
|
drz||
dd  }W n tk
r\   Y q Y nX |d krzddlm} |j}n2t|r|}n$t	|dd }|d krd	| }t
|||}	q |
d
krt
d|
 q |rd|
 }t
|d}q |dD ]J}t j|||d}|	d k	r0|jd kr(|j|	d}nt
d|| q|S )Nr   rU  FzTZID=r  r   r   r   z2tzids must be a callable, mapping, or None, not %s>   VALUE=DATE-TIME
VALUE=DATEzunsupported parm: z$Duplicate value parameter found in: Tr   rY  r   z*DTSTART/EXDATE specifies multiple timezone)rV  r   
startswithrQ  ri   r   Zgettzcallablerg  r<   rZ  r   r   rj   )r?   Z
date_valueparmsZ
rule_tzidsrW  tzidsrX  ZdatevalsZvalue_foundZTZIDparmZtzkeyr   Ztzlookupmsgdatestrr  rC   rC   rD   _parse_date_value  sL    


z_rrulestr._parse_date_valuec
                 C   s  |rd}d}t tdd td|}
| }| s>td|r| }d}|t|k r|| 	 }|sr||= qN|dkr|d dkr||d   |dd  7  < ||= qN|d7 }qNn|
 }|st|dkr|d	d
ks|dr| j|d ||||	dS g }g }g }g }|D ]n}|s(q|d	d
krBd}|}n|
d	d\}}|
d}|sjtd|d }|dd  }|dkr|D ]}td| q|| n|dkr|D ]}|dkrtd| q|| n|dkr|D ]}td| q|| nt|dkr8|| |||
|||	 nN|dkrz| |||
|||	}t|dkrptd| |d }ntd| q|st|dks|s|s|rts|s|rddlma t|d}|D ]}|| j||||	d q|D ].}|
dD ]}|tj|||	d qq |D ]}|| j||||	d q4|D ]}|| qX|r|r|| |S | j|d ||||	dS d S ) NTc                 S   s   |   | fS rJ   )rf  )rM   rC   rC   rD   r   \  r   z&_rrulestr._parse_rfc.<locals>.<lambda>zTZID=(?P<name>[^:]+):zempty stringr    r   rb  r  r   )r_   r   rW  rX  rc  r   zempty property namezunsupported RRULE parm: ZRDATErm  zunsupported RDATE parm: ZEXRULEzunsupported EXRULE parm: ZEXDATEZDTSTARTz"Multiple DTSTART values specified:zunsupported property: rU  )r_   )r   rW  rX  r   rY  )r   r_   rW  rX  )r   maprefindallrf  stripr<   
splitlinesri   rstriprQ  re  ro  rl  rj   extendrw  rV  r   r   r   rE  rZ  rF  rG  )r?   r   r   r_   ZunfoldZforceset
compatiblerW  rs  rX  Z
TZID_NAMESlinesrl   rj  Z	rrulevalsZ	rdatevalsZ
exrulevalsZ
exdatevalsr   r   rr  rt  ZdtvalsZrsetrv  rC   rC   rD   
_parse_rfcM  s    

" 






  

  




z_rrulestr._parse_rfcc                 K   s   | j |f|S rJ   )r  )r?   r   rQ   rC   rC   rD   __call__  s    z_rrulestr.__call__)NFFN)NFFFFFNN)#rE   rF   rG   rH   r   r   r   r   r   r   r   rS  r\  rP  rR  Z_handle_INTERVALZ_handle_COUNTZ_handle_BYSETPOSZ_handle_BYMONTHZ_handle_BYMONTHDAYZ_handle_BYYEARDAYZ_handle_BYEASTERZ_handle_BYWEEKNOZ_handle_BYHOURZ_handle_BYMINUTEZ_handle_BYSECONDrT  r[  r]  ra  Z_handle_BYDAYrl  rw  r  r  rC   rC   rC   rD   rK    s`   ,      
5        
trK  )?rH   rs   r   r   rz  rw   mathr   ImportErrorZ	fractionssixr   r   Z	six.movesr   r   r3  Z_commonr	   Zweekdaybasewarningsr
   __all__r   r%  rr   r   ZM29ZM30ZM31r&  r!  r'  r"  r(  r$  r#  r   r   r   r   r   r   r   r   r   rV  r   r   r   r   r   r   r   r_  rV   rJ  rW   r   r   r   rK  r   rC   rC   rC   rD   <module>   s              <.@.@
( T      - Do  ?U
    ^;                      @   s   d dl T dS )   )*N)Ztz.win r   r   OC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\tzwin.py<module>       U
    ^                     @   s>   d Z ddlmZ ddlmZmZ dddZdd Zd	d
 ZdS )zs
This module offers general convenience and utility functions for dealing with
datetimes.

.. versionadded:: 2.7.0
    )unicode_literals)datetimetimeNc                 C   s"   t | }t | td| dS )a  
    Returns a :py:class:`datetime` representing the current day at midnight

    :param tzinfo:
        The time zone to attach (also used to determine the current day).

    :return:
        A :py:class:`datetime.datetime` object representing the current day
        at midnight.
    r   tzinfo)r   nowcombinedater   )r   dt r   OC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\utils.pytoday   s    
r   c                 C   s   | j dk	r| S | j|dS dS )a  
    Sets the ``tzinfo`` parameter on naive datetimes only

    This is useful for example when you are provided a datetime that may have
    either an implicit or explicit time zone, such as when parsing a time zone
    string.

    .. doctest::

        >>> from dateutil.tz import tzoffset
        >>> from dateutil.parser import parse
        >>> from dateutil.utils import default_tzinfo
        >>> dflt_tz = tzoffset("EST", -18000)
        >>> print(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))
        2014-01-01 12:30:00+00:00
        >>> print(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))
        2014-01-01 12:30:00-05:00

    :param dt:
        The datetime on which to replace the time zone

    :param tzinfo:
        The :py:class:`datetime.tzinfo` subclass instance to assign to
        ``dt`` if (and only if) it is naive.

    :return:
        Returns an aware :py:class:`datetime.datetime`.
    Nr   )r   replace)r
   r   r   r   r   default_tzinfo   s    
r   c                 C   s*   t |}| | }| |  ko$|kS   S )zh
    Useful for comparing two datetimes that may a negilible difference
    to be considered equal.
    )abs)Zdt1Zdt2delta
differencer   r   r   within_delta@   s    r   )N)__doc__
__future__r   r   r   r   r   r   r   r   r   r   <module>   s
   
#U
    ^                     @   s   d Z G dd deZdS )z'
Common code used in multiple modules.
c                   @   sF   e Zd Zd dgZdddZdd Zdd Zd	d
 Zdd Zdd Z	dS )weekdaynNc                 C   s   || _ || _d S Nr   r   )selfr   r    r   QC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\_common.py__init__	   s    zweekday.__init__c                 C   s    || j kr| S | | j|S d S r   )r   	__class__r   )r   r   r   r   r   __call__   s    
zweekday.__call__c                 C   s>   z"| j |j ks| j|jkr W dS W n tk
r8   Y dS X dS )NFT)r   r   AttributeErrorr   otherr   r   r   __eq__   s    
zweekday.__eq__c                 C   s   t | j| jfS r   )hashr   r   )r   r   r   r   __hash__   s    zweekday.__hash__c                 C   s
   | |k S r   r   r   r   r   r   __ne__!   s    zweekday.__ne__c                 C   s&   d| j  }| js|S d|| jf S d S )N)ZMOZTUZWEZTHZFRZSAZSUz%s(%+d)r   )r   sr   r   r   __repr__$   s    
zweekday.__repr__)N)
__name__
__module____qualname__	__slots__r   r
   r   r   r   r   r   r   r   r   r      s   
r   N)__doc__objectr   r   r   r   r   <module>   s   U
    ^t                      @   s   d Z dS )z2.8.1N)version r   r   RC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\_version.py<module>       U
    ^                      @   s@   zd dl mZ W n ek
r(   dZY nX ddddddd	gZd
S )   )versionunknownZeasterparserZrelativedeltaZrruletzutilsZzoneinfoN)_versionr   __version__ImportError__all__ r   r   RC:\Users\Admin\AppData\Local\Temp\pip-unpacked-wheel-uhi63lcx\dateutil\__init__.py<module>   s   

 import os
import arrow

class TestModule():
  def __init__(self):
    self.val = 0

  def incVal(self):
    self.val += 1

  def decVal(self):
    self.val -= 1

  def getTime(self):
    utc = arrow.utcnow()

    return utc.format('HH:mm:ss')from .test import TestModuleU
    ^,                      @   s   d d Z dS )c                 C   s   | | S )N )Zcurrvalr   r   /D:\Projects\Furcifer\example\test\val_setter.pyadd_val   s    r   N)r   r   r   r   r   <module>       